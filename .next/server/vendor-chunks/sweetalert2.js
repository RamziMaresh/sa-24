"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/sweetalert2";
exports.ids = ["vendor-chunks/sweetalert2"];
exports.modules = {

/***/ "(ssr)/./node_modules/sweetalert2/dist/sweetalert2.esm.all.js":
/*!**************************************************************!*\
  !*** ./node_modules/sweetalert2/dist/sweetalert2.esm.all.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Swal)\n/* harmony export */ });\n/*!\n* sweetalert2 v11.14.0\n* Released under the MIT License.\n*/ function _assertClassBrand(e, t, n) {\n    if (\"function\" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n;\n    throw new TypeError(\"Private element is not present on this object\");\n}\nfunction _checkPrivateRedeclaration(e, t) {\n    if (t.has(e)) throw new TypeError(\"Cannot initialize the same private elements twice on an object\");\n}\nfunction _classPrivateFieldGet2(s, a) {\n    return s.get(_assertClassBrand(s, a));\n}\nfunction _classPrivateFieldInitSpec(e, t, a) {\n    _checkPrivateRedeclaration(e, t), t.set(e, a);\n}\nfunction _classPrivateFieldSet2(s, a, r) {\n    return s.set(_assertClassBrand(s, a), r), r;\n}\nconst RESTORE_FOCUS_TIMEOUT = 100;\n/** @type {GlobalState} */ const globalState = {};\nconst focusPreviousActiveElement = ()=>{\n    if (globalState.previousActiveElement instanceof HTMLElement) {\n        globalState.previousActiveElement.focus();\n        globalState.previousActiveElement = null;\n    } else if (document.body) {\n        document.body.focus();\n    }\n};\n/**\n * Restore previous active (focused) element\n *\n * @param {boolean} returnFocus\n * @returns {Promise<void>}\n */ const restoreActiveElement = (returnFocus)=>{\n    return new Promise((resolve)=>{\n        if (!returnFocus) {\n            return resolve();\n        }\n        const x = window.scrollX;\n        const y = window.scrollY;\n        globalState.restoreFocusTimeout = setTimeout(()=>{\n            focusPreviousActiveElement();\n            resolve();\n        }, RESTORE_FOCUS_TIMEOUT); // issues/900\n        window.scrollTo(x, y);\n    });\n};\nconst swalPrefix = \"swal2-\";\n/**\n * @typedef {Record<SwalClass, string>} SwalClasses\n */ /**\n * @typedef {'success' | 'warning' | 'info' | 'question' | 'error'} SwalIcon\n * @typedef {Record<SwalIcon, string>} SwalIcons\n */ /** @type {SwalClass[]} */ const classNames = [\n    \"container\",\n    \"shown\",\n    \"height-auto\",\n    \"iosfix\",\n    \"popup\",\n    \"modal\",\n    \"no-backdrop\",\n    \"no-transition\",\n    \"toast\",\n    \"toast-shown\",\n    \"show\",\n    \"hide\",\n    \"close\",\n    \"title\",\n    \"html-container\",\n    \"actions\",\n    \"confirm\",\n    \"deny\",\n    \"cancel\",\n    \"default-outline\",\n    \"footer\",\n    \"icon\",\n    \"icon-content\",\n    \"image\",\n    \"input\",\n    \"file\",\n    \"range\",\n    \"select\",\n    \"radio\",\n    \"checkbox\",\n    \"label\",\n    \"textarea\",\n    \"inputerror\",\n    \"input-label\",\n    \"validation-message\",\n    \"progress-steps\",\n    \"active-progress-step\",\n    \"progress-step\",\n    \"progress-step-line\",\n    \"loader\",\n    \"loading\",\n    \"styled\",\n    \"top\",\n    \"top-start\",\n    \"top-end\",\n    \"top-left\",\n    \"top-right\",\n    \"center\",\n    \"center-start\",\n    \"center-end\",\n    \"center-left\",\n    \"center-right\",\n    \"bottom\",\n    \"bottom-start\",\n    \"bottom-end\",\n    \"bottom-left\",\n    \"bottom-right\",\n    \"grow-row\",\n    \"grow-column\",\n    \"grow-fullscreen\",\n    \"rtl\",\n    \"timer-progress-bar\",\n    \"timer-progress-bar-container\",\n    \"scrollbar-measure\",\n    \"icon-success\",\n    \"icon-warning\",\n    \"icon-info\",\n    \"icon-question\",\n    \"icon-error\"\n];\nconst swalClasses = classNames.reduce((acc, className)=>{\n    acc[className] = swalPrefix + className;\n    return acc;\n}, /** @type {SwalClasses} */ {});\n/** @type {SwalIcon[]} */ const icons = [\n    \"success\",\n    \"warning\",\n    \"info\",\n    \"question\",\n    \"error\"\n];\nconst iconTypes = icons.reduce((acc, icon)=>{\n    acc[icon] = swalPrefix + icon;\n    return acc;\n}, /** @type {SwalIcons} */ {});\nconst consolePrefix = \"SweetAlert2:\";\n/**\n * Capitalize the first letter of a string\n *\n * @param {string} str\n * @returns {string}\n */ const capitalizeFirstLetter = (str)=>str.charAt(0).toUpperCase() + str.slice(1);\n/**\n * Standardize console warnings\n *\n * @param {string | string[]} message\n */ const warn = (message)=>{\n    console.warn(`${consolePrefix} ${typeof message === \"object\" ? message.join(\" \") : message}`);\n};\n/**\n * Standardize console errors\n *\n * @param {string} message\n */ const error = (message)=>{\n    console.error(`${consolePrefix} ${message}`);\n};\n/**\n * Private global state for `warnOnce`\n *\n * @type {string[]}\n * @private\n */ const previousWarnOnceMessages = [];\n/**\n * Show a console warning, but only if it hasn't already been shown\n *\n * @param {string} message\n */ const warnOnce = (message)=>{\n    if (!previousWarnOnceMessages.includes(message)) {\n        previousWarnOnceMessages.push(message);\n        warn(message);\n    }\n};\n/**\n * Show a one-time console warning about deprecated params/methods\n *\n * @param {string} deprecatedParam\n * @param {string?} useInstead\n */ const warnAboutDeprecation = function(deprecatedParam) {\n    let useInstead = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    warnOnce(`\"${deprecatedParam}\" is deprecated and will be removed in the next major release.${useInstead ? ` Use \"${useInstead}\" instead.` : \"\"}`);\n};\n/**\n * If `arg` is a function, call it (with no arguments or context) and return the result.\n * Otherwise, just pass the value through\n *\n * @param {Function | any} arg\n * @returns {any}\n */ const callIfFunction = (arg)=>typeof arg === \"function\" ? arg() : arg;\n/**\n * @param {any} arg\n * @returns {boolean}\n */ const hasToPromiseFn = (arg)=>arg && typeof arg.toPromise === \"function\";\n/**\n * @param {any} arg\n * @returns {Promise<any>}\n */ const asPromise = (arg)=>hasToPromiseFn(arg) ? arg.toPromise() : Promise.resolve(arg);\n/**\n * @param {any} arg\n * @returns {boolean}\n */ const isPromise = (arg)=>arg && Promise.resolve(arg) === arg;\n/**\n * Gets the popup container which contains the backdrop and the popup itself.\n *\n * @returns {HTMLElement | null}\n */ const getContainer = ()=>document.body.querySelector(`.${swalClasses.container}`);\n/**\n * @param {string} selectorString\n * @returns {HTMLElement | null}\n */ const elementBySelector = (selectorString)=>{\n    const container = getContainer();\n    return container ? container.querySelector(selectorString) : null;\n};\n/**\n * @param {string} className\n * @returns {HTMLElement | null}\n */ const elementByClass = (className)=>{\n    return elementBySelector(`.${className}`);\n};\n/**\n * @returns {HTMLElement | null}\n */ const getPopup = ()=>elementByClass(swalClasses.popup);\n/**\n * @returns {HTMLElement | null}\n */ const getIcon = ()=>elementByClass(swalClasses.icon);\n/**\n * @returns {HTMLElement | null}\n */ const getIconContent = ()=>elementByClass(swalClasses[\"icon-content\"]);\n/**\n * @returns {HTMLElement | null}\n */ const getTitle = ()=>elementByClass(swalClasses.title);\n/**\n * @returns {HTMLElement | null}\n */ const getHtmlContainer = ()=>elementByClass(swalClasses[\"html-container\"]);\n/**\n * @returns {HTMLElement | null}\n */ const getImage = ()=>elementByClass(swalClasses.image);\n/**\n * @returns {HTMLElement | null}\n */ const getProgressSteps = ()=>elementByClass(swalClasses[\"progress-steps\"]);\n/**\n * @returns {HTMLElement | null}\n */ const getValidationMessage = ()=>elementByClass(swalClasses[\"validation-message\"]);\n/**\n * @returns {HTMLButtonElement | null}\n */ const getConfirmButton = ()=>/** @type {HTMLButtonElement} */ elementBySelector(`.${swalClasses.actions} .${swalClasses.confirm}`);\n/**\n * @returns {HTMLButtonElement | null}\n */ const getCancelButton = ()=>/** @type {HTMLButtonElement} */ elementBySelector(`.${swalClasses.actions} .${swalClasses.cancel}`);\n/**\n * @returns {HTMLButtonElement | null}\n */ const getDenyButton = ()=>/** @type {HTMLButtonElement} */ elementBySelector(`.${swalClasses.actions} .${swalClasses.deny}`);\n/**\n * @returns {HTMLElement | null}\n */ const getInputLabel = ()=>elementByClass(swalClasses[\"input-label\"]);\n/**\n * @returns {HTMLElement | null}\n */ const getLoader = ()=>elementBySelector(`.${swalClasses.loader}`);\n/**\n * @returns {HTMLElement | null}\n */ const getActions = ()=>elementByClass(swalClasses.actions);\n/**\n * @returns {HTMLElement | null}\n */ const getFooter = ()=>elementByClass(swalClasses.footer);\n/**\n * @returns {HTMLElement | null}\n */ const getTimerProgressBar = ()=>elementByClass(swalClasses[\"timer-progress-bar\"]);\n/**\n * @returns {HTMLElement | null}\n */ const getCloseButton = ()=>elementByClass(swalClasses.close);\n// https://github.com/jkup/focusable/blob/master/index.js\nconst focusable = `\n  a[href],\n  area[href],\n  input:not([disabled]),\n  select:not([disabled]),\n  textarea:not([disabled]),\n  button:not([disabled]),\n  iframe,\n  object,\n  embed,\n  [tabindex=\"0\"],\n  [contenteditable],\n  audio[controls],\n  video[controls],\n  summary\n`;\n/**\n * @returns {HTMLElement[]}\n */ const getFocusableElements = ()=>{\n    const popup = getPopup();\n    if (!popup) {\n        return [];\n    }\n    /** @type {NodeListOf<HTMLElement>} */ const focusableElementsWithTabindex = popup.querySelectorAll('[tabindex]:not([tabindex=\"-1\"]):not([tabindex=\"0\"])');\n    const focusableElementsWithTabindexSorted = Array.from(focusableElementsWithTabindex)// sort according to tabindex\n    .sort((a, b)=>{\n        const tabindexA = parseInt(a.getAttribute(\"tabindex\") || \"0\");\n        const tabindexB = parseInt(b.getAttribute(\"tabindex\") || \"0\");\n        if (tabindexA > tabindexB) {\n            return 1;\n        } else if (tabindexA < tabindexB) {\n            return -1;\n        }\n        return 0;\n    });\n    /** @type {NodeListOf<HTMLElement>} */ const otherFocusableElements = popup.querySelectorAll(focusable);\n    const otherFocusableElementsFiltered = Array.from(otherFocusableElements).filter((el)=>el.getAttribute(\"tabindex\") !== \"-1\");\n    return [\n        ...new Set(focusableElementsWithTabindexSorted.concat(otherFocusableElementsFiltered))\n    ].filter((el)=>isVisible$1(el));\n};\n/**\n * @returns {boolean}\n */ const isModal = ()=>{\n    return hasClass(document.body, swalClasses.shown) && !hasClass(document.body, swalClasses[\"toast-shown\"]) && !hasClass(document.body, swalClasses[\"no-backdrop\"]);\n};\n/**\n * @returns {boolean}\n */ const isToast = ()=>{\n    const popup = getPopup();\n    if (!popup) {\n        return false;\n    }\n    return hasClass(popup, swalClasses.toast);\n};\n/**\n * @returns {boolean}\n */ const isLoading = ()=>{\n    const popup = getPopup();\n    if (!popup) {\n        return false;\n    }\n    return popup.hasAttribute(\"data-loading\");\n};\n/**\n * Securely set innerHTML of an element\n * https://github.com/sweetalert2/sweetalert2/issues/1926\n *\n * @param {HTMLElement} elem\n * @param {string} html\n */ const setInnerHtml = (elem, html)=>{\n    elem.textContent = \"\";\n    if (html) {\n        const parser = new DOMParser();\n        const parsed = parser.parseFromString(html, `text/html`);\n        const head = parsed.querySelector(\"head\");\n        if (head) {\n            Array.from(head.childNodes).forEach((child)=>{\n                elem.appendChild(child);\n            });\n        }\n        const body = parsed.querySelector(\"body\");\n        if (body) {\n            Array.from(body.childNodes).forEach((child)=>{\n                if (child instanceof HTMLVideoElement || child instanceof HTMLAudioElement) {\n                    elem.appendChild(child.cloneNode(true)); // https://github.com/sweetalert2/sweetalert2/issues/2507\n                } else {\n                    elem.appendChild(child);\n                }\n            });\n        }\n    }\n};\n/**\n * @param {HTMLElement} elem\n * @param {string} className\n * @returns {boolean}\n */ const hasClass = (elem, className)=>{\n    if (!className) {\n        return false;\n    }\n    const classList = className.split(/\\s+/);\n    for(let i = 0; i < classList.length; i++){\n        if (!elem.classList.contains(classList[i])) {\n            return false;\n        }\n    }\n    return true;\n};\n/**\n * @param {HTMLElement} elem\n * @param {SweetAlertOptions} params\n */ const removeCustomClasses = (elem, params)=>{\n    Array.from(elem.classList).forEach((className)=>{\n        if (!Object.values(swalClasses).includes(className) && !Object.values(iconTypes).includes(className) && !Object.values(params.showClass || {}).includes(className)) {\n            elem.classList.remove(className);\n        }\n    });\n};\n/**\n * @param {HTMLElement} elem\n * @param {SweetAlertOptions} params\n * @param {string} className\n */ const applyCustomClass = (elem, params, className)=>{\n    removeCustomClasses(elem, params);\n    if (!params.customClass) {\n        return;\n    }\n    const customClass = params.customClass[/** @type {keyof SweetAlertCustomClass} */ className];\n    if (!customClass) {\n        return;\n    }\n    if (typeof customClass !== \"string\" && !customClass.forEach) {\n        warn(`Invalid type of customClass.${className}! Expected string or iterable object, got \"${typeof customClass}\"`);\n        return;\n    }\n    addClass(elem, customClass);\n};\n/**\n * @param {HTMLElement} popup\n * @param {import('./renderers/renderInput').InputClass | SweetAlertInput} inputClass\n * @returns {HTMLInputElement | null}\n */ const getInput$1 = (popup, inputClass)=>{\n    if (!inputClass) {\n        return null;\n    }\n    switch(inputClass){\n        case \"select\":\n        case \"textarea\":\n        case \"file\":\n            return popup.querySelector(`.${swalClasses.popup} > .${swalClasses[inputClass]}`);\n        case \"checkbox\":\n            return popup.querySelector(`.${swalClasses.popup} > .${swalClasses.checkbox} input`);\n        case \"radio\":\n            return popup.querySelector(`.${swalClasses.popup} > .${swalClasses.radio} input:checked`) || popup.querySelector(`.${swalClasses.popup} > .${swalClasses.radio} input:first-child`);\n        case \"range\":\n            return popup.querySelector(`.${swalClasses.popup} > .${swalClasses.range} input`);\n        default:\n            return popup.querySelector(`.${swalClasses.popup} > .${swalClasses.input}`);\n    }\n};\n/**\n * @param {HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement} input\n */ const focusInput = (input)=>{\n    input.focus();\n    // place cursor at end of text in text input\n    if (input.type !== \"file\") {\n        // http://stackoverflow.com/a/2345915\n        const val = input.value;\n        input.value = \"\";\n        input.value = val;\n    }\n};\n/**\n * @param {HTMLElement | HTMLElement[] | null} target\n * @param {string | string[] | readonly string[] | undefined} classList\n * @param {boolean} condition\n */ const toggleClass = (target, classList, condition)=>{\n    if (!target || !classList) {\n        return;\n    }\n    if (typeof classList === \"string\") {\n        classList = classList.split(/\\s+/).filter(Boolean);\n    }\n    classList.forEach((className)=>{\n        if (Array.isArray(target)) {\n            target.forEach((elem)=>{\n                if (condition) {\n                    elem.classList.add(className);\n                } else {\n                    elem.classList.remove(className);\n                }\n            });\n        } else {\n            if (condition) {\n                target.classList.add(className);\n            } else {\n                target.classList.remove(className);\n            }\n        }\n    });\n};\n/**\n * @param {HTMLElement | HTMLElement[] | null} target\n * @param {string | string[] | readonly string[] | undefined} classList\n */ const addClass = (target, classList)=>{\n    toggleClass(target, classList, true);\n};\n/**\n * @param {HTMLElement | HTMLElement[] | null} target\n * @param {string | string[] | readonly string[] | undefined} classList\n */ const removeClass = (target, classList)=>{\n    toggleClass(target, classList, false);\n};\n/**\n * Get direct child of an element by class name\n *\n * @param {HTMLElement} elem\n * @param {string} className\n * @returns {HTMLElement | undefined}\n */ const getDirectChildByClass = (elem, className)=>{\n    const children = Array.from(elem.children);\n    for(let i = 0; i < children.length; i++){\n        const child = children[i];\n        if (child instanceof HTMLElement && hasClass(child, className)) {\n            return child;\n        }\n    }\n};\n/**\n * @param {HTMLElement} elem\n * @param {string} property\n * @param {*} value\n */ const applyNumericalStyle = (elem, property, value)=>{\n    if (value === `${parseInt(value)}`) {\n        value = parseInt(value);\n    }\n    if (value || parseInt(value) === 0) {\n        elem.style.setProperty(property, typeof value === \"number\" ? `${value}px` : value);\n    } else {\n        elem.style.removeProperty(property);\n    }\n};\n/**\n * @param {HTMLElement | null} elem\n * @param {string} display\n */ const show = function(elem) {\n    let display = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"flex\";\n    if (!elem) {\n        return;\n    }\n    elem.style.display = display;\n};\n/**\n * @param {HTMLElement | null} elem\n */ const hide = (elem)=>{\n    if (!elem) {\n        return;\n    }\n    elem.style.display = \"none\";\n};\n/**\n * @param {HTMLElement | null} elem\n * @param {string} display\n */ const showWhenInnerHtmlPresent = function(elem) {\n    let display = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"block\";\n    if (!elem) {\n        return;\n    }\n    new MutationObserver(()=>{\n        toggle(elem, elem.innerHTML, display);\n    }).observe(elem, {\n        childList: true,\n        subtree: true\n    });\n};\n/**\n * @param {HTMLElement} parent\n * @param {string} selector\n * @param {string} property\n * @param {string} value\n */ const setStyle = (parent, selector, property, value)=>{\n    /** @type {HTMLElement | null} */ const el = parent.querySelector(selector);\n    if (el) {\n        el.style.setProperty(property, value);\n    }\n};\n/**\n * @param {HTMLElement} elem\n * @param {any} condition\n * @param {string} display\n */ const toggle = function(elem, condition) {\n    let display = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"flex\";\n    if (condition) {\n        show(elem, display);\n    } else {\n        hide(elem);\n    }\n};\n/**\n * borrowed from jquery $(elem).is(':visible') implementation\n *\n * @param {HTMLElement | null} elem\n * @returns {boolean}\n */ const isVisible$1 = (elem)=>!!(elem && (elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length));\n/**\n * @returns {boolean}\n */ const allButtonsAreHidden = ()=>!isVisible$1(getConfirmButton()) && !isVisible$1(getDenyButton()) && !isVisible$1(getCancelButton());\n/**\n * @param {HTMLElement} elem\n * @returns {boolean}\n */ const isScrollable = (elem)=>!!(elem.scrollHeight > elem.clientHeight);\n/**\n * borrowed from https://stackoverflow.com/a/46352119\n *\n * @param {HTMLElement} elem\n * @returns {boolean}\n */ const hasCssAnimation = (elem)=>{\n    const style = window.getComputedStyle(elem);\n    const animDuration = parseFloat(style.getPropertyValue(\"animation-duration\") || \"0\");\n    const transDuration = parseFloat(style.getPropertyValue(\"transition-duration\") || \"0\");\n    return animDuration > 0 || transDuration > 0;\n};\n/**\n * @param {number} timer\n * @param {boolean} reset\n */ const animateTimerProgressBar = function(timer) {\n    let reset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    const timerProgressBar = getTimerProgressBar();\n    if (!timerProgressBar) {\n        return;\n    }\n    if (isVisible$1(timerProgressBar)) {\n        if (reset) {\n            timerProgressBar.style.transition = \"none\";\n            timerProgressBar.style.width = \"100%\";\n        }\n        setTimeout(()=>{\n            timerProgressBar.style.transition = `width ${timer / 1000}s linear`;\n            timerProgressBar.style.width = \"0%\";\n        }, 10);\n    }\n};\nconst stopTimerProgressBar = ()=>{\n    const timerProgressBar = getTimerProgressBar();\n    if (!timerProgressBar) {\n        return;\n    }\n    const timerProgressBarWidth = parseInt(window.getComputedStyle(timerProgressBar).width);\n    timerProgressBar.style.removeProperty(\"transition\");\n    timerProgressBar.style.width = \"100%\";\n    const timerProgressBarFullWidth = parseInt(window.getComputedStyle(timerProgressBar).width);\n    const timerProgressBarPercent = timerProgressBarWidth / timerProgressBarFullWidth * 100;\n    timerProgressBar.style.width = `${timerProgressBarPercent}%`;\n};\n/**\n * Detect Node env\n *\n * @returns {boolean}\n */ const isNodeEnv = ()=> true || 0;\nconst sweetHTML = `\n <div aria-labelledby=\"${swalClasses.title}\" aria-describedby=\"${swalClasses[\"html-container\"]}\" class=\"${swalClasses.popup}\" tabindex=\"-1\">\n   <button type=\"button\" class=\"${swalClasses.close}\"></button>\n   <ul class=\"${swalClasses[\"progress-steps\"]}\"></ul>\n   <div class=\"${swalClasses.icon}\"></div>\n   <img class=\"${swalClasses.image}\" />\n   <h2 class=\"${swalClasses.title}\" id=\"${swalClasses.title}\"></h2>\n   <div class=\"${swalClasses[\"html-container\"]}\" id=\"${swalClasses[\"html-container\"]}\"></div>\n   <input class=\"${swalClasses.input}\" id=\"${swalClasses.input}\" />\n   <input type=\"file\" class=\"${swalClasses.file}\" />\n   <div class=\"${swalClasses.range}\">\n     <input type=\"range\" />\n     <output></output>\n   </div>\n   <select class=\"${swalClasses.select}\" id=\"${swalClasses.select}\"></select>\n   <div class=\"${swalClasses.radio}\"></div>\n   <label class=\"${swalClasses.checkbox}\">\n     <input type=\"checkbox\" id=\"${swalClasses.checkbox}\" />\n     <span class=\"${swalClasses.label}\"></span>\n   </label>\n   <textarea class=\"${swalClasses.textarea}\" id=\"${swalClasses.textarea}\"></textarea>\n   <div class=\"${swalClasses[\"validation-message\"]}\" id=\"${swalClasses[\"validation-message\"]}\"></div>\n   <div class=\"${swalClasses.actions}\">\n     <div class=\"${swalClasses.loader}\"></div>\n     <button type=\"button\" class=\"${swalClasses.confirm}\"></button>\n     <button type=\"button\" class=\"${swalClasses.deny}\"></button>\n     <button type=\"button\" class=\"${swalClasses.cancel}\"></button>\n   </div>\n   <div class=\"${swalClasses.footer}\"></div>\n   <div class=\"${swalClasses[\"timer-progress-bar-container\"]}\">\n     <div class=\"${swalClasses[\"timer-progress-bar\"]}\"></div>\n   </div>\n </div>\n`.replace(/(^|\\n)\\s*/g, \"\");\n/**\n * @returns {boolean}\n */ const resetOldContainer = ()=>{\n    const oldContainer = getContainer();\n    if (!oldContainer) {\n        return false;\n    }\n    oldContainer.remove();\n    removeClass([\n        document.documentElement,\n        document.body\n    ], [\n        swalClasses[\"no-backdrop\"],\n        swalClasses[\"toast-shown\"],\n        swalClasses[\"has-column\"]\n    ]);\n    return true;\n};\nconst resetValidationMessage$1 = ()=>{\n    globalState.currentInstance.resetValidationMessage();\n};\nconst addInputChangeListeners = ()=>{\n    const popup = getPopup();\n    const input = getDirectChildByClass(popup, swalClasses.input);\n    const file = getDirectChildByClass(popup, swalClasses.file);\n    /** @type {HTMLInputElement} */ const range = popup.querySelector(`.${swalClasses.range} input`);\n    /** @type {HTMLOutputElement} */ const rangeOutput = popup.querySelector(`.${swalClasses.range} output`);\n    const select = getDirectChildByClass(popup, swalClasses.select);\n    /** @type {HTMLInputElement} */ const checkbox = popup.querySelector(`.${swalClasses.checkbox} input`);\n    const textarea = getDirectChildByClass(popup, swalClasses.textarea);\n    input.oninput = resetValidationMessage$1;\n    file.onchange = resetValidationMessage$1;\n    select.onchange = resetValidationMessage$1;\n    checkbox.onchange = resetValidationMessage$1;\n    textarea.oninput = resetValidationMessage$1;\n    range.oninput = ()=>{\n        resetValidationMessage$1();\n        rangeOutput.value = range.value;\n    };\n    range.onchange = ()=>{\n        resetValidationMessage$1();\n        rangeOutput.value = range.value;\n    };\n};\n/**\n * @param {string | HTMLElement} target\n * @returns {HTMLElement}\n */ const getTarget = (target)=>typeof target === \"string\" ? document.querySelector(target) : target;\n/**\n * @param {SweetAlertOptions} params\n */ const setupAccessibility = (params)=>{\n    const popup = getPopup();\n    popup.setAttribute(\"role\", params.toast ? \"alert\" : \"dialog\");\n    popup.setAttribute(\"aria-live\", params.toast ? \"polite\" : \"assertive\");\n    if (!params.toast) {\n        popup.setAttribute(\"aria-modal\", \"true\");\n    }\n};\n/**\n * @param {HTMLElement} targetElement\n */ const setupRTL = (targetElement)=>{\n    if (window.getComputedStyle(targetElement).direction === \"rtl\") {\n        addClass(getContainer(), swalClasses.rtl);\n    }\n};\n/**\n * Add modal + backdrop + no-war message for Russians to DOM\n *\n * @param {SweetAlertOptions} params\n */ const init = (params)=>{\n    // Clean up the old popup container if it exists\n    const oldContainerExisted = resetOldContainer();\n    if (isNodeEnv()) {\n        error(\"SweetAlert2 requires document to initialize\");\n        return;\n    }\n    const container = document.createElement(\"div\");\n    container.className = swalClasses.container;\n    if (oldContainerExisted) {\n        addClass(container, swalClasses[\"no-transition\"]);\n    }\n    setInnerHtml(container, sweetHTML);\n    const targetElement = getTarget(params.target);\n    targetElement.appendChild(container);\n    setupAccessibility(params);\n    setupRTL(targetElement);\n    addInputChangeListeners();\n};\n/**\n * @param {HTMLElement | object | string} param\n * @param {HTMLElement} target\n */ const parseHtmlToContainer = (param, target)=>{\n    // DOM element\n    if (param instanceof HTMLElement) {\n        target.appendChild(param);\n    } else if (typeof param === \"object\") {\n        handleObject(param, target);\n    } else if (param) {\n        setInnerHtml(target, param);\n    }\n};\n/**\n * @param {any} param\n * @param {HTMLElement} target\n */ const handleObject = (param, target)=>{\n    // JQuery element(s)\n    if (param.jquery) {\n        handleJqueryElem(target, param);\n    } else {\n        setInnerHtml(target, param.toString());\n    }\n};\n/**\n * @param {HTMLElement} target\n * @param {any} elem\n */ const handleJqueryElem = (target, elem)=>{\n    target.textContent = \"\";\n    if (0 in elem) {\n        for(let i = 0; (i in elem); i++){\n            target.appendChild(elem[i].cloneNode(true));\n        }\n    } else {\n        target.appendChild(elem.cloneNode(true));\n    }\n};\n/**\n * @returns {'webkitAnimationEnd' | 'animationend' | false}\n */ const animationEndEvent = (()=>{\n    // Prevent run in Node env\n    if (isNodeEnv()) {\n        return false;\n    }\n    const testEl = document.createElement(\"div\");\n    // Chrome, Safari and Opera\n    if (typeof testEl.style.webkitAnimation !== \"undefined\") {\n        return \"webkitAnimationEnd\";\n    }\n    // Standard syntax\n    if (typeof testEl.style.animation !== \"undefined\") {\n        return \"animationend\";\n    }\n    return false;\n})();\n/**\n * @param {SweetAlert} instance\n * @param {SweetAlertOptions} params\n */ const renderActions = (instance, params)=>{\n    const actions = getActions();\n    const loader = getLoader();\n    if (!actions || !loader) {\n        return;\n    }\n    // Actions (buttons) wrapper\n    if (!params.showConfirmButton && !params.showDenyButton && !params.showCancelButton) {\n        hide(actions);\n    } else {\n        show(actions);\n    }\n    // Custom class\n    applyCustomClass(actions, params, \"actions\");\n    // Render all the buttons\n    renderButtons(actions, loader, params);\n    // Loader\n    setInnerHtml(loader, params.loaderHtml || \"\");\n    applyCustomClass(loader, params, \"loader\");\n};\n/**\n * @param {HTMLElement} actions\n * @param {HTMLElement} loader\n * @param {SweetAlertOptions} params\n */ function renderButtons(actions, loader, params) {\n    const confirmButton = getConfirmButton();\n    const denyButton = getDenyButton();\n    const cancelButton = getCancelButton();\n    if (!confirmButton || !denyButton || !cancelButton) {\n        return;\n    }\n    // Render buttons\n    renderButton(confirmButton, \"confirm\", params);\n    renderButton(denyButton, \"deny\", params);\n    renderButton(cancelButton, \"cancel\", params);\n    handleButtonsStyling(confirmButton, denyButton, cancelButton, params);\n    if (params.reverseButtons) {\n        if (params.toast) {\n            actions.insertBefore(cancelButton, confirmButton);\n            actions.insertBefore(denyButton, confirmButton);\n        } else {\n            actions.insertBefore(cancelButton, loader);\n            actions.insertBefore(denyButton, loader);\n            actions.insertBefore(confirmButton, loader);\n        }\n    }\n}\n/**\n * @param {HTMLElement} confirmButton\n * @param {HTMLElement} denyButton\n * @param {HTMLElement} cancelButton\n * @param {SweetAlertOptions} params\n */ function handleButtonsStyling(confirmButton, denyButton, cancelButton, params) {\n    if (!params.buttonsStyling) {\n        removeClass([\n            confirmButton,\n            denyButton,\n            cancelButton\n        ], swalClasses.styled);\n        return;\n    }\n    addClass([\n        confirmButton,\n        denyButton,\n        cancelButton\n    ], swalClasses.styled);\n    // Buttons background colors\n    if (params.confirmButtonColor) {\n        confirmButton.style.backgroundColor = params.confirmButtonColor;\n        addClass(confirmButton, swalClasses[\"default-outline\"]);\n    }\n    if (params.denyButtonColor) {\n        denyButton.style.backgroundColor = params.denyButtonColor;\n        addClass(denyButton, swalClasses[\"default-outline\"]);\n    }\n    if (params.cancelButtonColor) {\n        cancelButton.style.backgroundColor = params.cancelButtonColor;\n        addClass(cancelButton, swalClasses[\"default-outline\"]);\n    }\n}\n/**\n * @param {HTMLElement} button\n * @param {'confirm' | 'deny' | 'cancel'} buttonType\n * @param {SweetAlertOptions} params\n */ function renderButton(button, buttonType, params) {\n    const buttonName = /** @type {'Confirm' | 'Deny' | 'Cancel'} */ capitalizeFirstLetter(buttonType);\n    toggle(button, params[`show${buttonName}Button`], \"inline-block\");\n    setInnerHtml(button, params[`${buttonType}ButtonText`] || \"\"); // Set caption text\n    button.setAttribute(\"aria-label\", params[`${buttonType}ButtonAriaLabel`] || \"\"); // ARIA label\n    // Add buttons custom classes\n    button.className = swalClasses[buttonType];\n    applyCustomClass(button, params, `${buttonType}Button`);\n}\n/**\n * @param {SweetAlert} instance\n * @param {SweetAlertOptions} params\n */ const renderCloseButton = (instance, params)=>{\n    const closeButton = getCloseButton();\n    if (!closeButton) {\n        return;\n    }\n    setInnerHtml(closeButton, params.closeButtonHtml || \"\");\n    // Custom class\n    applyCustomClass(closeButton, params, \"closeButton\");\n    toggle(closeButton, params.showCloseButton);\n    closeButton.setAttribute(\"aria-label\", params.closeButtonAriaLabel || \"\");\n};\n/**\n * @param {SweetAlert} instance\n * @param {SweetAlertOptions} params\n */ const renderContainer = (instance, params)=>{\n    const container = getContainer();\n    if (!container) {\n        return;\n    }\n    handleBackdropParam(container, params.backdrop);\n    handlePositionParam(container, params.position);\n    handleGrowParam(container, params.grow);\n    // Custom class\n    applyCustomClass(container, params, \"container\");\n};\n/**\n * @param {HTMLElement} container\n * @param {SweetAlertOptions['backdrop']} backdrop\n */ function handleBackdropParam(container, backdrop) {\n    if (typeof backdrop === \"string\") {\n        container.style.background = backdrop;\n    } else if (!backdrop) {\n        addClass([\n            document.documentElement,\n            document.body\n        ], swalClasses[\"no-backdrop\"]);\n    }\n}\n/**\n * @param {HTMLElement} container\n * @param {SweetAlertOptions['position']} position\n */ function handlePositionParam(container, position) {\n    if (!position) {\n        return;\n    }\n    if (position in swalClasses) {\n        addClass(container, swalClasses[position]);\n    } else {\n        warn('The \"position\" parameter is not valid, defaulting to \"center\"');\n        addClass(container, swalClasses.center);\n    }\n}\n/**\n * @param {HTMLElement} container\n * @param {SweetAlertOptions['grow']} grow\n */ function handleGrowParam(container, grow) {\n    if (!grow) {\n        return;\n    }\n    addClass(container, swalClasses[`grow-${grow}`]);\n}\n/**\n * This module contains `WeakMap`s for each effectively-\"private  property\" that a `Swal` has.\n * For example, to set the private property \"foo\" of `this` to \"bar\", you can `privateProps.foo.set(this, 'bar')`\n * This is the approach that Babel will probably take to implement private methods/fields\n *   https://github.com/tc39/proposal-private-methods\n *   https://github.com/babel/babel/pull/7555\n * Once we have the changes from that PR in Babel, and our core class fits reasonable in *one module*\n *   then we can use that language feature.\n */ var privateProps = {\n    innerParams: new WeakMap(),\n    domCache: new WeakMap()\n};\n/// <reference path=\"../../../../sweetalert2.d.ts\"/>\n/** @type {InputClass[]} */ const inputClasses = [\n    \"input\",\n    \"file\",\n    \"range\",\n    \"select\",\n    \"radio\",\n    \"checkbox\",\n    \"textarea\"\n];\n/**\n * @param {SweetAlert} instance\n * @param {SweetAlertOptions} params\n */ const renderInput = (instance, params)=>{\n    const popup = getPopup();\n    if (!popup) {\n        return;\n    }\n    const innerParams = privateProps.innerParams.get(instance);\n    const rerender = !innerParams || params.input !== innerParams.input;\n    inputClasses.forEach((inputClass)=>{\n        const inputContainer = getDirectChildByClass(popup, swalClasses[inputClass]);\n        if (!inputContainer) {\n            return;\n        }\n        // set attributes\n        setAttributes(inputClass, params.inputAttributes);\n        // set class\n        inputContainer.className = swalClasses[inputClass];\n        if (rerender) {\n            hide(inputContainer);\n        }\n    });\n    if (params.input) {\n        if (rerender) {\n            showInput(params);\n        }\n        // set custom class\n        setCustomClass(params);\n    }\n};\n/**\n * @param {SweetAlertOptions} params\n */ const showInput = (params)=>{\n    if (!params.input) {\n        return;\n    }\n    if (!renderInputType[params.input]) {\n        error(`Unexpected type of input! Expected ${Object.keys(renderInputType).join(\" | \")}, got \"${params.input}\"`);\n        return;\n    }\n    const inputContainer = getInputContainer(params.input);\n    if (!inputContainer) {\n        return;\n    }\n    const input = renderInputType[params.input](inputContainer, params);\n    show(inputContainer);\n    // input autofocus\n    if (params.inputAutoFocus) {\n        setTimeout(()=>{\n            focusInput(input);\n        });\n    }\n};\n/**\n * @param {HTMLInputElement} input\n */ const removeAttributes = (input)=>{\n    for(let i = 0; i < input.attributes.length; i++){\n        const attrName = input.attributes[i].name;\n        if (![\n            \"id\",\n            \"type\",\n            \"value\",\n            \"style\"\n        ].includes(attrName)) {\n            input.removeAttribute(attrName);\n        }\n    }\n};\n/**\n * @param {InputClass} inputClass\n * @param {SweetAlertOptions['inputAttributes']} inputAttributes\n */ const setAttributes = (inputClass, inputAttributes)=>{\n    const popup = getPopup();\n    if (!popup) {\n        return;\n    }\n    const input = getInput$1(popup, inputClass);\n    if (!input) {\n        return;\n    }\n    removeAttributes(input);\n    for(const attr in inputAttributes){\n        input.setAttribute(attr, inputAttributes[attr]);\n    }\n};\n/**\n * @param {SweetAlertOptions} params\n */ const setCustomClass = (params)=>{\n    if (!params.input) {\n        return;\n    }\n    const inputContainer = getInputContainer(params.input);\n    if (inputContainer) {\n        applyCustomClass(inputContainer, params, \"input\");\n    }\n};\n/**\n * @param {HTMLInputElement | HTMLTextAreaElement} input\n * @param {SweetAlertOptions} params\n */ const setInputPlaceholder = (input, params)=>{\n    if (!input.placeholder && params.inputPlaceholder) {\n        input.placeholder = params.inputPlaceholder;\n    }\n};\n/**\n * @param {Input} input\n * @param {Input} prependTo\n * @param {SweetAlertOptions} params\n */ const setInputLabel = (input, prependTo, params)=>{\n    if (params.inputLabel) {\n        const label = document.createElement(\"label\");\n        const labelClass = swalClasses[\"input-label\"];\n        label.setAttribute(\"for\", input.id);\n        label.className = labelClass;\n        if (typeof params.customClass === \"object\") {\n            addClass(label, params.customClass.inputLabel);\n        }\n        label.innerText = params.inputLabel;\n        prependTo.insertAdjacentElement(\"beforebegin\", label);\n    }\n};\n/**\n * @param {SweetAlertInput} inputType\n * @returns {HTMLElement | undefined}\n */ const getInputContainer = (inputType)=>{\n    const popup = getPopup();\n    if (!popup) {\n        return;\n    }\n    return getDirectChildByClass(popup, swalClasses[/** @type {SwalClass} */ inputType] || swalClasses.input);\n};\n/**\n * @param {HTMLInputElement | HTMLOutputElement | HTMLTextAreaElement} input\n * @param {SweetAlertOptions['inputValue']} inputValue\n */ const checkAndSetInputValue = (input, inputValue)=>{\n    if ([\n        \"string\",\n        \"number\"\n    ].includes(typeof inputValue)) {\n        input.value = `${inputValue}`;\n    } else if (!isPromise(inputValue)) {\n        warn(`Unexpected type of inputValue! Expected \"string\", \"number\" or \"Promise\", got \"${typeof inputValue}\"`);\n    }\n};\n/** @type {Record<SweetAlertInput, (input: Input | HTMLElement, params: SweetAlertOptions) => Input>} */ const renderInputType = {};\n/**\n * @param {HTMLInputElement} input\n * @param {SweetAlertOptions} params\n * @returns {HTMLInputElement}\n */ renderInputType.text = renderInputType.email = renderInputType.password = renderInputType.number = renderInputType.tel = renderInputType.url = renderInputType.search = renderInputType.date = renderInputType[\"datetime-local\"] = renderInputType.time = renderInputType.week = renderInputType.month = /** @type {(input: Input | HTMLElement, params: SweetAlertOptions) => Input} */ (input, params)=>{\n    checkAndSetInputValue(input, params.inputValue);\n    setInputLabel(input, input, params);\n    setInputPlaceholder(input, params);\n    input.type = params.input;\n    return input;\n};\n/**\n * @param {HTMLInputElement} input\n * @param {SweetAlertOptions} params\n * @returns {HTMLInputElement}\n */ renderInputType.file = (input, params)=>{\n    setInputLabel(input, input, params);\n    setInputPlaceholder(input, params);\n    return input;\n};\n/**\n * @param {HTMLInputElement} range\n * @param {SweetAlertOptions} params\n * @returns {HTMLInputElement}\n */ renderInputType.range = (range, params)=>{\n    const rangeInput = range.querySelector(\"input\");\n    const rangeOutput = range.querySelector(\"output\");\n    checkAndSetInputValue(rangeInput, params.inputValue);\n    rangeInput.type = params.input;\n    checkAndSetInputValue(rangeOutput, params.inputValue);\n    setInputLabel(rangeInput, range, params);\n    return range;\n};\n/**\n * @param {HTMLSelectElement} select\n * @param {SweetAlertOptions} params\n * @returns {HTMLSelectElement}\n */ renderInputType.select = (select, params)=>{\n    select.textContent = \"\";\n    if (params.inputPlaceholder) {\n        const placeholder = document.createElement(\"option\");\n        setInnerHtml(placeholder, params.inputPlaceholder);\n        placeholder.value = \"\";\n        placeholder.disabled = true;\n        placeholder.selected = true;\n        select.appendChild(placeholder);\n    }\n    setInputLabel(select, select, params);\n    return select;\n};\n/**\n * @param {HTMLInputElement} radio\n * @returns {HTMLInputElement}\n */ renderInputType.radio = (radio)=>{\n    radio.textContent = \"\";\n    return radio;\n};\n/**\n * @param {HTMLLabelElement} checkboxContainer\n * @param {SweetAlertOptions} params\n * @returns {HTMLInputElement}\n */ renderInputType.checkbox = (checkboxContainer, params)=>{\n    const checkbox = getInput$1(getPopup(), \"checkbox\");\n    checkbox.value = \"1\";\n    checkbox.checked = Boolean(params.inputValue);\n    const label = checkboxContainer.querySelector(\"span\");\n    setInnerHtml(label, params.inputPlaceholder || params.inputLabel);\n    return checkbox;\n};\n/**\n * @param {HTMLTextAreaElement} textarea\n * @param {SweetAlertOptions} params\n * @returns {HTMLTextAreaElement}\n */ renderInputType.textarea = (textarea, params)=>{\n    checkAndSetInputValue(textarea, params.inputValue);\n    setInputPlaceholder(textarea, params);\n    setInputLabel(textarea, textarea, params);\n    /**\n   * @param {HTMLElement} el\n   * @returns {number}\n   */ const getMargin = (el)=>parseInt(window.getComputedStyle(el).marginLeft) + parseInt(window.getComputedStyle(el).marginRight);\n    // https://github.com/sweetalert2/sweetalert2/issues/2291\n    setTimeout(()=>{\n        // https://github.com/sweetalert2/sweetalert2/issues/1699\n        if (\"MutationObserver\" in window) {\n            const initialPopupWidth = parseInt(window.getComputedStyle(getPopup()).width);\n            const textareaResizeHandler = ()=>{\n                // check if texarea is still in document (i.e. popup wasn't closed in the meantime)\n                if (!document.body.contains(textarea)) {\n                    return;\n                }\n                const textareaWidth = textarea.offsetWidth + getMargin(textarea);\n                if (textareaWidth > initialPopupWidth) {\n                    getPopup().style.width = `${textareaWidth}px`;\n                } else {\n                    applyNumericalStyle(getPopup(), \"width\", params.width);\n                }\n            };\n            new MutationObserver(textareaResizeHandler).observe(textarea, {\n                attributes: true,\n                attributeFilter: [\n                    \"style\"\n                ]\n            });\n        }\n    });\n    return textarea;\n};\n/**\n * @param {SweetAlert} instance\n * @param {SweetAlertOptions} params\n */ const renderContent = (instance, params)=>{\n    const htmlContainer = getHtmlContainer();\n    if (!htmlContainer) {\n        return;\n    }\n    showWhenInnerHtmlPresent(htmlContainer);\n    applyCustomClass(htmlContainer, params, \"htmlContainer\");\n    // Content as HTML\n    if (params.html) {\n        parseHtmlToContainer(params.html, htmlContainer);\n        show(htmlContainer, \"block\");\n    } else if (params.text) {\n        htmlContainer.textContent = params.text;\n        show(htmlContainer, \"block\");\n    } else {\n        hide(htmlContainer);\n    }\n    renderInput(instance, params);\n};\n/**\n * @param {SweetAlert} instance\n * @param {SweetAlertOptions} params\n */ const renderFooter = (instance, params)=>{\n    const footer = getFooter();\n    if (!footer) {\n        return;\n    }\n    showWhenInnerHtmlPresent(footer);\n    toggle(footer, params.footer, \"block\");\n    if (params.footer) {\n        parseHtmlToContainer(params.footer, footer);\n    }\n    // Custom class\n    applyCustomClass(footer, params, \"footer\");\n};\n/**\n * @param {SweetAlert} instance\n * @param {SweetAlertOptions} params\n */ const renderIcon = (instance, params)=>{\n    const innerParams = privateProps.innerParams.get(instance);\n    const icon = getIcon();\n    if (!icon) {\n        return;\n    }\n    // if the given icon already rendered, apply the styling without re-rendering the icon\n    if (innerParams && params.icon === innerParams.icon) {\n        // Custom or default content\n        setContent(icon, params);\n        applyStyles(icon, params);\n        return;\n    }\n    if (!params.icon && !params.iconHtml) {\n        hide(icon);\n        return;\n    }\n    if (params.icon && Object.keys(iconTypes).indexOf(params.icon) === -1) {\n        error(`Unknown icon! Expected \"success\", \"error\", \"warning\", \"info\" or \"question\", got \"${params.icon}\"`);\n        hide(icon);\n        return;\n    }\n    show(icon);\n    // Custom or default content\n    setContent(icon, params);\n    applyStyles(icon, params);\n    // Animate icon\n    addClass(icon, params.showClass && params.showClass.icon);\n};\n/**\n * @param {HTMLElement} icon\n * @param {SweetAlertOptions} params\n */ const applyStyles = (icon, params)=>{\n    for (const [iconType, iconClassName] of Object.entries(iconTypes)){\n        if (params.icon !== iconType) {\n            removeClass(icon, iconClassName);\n        }\n    }\n    addClass(icon, params.icon && iconTypes[params.icon]);\n    // Icon color\n    setColor(icon, params);\n    // Success icon background color\n    adjustSuccessIconBackgroundColor();\n    // Custom class\n    applyCustomClass(icon, params, \"icon\");\n};\n// Adjust success icon background color to match the popup background color\nconst adjustSuccessIconBackgroundColor = ()=>{\n    const popup = getPopup();\n    if (!popup) {\n        return;\n    }\n    const popupBackgroundColor = window.getComputedStyle(popup).getPropertyValue(\"background-color\");\n    /** @type {NodeListOf<HTMLElement>} */ const successIconParts = popup.querySelectorAll(\"[class^=swal2-success-circular-line], .swal2-success-fix\");\n    for(let i = 0; i < successIconParts.length; i++){\n        successIconParts[i].style.backgroundColor = popupBackgroundColor;\n    }\n};\nconst successIconHtml = `\n  <div class=\"swal2-success-circular-line-left\"></div>\n  <span class=\"swal2-success-line-tip\"></span> <span class=\"swal2-success-line-long\"></span>\n  <div class=\"swal2-success-ring\"></div> <div class=\"swal2-success-fix\"></div>\n  <div class=\"swal2-success-circular-line-right\"></div>\n`;\nconst errorIconHtml = `\n  <span class=\"swal2-x-mark\">\n    <span class=\"swal2-x-mark-line-left\"></span>\n    <span class=\"swal2-x-mark-line-right\"></span>\n  </span>\n`;\n/**\n * @param {HTMLElement} icon\n * @param {SweetAlertOptions} params\n */ const setContent = (icon, params)=>{\n    if (!params.icon && !params.iconHtml) {\n        return;\n    }\n    let oldContent = icon.innerHTML;\n    let newContent = \"\";\n    if (params.iconHtml) {\n        newContent = iconContent(params.iconHtml);\n    } else if (params.icon === \"success\") {\n        newContent = successIconHtml;\n        oldContent = oldContent.replace(/ style=\".*?\"/g, \"\"); // undo adjustSuccessIconBackgroundColor()\n    } else if (params.icon === \"error\") {\n        newContent = errorIconHtml;\n    } else if (params.icon) {\n        const defaultIconHtml = {\n            question: \"?\",\n            warning: \"!\",\n            info: \"i\"\n        };\n        newContent = iconContent(defaultIconHtml[params.icon]);\n    }\n    if (oldContent.trim() !== newContent.trim()) {\n        setInnerHtml(icon, newContent);\n    }\n};\n/**\n * @param {HTMLElement} icon\n * @param {SweetAlertOptions} params\n */ const setColor = (icon, params)=>{\n    if (!params.iconColor) {\n        return;\n    }\n    icon.style.color = params.iconColor;\n    icon.style.borderColor = params.iconColor;\n    for (const sel of [\n        \".swal2-success-line-tip\",\n        \".swal2-success-line-long\",\n        \".swal2-x-mark-line-left\",\n        \".swal2-x-mark-line-right\"\n    ]){\n        setStyle(icon, sel, \"background-color\", params.iconColor);\n    }\n    setStyle(icon, \".swal2-success-ring\", \"border-color\", params.iconColor);\n};\n/**\n * @param {string} content\n * @returns {string}\n */ const iconContent = (content)=>`<div class=\"${swalClasses[\"icon-content\"]}\">${content}</div>`;\n/**\n * @param {SweetAlert} instance\n * @param {SweetAlertOptions} params\n */ const renderImage = (instance, params)=>{\n    const image = getImage();\n    if (!image) {\n        return;\n    }\n    if (!params.imageUrl) {\n        hide(image);\n        return;\n    }\n    show(image, \"\");\n    // Src, alt\n    image.setAttribute(\"src\", params.imageUrl);\n    image.setAttribute(\"alt\", params.imageAlt || \"\");\n    // Width, height\n    applyNumericalStyle(image, \"width\", params.imageWidth);\n    applyNumericalStyle(image, \"height\", params.imageHeight);\n    // Class\n    image.className = swalClasses.image;\n    applyCustomClass(image, params, \"image\");\n};\n/**\n * @param {SweetAlert} instance\n * @param {SweetAlertOptions} params\n */ const renderPopup = (instance, params)=>{\n    const container = getContainer();\n    const popup = getPopup();\n    if (!container || !popup) {\n        return;\n    }\n    // Width\n    // https://github.com/sweetalert2/sweetalert2/issues/2170\n    if (params.toast) {\n        applyNumericalStyle(container, \"width\", params.width);\n        popup.style.width = \"100%\";\n        const loader = getLoader();\n        if (loader) {\n            popup.insertBefore(loader, getIcon());\n        }\n    } else {\n        applyNumericalStyle(popup, \"width\", params.width);\n    }\n    // Padding\n    applyNumericalStyle(popup, \"padding\", params.padding);\n    // Color\n    if (params.color) {\n        popup.style.color = params.color;\n    }\n    // Background\n    if (params.background) {\n        popup.style.background = params.background;\n    }\n    hide(getValidationMessage());\n    // Classes\n    addClasses$1(popup, params);\n};\n/**\n * @param {HTMLElement} popup\n * @param {SweetAlertOptions} params\n */ const addClasses$1 = (popup, params)=>{\n    const showClass = params.showClass || {};\n    // Default Class + showClass when updating Swal.update({})\n    popup.className = `${swalClasses.popup} ${isVisible$1(popup) ? showClass.popup : \"\"}`;\n    if (params.toast) {\n        addClass([\n            document.documentElement,\n            document.body\n        ], swalClasses[\"toast-shown\"]);\n        addClass(popup, swalClasses.toast);\n    } else {\n        addClass(popup, swalClasses.modal);\n    }\n    // Custom class\n    applyCustomClass(popup, params, \"popup\");\n    // TODO: remove in the next major\n    if (typeof params.customClass === \"string\") {\n        addClass(popup, params.customClass);\n    }\n    // Icon class (#1842)\n    if (params.icon) {\n        addClass(popup, swalClasses[`icon-${params.icon}`]);\n    }\n};\n/**\n * @param {SweetAlert} instance\n * @param {SweetAlertOptions} params\n */ const renderProgressSteps = (instance, params)=>{\n    const progressStepsContainer = getProgressSteps();\n    if (!progressStepsContainer) {\n        return;\n    }\n    const { progressSteps, currentProgressStep } = params;\n    if (!progressSteps || progressSteps.length === 0 || currentProgressStep === undefined) {\n        hide(progressStepsContainer);\n        return;\n    }\n    show(progressStepsContainer);\n    progressStepsContainer.textContent = \"\";\n    if (currentProgressStep >= progressSteps.length) {\n        warn(\"Invalid currentProgressStep parameter, it should be less than progressSteps.length \" + \"(currentProgressStep like JS arrays starts from 0)\");\n    }\n    progressSteps.forEach((step, index)=>{\n        const stepEl = createStepElement(step);\n        progressStepsContainer.appendChild(stepEl);\n        if (index === currentProgressStep) {\n            addClass(stepEl, swalClasses[\"active-progress-step\"]);\n        }\n        if (index !== progressSteps.length - 1) {\n            const lineEl = createLineElement(params);\n            progressStepsContainer.appendChild(lineEl);\n        }\n    });\n};\n/**\n * @param {string} step\n * @returns {HTMLLIElement}\n */ const createStepElement = (step)=>{\n    const stepEl = document.createElement(\"li\");\n    addClass(stepEl, swalClasses[\"progress-step\"]);\n    setInnerHtml(stepEl, step);\n    return stepEl;\n};\n/**\n * @param {SweetAlertOptions} params\n * @returns {HTMLLIElement}\n */ const createLineElement = (params)=>{\n    const lineEl = document.createElement(\"li\");\n    addClass(lineEl, swalClasses[\"progress-step-line\"]);\n    if (params.progressStepsDistance) {\n        applyNumericalStyle(lineEl, \"width\", params.progressStepsDistance);\n    }\n    return lineEl;\n};\n/**\n * @param {SweetAlert} instance\n * @param {SweetAlertOptions} params\n */ const renderTitle = (instance, params)=>{\n    const title = getTitle();\n    if (!title) {\n        return;\n    }\n    showWhenInnerHtmlPresent(title);\n    toggle(title, params.title || params.titleText, \"block\");\n    if (params.title) {\n        parseHtmlToContainer(params.title, title);\n    }\n    if (params.titleText) {\n        title.innerText = params.titleText;\n    }\n    // Custom class\n    applyCustomClass(title, params, \"title\");\n};\n/**\n * @param {SweetAlert} instance\n * @param {SweetAlertOptions} params\n */ const render = (instance, params)=>{\n    renderPopup(instance, params);\n    renderContainer(instance, params);\n    renderProgressSteps(instance, params);\n    renderIcon(instance, params);\n    renderImage(instance, params);\n    renderTitle(instance, params);\n    renderCloseButton(instance, params);\n    renderContent(instance, params);\n    renderActions(instance, params);\n    renderFooter(instance, params);\n    const popup = getPopup();\n    if (typeof params.didRender === \"function\" && popup) {\n        params.didRender(popup);\n    }\n    globalState.eventEmitter.emit(\"didRender\", popup);\n};\n/*\n * Global function to determine if SweetAlert2 popup is shown\n */ const isVisible = ()=>{\n    return isVisible$1(getPopup());\n};\n/*\n * Global function to click 'Confirm' button\n */ const clickConfirm = ()=>{\n    var _dom$getConfirmButton;\n    return (_dom$getConfirmButton = getConfirmButton()) === null || _dom$getConfirmButton === void 0 ? void 0 : _dom$getConfirmButton.click();\n};\n/*\n * Global function to click 'Deny' button\n */ const clickDeny = ()=>{\n    var _dom$getDenyButton;\n    return (_dom$getDenyButton = getDenyButton()) === null || _dom$getDenyButton === void 0 ? void 0 : _dom$getDenyButton.click();\n};\n/*\n * Global function to click 'Cancel' button\n */ const clickCancel = ()=>{\n    var _dom$getCancelButton;\n    return (_dom$getCancelButton = getCancelButton()) === null || _dom$getCancelButton === void 0 ? void 0 : _dom$getCancelButton.click();\n};\n/** @typedef {'cancel' | 'backdrop' | 'close' | 'esc' | 'timer'} DismissReason */ /** @type {Record<DismissReason, DismissReason>} */ const DismissReason = Object.freeze({\n    cancel: \"cancel\",\n    backdrop: \"backdrop\",\n    close: \"close\",\n    esc: \"esc\",\n    timer: \"timer\"\n});\n/**\n * @param {GlobalState} globalState\n */ const removeKeydownHandler = (globalState)=>{\n    if (globalState.keydownTarget && globalState.keydownHandlerAdded) {\n        globalState.keydownTarget.removeEventListener(\"keydown\", globalState.keydownHandler, {\n            capture: globalState.keydownListenerCapture\n        });\n        globalState.keydownHandlerAdded = false;\n    }\n};\n/**\n * @param {GlobalState} globalState\n * @param {SweetAlertOptions} innerParams\n * @param {*} dismissWith\n */ const addKeydownHandler = (globalState, innerParams, dismissWith)=>{\n    removeKeydownHandler(globalState);\n    if (!innerParams.toast) {\n        globalState.keydownHandler = (e)=>keydownHandler(innerParams, e, dismissWith);\n        globalState.keydownTarget = innerParams.keydownListenerCapture ? window : getPopup();\n        globalState.keydownListenerCapture = innerParams.keydownListenerCapture;\n        globalState.keydownTarget.addEventListener(\"keydown\", globalState.keydownHandler, {\n            capture: globalState.keydownListenerCapture\n        });\n        globalState.keydownHandlerAdded = true;\n    }\n};\n/**\n * @param {number} index\n * @param {number} increment\n */ const setFocus = (index, increment)=>{\n    var _dom$getPopup;\n    const focusableElements = getFocusableElements();\n    // search for visible elements and select the next possible match\n    if (focusableElements.length) {\n        index = index + increment;\n        // rollover to first item\n        if (index === focusableElements.length) {\n            index = 0;\n        // go to last item\n        } else if (index === -1) {\n            index = focusableElements.length - 1;\n        }\n        focusableElements[index].focus();\n        return;\n    }\n    // no visible focusable elements, focus the popup\n    (_dom$getPopup = getPopup()) === null || _dom$getPopup === void 0 || _dom$getPopup.focus();\n};\nconst arrowKeysNextButton = [\n    \"ArrowRight\",\n    \"ArrowDown\"\n];\nconst arrowKeysPreviousButton = [\n    \"ArrowLeft\",\n    \"ArrowUp\"\n];\n/**\n * @param {SweetAlertOptions} innerParams\n * @param {KeyboardEvent} event\n * @param {Function} dismissWith\n */ const keydownHandler = (innerParams, event, dismissWith)=>{\n    if (!innerParams) {\n        return; // This instance has already been destroyed\n    }\n    // Ignore keydown during IME composition\n    // https://developer.mozilla.org/en-US/docs/Web/API/Document/keydown_event#ignoring_keydown_during_ime_composition\n    // https://github.com/sweetalert2/sweetalert2/issues/720\n    // https://github.com/sweetalert2/sweetalert2/issues/2406\n    if (event.isComposing || event.keyCode === 229) {\n        return;\n    }\n    if (innerParams.stopKeydownPropagation) {\n        event.stopPropagation();\n    }\n    // ENTER\n    if (event.key === \"Enter\") {\n        handleEnter(event, innerParams);\n    } else if (event.key === \"Tab\") {\n        handleTab(event);\n    } else if ([\n        ...arrowKeysNextButton,\n        ...arrowKeysPreviousButton\n    ].includes(event.key)) {\n        handleArrows(event.key);\n    } else if (event.key === \"Escape\") {\n        handleEsc(event, innerParams, dismissWith);\n    }\n};\n/**\n * @param {KeyboardEvent} event\n * @param {SweetAlertOptions} innerParams\n */ const handleEnter = (event, innerParams)=>{\n    // https://github.com/sweetalert2/sweetalert2/issues/2386\n    if (!callIfFunction(innerParams.allowEnterKey)) {\n        return;\n    }\n    const input = getInput$1(getPopup(), innerParams.input);\n    if (event.target && input && event.target instanceof HTMLElement && event.target.outerHTML === input.outerHTML) {\n        if ([\n            \"textarea\",\n            \"file\"\n        ].includes(innerParams.input)) {\n            return; // do not submit\n        }\n        clickConfirm();\n        event.preventDefault();\n    }\n};\n/**\n * @param {KeyboardEvent} event\n */ const handleTab = (event)=>{\n    const targetElement = event.target;\n    const focusableElements = getFocusableElements();\n    let btnIndex = -1;\n    for(let i = 0; i < focusableElements.length; i++){\n        if (targetElement === focusableElements[i]) {\n            btnIndex = i;\n            break;\n        }\n    }\n    // Cycle to the next button\n    if (!event.shiftKey) {\n        setFocus(btnIndex, 1);\n    } else {\n        setFocus(btnIndex, -1);\n    }\n    event.stopPropagation();\n    event.preventDefault();\n};\n/**\n * @param {string} key\n */ const handleArrows = (key)=>{\n    const actions = getActions();\n    const confirmButton = getConfirmButton();\n    const denyButton = getDenyButton();\n    const cancelButton = getCancelButton();\n    if (!actions || !confirmButton || !denyButton || !cancelButton) {\n        return;\n    }\n    /** @type HTMLElement[] */ const buttons = [\n        confirmButton,\n        denyButton,\n        cancelButton\n    ];\n    if (document.activeElement instanceof HTMLElement && !buttons.includes(document.activeElement)) {\n        return;\n    }\n    const sibling = arrowKeysNextButton.includes(key) ? \"nextElementSibling\" : \"previousElementSibling\";\n    let buttonToFocus = document.activeElement;\n    if (!buttonToFocus) {\n        return;\n    }\n    for(let i = 0; i < actions.children.length; i++){\n        buttonToFocus = buttonToFocus[sibling];\n        if (!buttonToFocus) {\n            return;\n        }\n        if (buttonToFocus instanceof HTMLButtonElement && isVisible$1(buttonToFocus)) {\n            break;\n        }\n    }\n    if (buttonToFocus instanceof HTMLButtonElement) {\n        buttonToFocus.focus();\n    }\n};\n/**\n * @param {KeyboardEvent} event\n * @param {SweetAlertOptions} innerParams\n * @param {Function} dismissWith\n */ const handleEsc = (event, innerParams, dismissWith)=>{\n    if (callIfFunction(innerParams.allowEscapeKey)) {\n        event.preventDefault();\n        dismissWith(DismissReason.esc);\n    }\n};\n/**\n * This module contains `WeakMap`s for each effectively-\"private  property\" that a `Swal` has.\n * For example, to set the private property \"foo\" of `this` to \"bar\", you can `privateProps.foo.set(this, 'bar')`\n * This is the approach that Babel will probably take to implement private methods/fields\n *   https://github.com/tc39/proposal-private-methods\n *   https://github.com/babel/babel/pull/7555\n * Once we have the changes from that PR in Babel, and our core class fits reasonable in *one module*\n *   then we can use that language feature.\n */ var privateMethods = {\n    swalPromiseResolve: new WeakMap(),\n    swalPromiseReject: new WeakMap()\n};\n// From https://developer.paciellogroup.com/blog/2018/06/the-current-state-of-modal-dialog-accessibility/\n// Adding aria-hidden=\"true\" to elements outside of the active modal dialog ensures that\n// elements not within the active modal dialog will not be surfaced if a user opens a screen\n// readers list of elements (headings, form controls, landmarks, etc.) in the document.\nconst setAriaHidden = ()=>{\n    const container = getContainer();\n    const bodyChildren = Array.from(document.body.children);\n    bodyChildren.forEach((el)=>{\n        if (el.contains(container)) {\n            return;\n        }\n        if (el.hasAttribute(\"aria-hidden\")) {\n            el.setAttribute(\"data-previous-aria-hidden\", el.getAttribute(\"aria-hidden\") || \"\");\n        }\n        el.setAttribute(\"aria-hidden\", \"true\");\n    });\n};\nconst unsetAriaHidden = ()=>{\n    const bodyChildren = Array.from(document.body.children);\n    bodyChildren.forEach((el)=>{\n        if (el.hasAttribute(\"data-previous-aria-hidden\")) {\n            el.setAttribute(\"aria-hidden\", el.getAttribute(\"data-previous-aria-hidden\") || \"\");\n            el.removeAttribute(\"data-previous-aria-hidden\");\n        } else {\n            el.removeAttribute(\"aria-hidden\");\n        }\n    });\n};\n// @ts-ignore\nconst isSafariOrIOS =  false && 0; // true for Safari desktop + all iOS browsers https://stackoverflow.com/a/70585394\n/**\n * Fix iOS scrolling\n * http://stackoverflow.com/q/39626302\n */ const iOSfix = ()=>{\n    if (isSafariOrIOS && !hasClass(document.body, swalClasses.iosfix)) {\n        const offset = document.body.scrollTop;\n        document.body.style.top = `${offset * -1}px`;\n        addClass(document.body, swalClasses.iosfix);\n        lockBodyScroll();\n    }\n};\n/**\n * https://github.com/sweetalert2/sweetalert2/issues/1246\n */ const lockBodyScroll = ()=>{\n    const container = getContainer();\n    if (!container) {\n        return;\n    }\n    /** @type {boolean} */ let preventTouchMove;\n    /**\n   * @param {TouchEvent} event\n   */ container.ontouchstart = (event)=>{\n        preventTouchMove = shouldPreventTouchMove(event);\n    };\n    /**\n   * @param {TouchEvent} event\n   */ container.ontouchmove = (event)=>{\n        if (preventTouchMove) {\n            event.preventDefault();\n            event.stopPropagation();\n        }\n    };\n};\n/**\n * @param {TouchEvent} event\n * @returns {boolean}\n */ const shouldPreventTouchMove = (event)=>{\n    const target = event.target;\n    const container = getContainer();\n    const htmlContainer = getHtmlContainer();\n    if (!container || !htmlContainer) {\n        return false;\n    }\n    if (isStylus(event) || isZoom(event)) {\n        return false;\n    }\n    if (target === container) {\n        return true;\n    }\n    if (!isScrollable(container) && target instanceof HTMLElement && target.tagName !== \"INPUT\" && // #1603\n    target.tagName !== \"TEXTAREA\" && // #2266\n    !(isScrollable(htmlContainer) && // #1944\n    htmlContainer.contains(target))) {\n        return true;\n    }\n    return false;\n};\n/**\n * https://github.com/sweetalert2/sweetalert2/issues/1786\n *\n * @param {*} event\n * @returns {boolean}\n */ const isStylus = (event)=>{\n    return event.touches && event.touches.length && event.touches[0].touchType === \"stylus\";\n};\n/**\n * https://github.com/sweetalert2/sweetalert2/issues/1891\n *\n * @param {TouchEvent} event\n * @returns {boolean}\n */ const isZoom = (event)=>{\n    return event.touches && event.touches.length > 1;\n};\nconst undoIOSfix = ()=>{\n    if (hasClass(document.body, swalClasses.iosfix)) {\n        const offset = parseInt(document.body.style.top, 10);\n        removeClass(document.body, swalClasses.iosfix);\n        document.body.style.top = \"\";\n        document.body.scrollTop = offset * -1;\n    }\n};\n/**\n * Measure scrollbar width for padding body during modal show/hide\n * https://github.com/twbs/bootstrap/blob/master/js/src/modal.js\n *\n * @returns {number}\n */ const measureScrollbar = ()=>{\n    const scrollDiv = document.createElement(\"div\");\n    scrollDiv.className = swalClasses[\"scrollbar-measure\"];\n    document.body.appendChild(scrollDiv);\n    const scrollbarWidth = scrollDiv.getBoundingClientRect().width - scrollDiv.clientWidth;\n    document.body.removeChild(scrollDiv);\n    return scrollbarWidth;\n};\n/**\n * Remember state in cases where opening and handling a modal will fiddle with it.\n * @type {number | null}\n */ let previousBodyPadding = null;\n/**\n * @param {string} initialBodyOverflow\n */ const replaceScrollbarWithPadding = (initialBodyOverflow)=>{\n    // for queues, do not do this more than once\n    if (previousBodyPadding !== null) {\n        return;\n    }\n    // if the body has overflow\n    if (document.body.scrollHeight > window.innerHeight || initialBodyOverflow === \"scroll\" // https://github.com/sweetalert2/sweetalert2/issues/2663\n    ) {\n        // add padding so the content doesn't shift after removal of scrollbar\n        previousBodyPadding = parseInt(window.getComputedStyle(document.body).getPropertyValue(\"padding-right\"));\n        document.body.style.paddingRight = `${previousBodyPadding + measureScrollbar()}px`;\n    }\n};\nconst undoReplaceScrollbarWithPadding = ()=>{\n    if (previousBodyPadding !== null) {\n        document.body.style.paddingRight = `${previousBodyPadding}px`;\n        previousBodyPadding = null;\n    }\n};\n/**\n * @param {SweetAlert} instance\n * @param {HTMLElement} container\n * @param {boolean} returnFocus\n * @param {Function} didClose\n */ function removePopupAndResetState(instance, container, returnFocus, didClose) {\n    if (isToast()) {\n        triggerDidCloseAndDispose(instance, didClose);\n    } else {\n        restoreActiveElement(returnFocus).then(()=>triggerDidCloseAndDispose(instance, didClose));\n        removeKeydownHandler(globalState);\n    }\n    // workaround for https://github.com/sweetalert2/sweetalert2/issues/2088\n    // for some reason removing the container in Safari will scroll the document to bottom\n    if (isSafariOrIOS) {\n        container.setAttribute(\"style\", \"display:none !important\");\n        container.removeAttribute(\"class\");\n        container.innerHTML = \"\";\n    } else {\n        container.remove();\n    }\n    if (isModal()) {\n        undoReplaceScrollbarWithPadding();\n        undoIOSfix();\n        unsetAriaHidden();\n    }\n    removeBodyClasses();\n}\n/**\n * Remove SweetAlert2 classes from body\n */ function removeBodyClasses() {\n    removeClass([\n        document.documentElement,\n        document.body\n    ], [\n        swalClasses.shown,\n        swalClasses[\"height-auto\"],\n        swalClasses[\"no-backdrop\"],\n        swalClasses[\"toast-shown\"]\n    ]);\n}\n/**\n * Instance method to close sweetAlert\n *\n * @param {any} resolveValue\n */ function close(resolveValue) {\n    resolveValue = prepareResolveValue(resolveValue);\n    const swalPromiseResolve = privateMethods.swalPromiseResolve.get(this);\n    const didClose = triggerClosePopup(this);\n    if (this.isAwaitingPromise) {\n        // A swal awaiting for a promise (after a click on Confirm or Deny) cannot be dismissed anymore #2335\n        if (!resolveValue.isDismissed) {\n            handleAwaitingPromise(this);\n            swalPromiseResolve(resolveValue);\n        }\n    } else if (didClose) {\n        // Resolve Swal promise\n        swalPromiseResolve(resolveValue);\n    }\n}\nconst triggerClosePopup = (instance)=>{\n    const popup = getPopup();\n    if (!popup) {\n        return false;\n    }\n    const innerParams = privateProps.innerParams.get(instance);\n    if (!innerParams || hasClass(popup, innerParams.hideClass.popup)) {\n        return false;\n    }\n    removeClass(popup, innerParams.showClass.popup);\n    addClass(popup, innerParams.hideClass.popup);\n    const backdrop = getContainer();\n    removeClass(backdrop, innerParams.showClass.backdrop);\n    addClass(backdrop, innerParams.hideClass.backdrop);\n    handlePopupAnimation(instance, popup, innerParams);\n    return true;\n};\n/**\n * @param {any} error\n */ function rejectPromise(error) {\n    const rejectPromise = privateMethods.swalPromiseReject.get(this);\n    handleAwaitingPromise(this);\n    if (rejectPromise) {\n        // Reject Swal promise\n        rejectPromise(error);\n    }\n}\n/**\n * @param {SweetAlert} instance\n */ const handleAwaitingPromise = (instance)=>{\n    if (instance.isAwaitingPromise) {\n        delete instance.isAwaitingPromise;\n        // The instance might have been previously partly destroyed, we must resume the destroy process in this case #2335\n        if (!privateProps.innerParams.get(instance)) {\n            instance._destroy();\n        }\n    }\n};\n/**\n * @param {any} resolveValue\n * @returns {SweetAlertResult}\n */ const prepareResolveValue = (resolveValue)=>{\n    // When user calls Swal.close()\n    if (typeof resolveValue === \"undefined\") {\n        return {\n            isConfirmed: false,\n            isDenied: false,\n            isDismissed: true\n        };\n    }\n    return Object.assign({\n        isConfirmed: false,\n        isDenied: false,\n        isDismissed: false\n    }, resolveValue);\n};\n/**\n * @param {SweetAlert} instance\n * @param {HTMLElement} popup\n * @param {SweetAlertOptions} innerParams\n */ const handlePopupAnimation = (instance, popup, innerParams)=>{\n    const container = getContainer();\n    // If animation is supported, animate\n    const animationIsSupported = animationEndEvent && hasCssAnimation(popup);\n    if (typeof innerParams.willClose === \"function\") {\n        innerParams.willClose(popup);\n    }\n    globalState.eventEmitter.emit(\"willClose\", popup);\n    if (animationIsSupported) {\n        animatePopup(instance, popup, container, innerParams.returnFocus, innerParams.didClose);\n    } else {\n        // Otherwise, remove immediately\n        removePopupAndResetState(instance, container, innerParams.returnFocus, innerParams.didClose);\n    }\n};\n/**\n * @param {SweetAlert} instance\n * @param {HTMLElement} popup\n * @param {HTMLElement} container\n * @param {boolean} returnFocus\n * @param {Function} didClose\n */ const animatePopup = (instance, popup, container, returnFocus, didClose)=>{\n    if (!animationEndEvent) {\n        return;\n    }\n    globalState.swalCloseEventFinishedCallback = removePopupAndResetState.bind(null, instance, container, returnFocus, didClose);\n    popup.addEventListener(animationEndEvent, function(e) {\n        if (e.target === popup) {\n            globalState.swalCloseEventFinishedCallback();\n            delete globalState.swalCloseEventFinishedCallback;\n        }\n    });\n};\n/**\n * @param {SweetAlert} instance\n * @param {Function} didClose\n */ const triggerDidCloseAndDispose = (instance, didClose)=>{\n    setTimeout(()=>{\n        if (typeof didClose === \"function\") {\n            didClose.bind(instance.params)();\n        }\n        globalState.eventEmitter.emit(\"didClose\");\n        // instance might have been destroyed already\n        if (instance._destroy) {\n            instance._destroy();\n        }\n    });\n};\n/**\n * Shows loader (spinner), this is useful with AJAX requests.\n * By default the loader be shown instead of the \"Confirm\" button.\n *\n * @param {HTMLButtonElement | null} [buttonToReplace]\n */ const showLoading = (buttonToReplace)=>{\n    let popup = getPopup();\n    if (!popup) {\n        new Swal();\n    }\n    popup = getPopup();\n    if (!popup) {\n        return;\n    }\n    const loader = getLoader();\n    if (isToast()) {\n        hide(getIcon());\n    } else {\n        replaceButton(popup, buttonToReplace);\n    }\n    show(loader);\n    popup.setAttribute(\"data-loading\", \"true\");\n    popup.setAttribute(\"aria-busy\", \"true\");\n    popup.focus();\n};\n/**\n * @param {HTMLElement} popup\n * @param {HTMLButtonElement | null} [buttonToReplace]\n */ const replaceButton = (popup, buttonToReplace)=>{\n    const actions = getActions();\n    const loader = getLoader();\n    if (!actions || !loader) {\n        return;\n    }\n    if (!buttonToReplace && isVisible$1(getConfirmButton())) {\n        buttonToReplace = getConfirmButton();\n    }\n    show(actions);\n    if (buttonToReplace) {\n        hide(buttonToReplace);\n        loader.setAttribute(\"data-button-to-replace\", buttonToReplace.className);\n        actions.insertBefore(loader, buttonToReplace);\n    }\n    addClass([\n        popup,\n        actions\n    ], swalClasses.loading);\n};\n/**\n * @param {SweetAlert} instance\n * @param {SweetAlertOptions} params\n */ const handleInputOptionsAndValue = (instance, params)=>{\n    if (params.input === \"select\" || params.input === \"radio\") {\n        handleInputOptions(instance, params);\n    } else if ([\n        \"text\",\n        \"email\",\n        \"number\",\n        \"tel\",\n        \"textarea\"\n    ].some((i)=>i === params.input) && (hasToPromiseFn(params.inputValue) || isPromise(params.inputValue))) {\n        showLoading(getConfirmButton());\n        handleInputValue(instance, params);\n    }\n};\n/**\n * @param {SweetAlert} instance\n * @param {SweetAlertOptions} innerParams\n * @returns {SweetAlertInputValue}\n */ const getInputValue = (instance, innerParams)=>{\n    const input = instance.getInput();\n    if (!input) {\n        return null;\n    }\n    switch(innerParams.input){\n        case \"checkbox\":\n            return getCheckboxValue(input);\n        case \"radio\":\n            return getRadioValue(input);\n        case \"file\":\n            return getFileValue(input);\n        default:\n            return innerParams.inputAutoTrim ? input.value.trim() : input.value;\n    }\n};\n/**\n * @param {HTMLInputElement} input\n * @returns {number}\n */ const getCheckboxValue = (input)=>input.checked ? 1 : 0;\n/**\n * @param {HTMLInputElement} input\n * @returns {string | null}\n */ const getRadioValue = (input)=>input.checked ? input.value : null;\n/**\n * @param {HTMLInputElement} input\n * @returns {FileList | File | null}\n */ const getFileValue = (input)=>input.files && input.files.length ? input.getAttribute(\"multiple\") !== null ? input.files : input.files[0] : null;\n/**\n * @param {SweetAlert} instance\n * @param {SweetAlertOptions} params\n */ const handleInputOptions = (instance, params)=>{\n    const popup = getPopup();\n    if (!popup) {\n        return;\n    }\n    /**\n   * @param {Record<string, any>} inputOptions\n   */ const processInputOptions = (inputOptions)=>{\n        if (params.input === \"select\") {\n            populateSelectOptions(popup, formatInputOptions(inputOptions), params);\n        } else if (params.input === \"radio\") {\n            populateRadioOptions(popup, formatInputOptions(inputOptions), params);\n        }\n    };\n    if (hasToPromiseFn(params.inputOptions) || isPromise(params.inputOptions)) {\n        showLoading(getConfirmButton());\n        asPromise(params.inputOptions).then((inputOptions)=>{\n            instance.hideLoading();\n            processInputOptions(inputOptions);\n        });\n    } else if (typeof params.inputOptions === \"object\") {\n        processInputOptions(params.inputOptions);\n    } else {\n        error(`Unexpected type of inputOptions! Expected object, Map or Promise, got ${typeof params.inputOptions}`);\n    }\n};\n/**\n * @param {SweetAlert} instance\n * @param {SweetAlertOptions} params\n */ const handleInputValue = (instance, params)=>{\n    const input = instance.getInput();\n    if (!input) {\n        return;\n    }\n    hide(input);\n    asPromise(params.inputValue).then((inputValue)=>{\n        input.value = params.input === \"number\" ? `${parseFloat(inputValue) || 0}` : `${inputValue}`;\n        show(input);\n        input.focus();\n        instance.hideLoading();\n    }).catch((err)=>{\n        error(`Error in inputValue promise: ${err}`);\n        input.value = \"\";\n        show(input);\n        input.focus();\n        instance.hideLoading();\n    });\n};\n/**\n * @param {HTMLElement} popup\n * @param {InputOptionFlattened[]} inputOptions\n * @param {SweetAlertOptions} params\n */ function populateSelectOptions(popup, inputOptions, params) {\n    const select = getDirectChildByClass(popup, swalClasses.select);\n    if (!select) {\n        return;\n    }\n    /**\n   * @param {HTMLElement} parent\n   * @param {string} optionLabel\n   * @param {string} optionValue\n   */ const renderOption = (parent, optionLabel, optionValue)=>{\n        const option = document.createElement(\"option\");\n        option.value = optionValue;\n        setInnerHtml(option, optionLabel);\n        option.selected = isSelected(optionValue, params.inputValue);\n        parent.appendChild(option);\n    };\n    inputOptions.forEach((inputOption)=>{\n        const optionValue = inputOption[0];\n        const optionLabel = inputOption[1];\n        // <optgroup> spec:\n        // https://www.w3.org/TR/html401/interact/forms.html#h-17.6\n        // \"...all OPTGROUP elements must be specified directly within a SELECT element (i.e., groups may not be nested)...\"\n        // check whether this is a <optgroup>\n        if (Array.isArray(optionLabel)) {\n            // if it is an array, then it is an <optgroup>\n            const optgroup = document.createElement(\"optgroup\");\n            optgroup.label = optionValue;\n            optgroup.disabled = false; // not configurable for now\n            select.appendChild(optgroup);\n            optionLabel.forEach((o)=>renderOption(optgroup, o[1], o[0]));\n        } else {\n            // case of <option>\n            renderOption(select, optionLabel, optionValue);\n        }\n    });\n    select.focus();\n}\n/**\n * @param {HTMLElement} popup\n * @param {InputOptionFlattened[]} inputOptions\n * @param {SweetAlertOptions} params\n */ function populateRadioOptions(popup, inputOptions, params) {\n    const radio = getDirectChildByClass(popup, swalClasses.radio);\n    if (!radio) {\n        return;\n    }\n    inputOptions.forEach((inputOption)=>{\n        const radioValue = inputOption[0];\n        const radioLabel = inputOption[1];\n        const radioInput = document.createElement(\"input\");\n        const radioLabelElement = document.createElement(\"label\");\n        radioInput.type = \"radio\";\n        radioInput.name = swalClasses.radio;\n        radioInput.value = radioValue;\n        if (isSelected(radioValue, params.inputValue)) {\n            radioInput.checked = true;\n        }\n        const label = document.createElement(\"span\");\n        setInnerHtml(label, radioLabel);\n        label.className = swalClasses.label;\n        radioLabelElement.appendChild(radioInput);\n        radioLabelElement.appendChild(label);\n        radio.appendChild(radioLabelElement);\n    });\n    const radios = radio.querySelectorAll(\"input\");\n    if (radios.length) {\n        radios[0].focus();\n    }\n}\n/**\n * Converts `inputOptions` into an array of `[value, label]`s\n *\n * @param {Record<string, any>} inputOptions\n * @typedef {string[]} InputOptionFlattened\n * @returns {InputOptionFlattened[]}\n */ const formatInputOptions = (inputOptions)=>{\n    /** @type {InputOptionFlattened[]} */ const result = [];\n    if (inputOptions instanceof Map) {\n        inputOptions.forEach((value, key)=>{\n            let valueFormatted = value;\n            if (typeof valueFormatted === \"object\") {\n                // case of <optgroup>\n                valueFormatted = formatInputOptions(valueFormatted);\n            }\n            result.push([\n                key,\n                valueFormatted\n            ]);\n        });\n    } else {\n        Object.keys(inputOptions).forEach((key)=>{\n            let valueFormatted = inputOptions[key];\n            if (typeof valueFormatted === \"object\") {\n                // case of <optgroup>\n                valueFormatted = formatInputOptions(valueFormatted);\n            }\n            result.push([\n                key,\n                valueFormatted\n            ]);\n        });\n    }\n    return result;\n};\n/**\n * @param {string} optionValue\n * @param {SweetAlertInputValue} inputValue\n * @returns {boolean}\n */ const isSelected = (optionValue, inputValue)=>{\n    return !!inputValue && inputValue.toString() === optionValue.toString();\n};\n/**\n * @param {SweetAlert} instance\n */ const handleConfirmButtonClick = (instance)=>{\n    const innerParams = privateProps.innerParams.get(instance);\n    instance.disableButtons();\n    if (innerParams.input) {\n        handleConfirmOrDenyWithInput(instance, \"confirm\");\n    } else {\n        confirm(instance, true);\n    }\n};\n/**\n * @param {SweetAlert} instance\n */ const handleDenyButtonClick = (instance)=>{\n    const innerParams = privateProps.innerParams.get(instance);\n    instance.disableButtons();\n    if (innerParams.returnInputValueOnDeny) {\n        handleConfirmOrDenyWithInput(instance, \"deny\");\n    } else {\n        deny(instance, false);\n    }\n};\n/**\n * @param {SweetAlert} instance\n * @param {Function} dismissWith\n */ const handleCancelButtonClick = (instance, dismissWith)=>{\n    instance.disableButtons();\n    dismissWith(DismissReason.cancel);\n};\n/**\n * @param {SweetAlert} instance\n * @param {'confirm' | 'deny'} type\n */ const handleConfirmOrDenyWithInput = (instance, type)=>{\n    const innerParams = privateProps.innerParams.get(instance);\n    if (!innerParams.input) {\n        error(`The \"input\" parameter is needed to be set when using returnInputValueOn${capitalizeFirstLetter(type)}`);\n        return;\n    }\n    const input = instance.getInput();\n    const inputValue = getInputValue(instance, innerParams);\n    if (innerParams.inputValidator) {\n        handleInputValidator(instance, inputValue, type);\n    } else if (input && !input.checkValidity()) {\n        instance.enableButtons();\n        instance.showValidationMessage(innerParams.validationMessage || input.validationMessage);\n    } else if (type === \"deny\") {\n        deny(instance, inputValue);\n    } else {\n        confirm(instance, inputValue);\n    }\n};\n/**\n * @param {SweetAlert} instance\n * @param {SweetAlertInputValue} inputValue\n * @param {'confirm' | 'deny'} type\n */ const handleInputValidator = (instance, inputValue, type)=>{\n    const innerParams = privateProps.innerParams.get(instance);\n    instance.disableInput();\n    const validationPromise = Promise.resolve().then(()=>asPromise(innerParams.inputValidator(inputValue, innerParams.validationMessage)));\n    validationPromise.then((validationMessage)=>{\n        instance.enableButtons();\n        instance.enableInput();\n        if (validationMessage) {\n            instance.showValidationMessage(validationMessage);\n        } else if (type === \"deny\") {\n            deny(instance, inputValue);\n        } else {\n            confirm(instance, inputValue);\n        }\n    });\n};\n/**\n * @param {SweetAlert} instance\n * @param {any} value\n */ const deny = (instance, value)=>{\n    const innerParams = privateProps.innerParams.get(instance || undefined);\n    if (innerParams.showLoaderOnDeny) {\n        showLoading(getDenyButton());\n    }\n    if (innerParams.preDeny) {\n        instance.isAwaitingPromise = true; // Flagging the instance as awaiting a promise so it's own promise's reject/resolve methods doesn't get destroyed until the result from this preDeny's promise is received\n        const preDenyPromise = Promise.resolve().then(()=>asPromise(innerParams.preDeny(value, innerParams.validationMessage)));\n        preDenyPromise.then((preDenyValue)=>{\n            if (preDenyValue === false) {\n                instance.hideLoading();\n                handleAwaitingPromise(instance);\n            } else {\n                instance.close({\n                    isDenied: true,\n                    value: typeof preDenyValue === \"undefined\" ? value : preDenyValue\n                });\n            }\n        }).catch((error)=>rejectWith(instance || undefined, error));\n    } else {\n        instance.close({\n            isDenied: true,\n            value\n        });\n    }\n};\n/**\n * @param {SweetAlert} instance\n * @param {any} value\n */ const succeedWith = (instance, value)=>{\n    instance.close({\n        isConfirmed: true,\n        value\n    });\n};\n/**\n *\n * @param {SweetAlert} instance\n * @param {string} error\n */ const rejectWith = (instance, error)=>{\n    instance.rejectPromise(error);\n};\n/**\n *\n * @param {SweetAlert} instance\n * @param {any} value\n */ const confirm = (instance, value)=>{\n    const innerParams = privateProps.innerParams.get(instance || undefined);\n    if (innerParams.showLoaderOnConfirm) {\n        showLoading();\n    }\n    if (innerParams.preConfirm) {\n        instance.resetValidationMessage();\n        instance.isAwaitingPromise = true; // Flagging the instance as awaiting a promise so it's own promise's reject/resolve methods doesn't get destroyed until the result from this preConfirm's promise is received\n        const preConfirmPromise = Promise.resolve().then(()=>asPromise(innerParams.preConfirm(value, innerParams.validationMessage)));\n        preConfirmPromise.then((preConfirmValue)=>{\n            if (isVisible$1(getValidationMessage()) || preConfirmValue === false) {\n                instance.hideLoading();\n                handleAwaitingPromise(instance);\n            } else {\n                succeedWith(instance, typeof preConfirmValue === \"undefined\" ? value : preConfirmValue);\n            }\n        }).catch((error)=>rejectWith(instance || undefined, error));\n    } else {\n        succeedWith(instance, value);\n    }\n};\n/**\n * Hides loader and shows back the button which was hidden by .showLoading()\n */ function hideLoading() {\n    // do nothing if popup is closed\n    const innerParams = privateProps.innerParams.get(this);\n    if (!innerParams) {\n        return;\n    }\n    const domCache = privateProps.domCache.get(this);\n    hide(domCache.loader);\n    if (isToast()) {\n        if (innerParams.icon) {\n            show(getIcon());\n        }\n    } else {\n        showRelatedButton(domCache);\n    }\n    removeClass([\n        domCache.popup,\n        domCache.actions\n    ], swalClasses.loading);\n    domCache.popup.removeAttribute(\"aria-busy\");\n    domCache.popup.removeAttribute(\"data-loading\");\n    domCache.confirmButton.disabled = false;\n    domCache.denyButton.disabled = false;\n    domCache.cancelButton.disabled = false;\n}\nconst showRelatedButton = (domCache)=>{\n    const buttonToReplace = domCache.popup.getElementsByClassName(domCache.loader.getAttribute(\"data-button-to-replace\"));\n    if (buttonToReplace.length) {\n        show(buttonToReplace[0], \"inline-block\");\n    } else if (allButtonsAreHidden()) {\n        hide(domCache.actions);\n    }\n};\n/**\n * Gets the input DOM node, this method works with input parameter.\n *\n * @returns {HTMLInputElement | null}\n */ function getInput() {\n    const innerParams = privateProps.innerParams.get(this);\n    const domCache = privateProps.domCache.get(this);\n    if (!domCache) {\n        return null;\n    }\n    return getInput$1(domCache.popup, innerParams.input);\n}\n/**\n * @param {SweetAlert} instance\n * @param {string[]} buttons\n * @param {boolean} disabled\n */ function setButtonsDisabled(instance, buttons, disabled) {\n    const domCache = privateProps.domCache.get(instance);\n    buttons.forEach((button)=>{\n        domCache[button].disabled = disabled;\n    });\n}\n/**\n * @param {HTMLInputElement | null} input\n * @param {boolean} disabled\n */ function setInputDisabled(input, disabled) {\n    const popup = getPopup();\n    if (!popup || !input) {\n        return;\n    }\n    if (input.type === \"radio\") {\n        /** @type {NodeListOf<HTMLInputElement>} */ const radios = popup.querySelectorAll(`[name=\"${swalClasses.radio}\"]`);\n        for(let i = 0; i < radios.length; i++){\n            radios[i].disabled = disabled;\n        }\n    } else {\n        input.disabled = disabled;\n    }\n}\n/**\n * Enable all the buttons\n * @this {SweetAlert}\n */ function enableButtons() {\n    setButtonsDisabled(this, [\n        \"confirmButton\",\n        \"denyButton\",\n        \"cancelButton\"\n    ], false);\n}\n/**\n * Disable all the buttons\n * @this {SweetAlert}\n */ function disableButtons() {\n    setButtonsDisabled(this, [\n        \"confirmButton\",\n        \"denyButton\",\n        \"cancelButton\"\n    ], true);\n}\n/**\n * Enable the input field\n * @this {SweetAlert}\n */ function enableInput() {\n    setInputDisabled(this.getInput(), false);\n}\n/**\n * Disable the input field\n * @this {SweetAlert}\n */ function disableInput() {\n    setInputDisabled(this.getInput(), true);\n}\n/**\n * Show block with validation message\n *\n * @param {string} error\n * @this {SweetAlert}\n */ function showValidationMessage(error) {\n    const domCache = privateProps.domCache.get(this);\n    const params = privateProps.innerParams.get(this);\n    setInnerHtml(domCache.validationMessage, error);\n    domCache.validationMessage.className = swalClasses[\"validation-message\"];\n    if (params.customClass && params.customClass.validationMessage) {\n        addClass(domCache.validationMessage, params.customClass.validationMessage);\n    }\n    show(domCache.validationMessage);\n    const input = this.getInput();\n    if (input) {\n        input.setAttribute(\"aria-invalid\", \"true\");\n        input.setAttribute(\"aria-describedby\", swalClasses[\"validation-message\"]);\n        focusInput(input);\n        addClass(input, swalClasses.inputerror);\n    }\n}\n/**\n * Hide block with validation message\n *\n * @this {SweetAlert}\n */ function resetValidationMessage() {\n    const domCache = privateProps.domCache.get(this);\n    if (domCache.validationMessage) {\n        hide(domCache.validationMessage);\n    }\n    const input = this.getInput();\n    if (input) {\n        input.removeAttribute(\"aria-invalid\");\n        input.removeAttribute(\"aria-describedby\");\n        removeClass(input, swalClasses.inputerror);\n    }\n}\nconst defaultParams = {\n    title: \"\",\n    titleText: \"\",\n    text: \"\",\n    html: \"\",\n    footer: \"\",\n    icon: undefined,\n    iconColor: undefined,\n    iconHtml: undefined,\n    template: undefined,\n    toast: false,\n    animation: true,\n    showClass: {\n        popup: \"swal2-show\",\n        backdrop: \"swal2-backdrop-show\",\n        icon: \"swal2-icon-show\"\n    },\n    hideClass: {\n        popup: \"swal2-hide\",\n        backdrop: \"swal2-backdrop-hide\",\n        icon: \"swal2-icon-hide\"\n    },\n    customClass: {},\n    target: \"body\",\n    color: undefined,\n    backdrop: true,\n    heightAuto: true,\n    allowOutsideClick: true,\n    allowEscapeKey: true,\n    allowEnterKey: true,\n    stopKeydownPropagation: true,\n    keydownListenerCapture: false,\n    showConfirmButton: true,\n    showDenyButton: false,\n    showCancelButton: false,\n    preConfirm: undefined,\n    preDeny: undefined,\n    confirmButtonText: \"OK\",\n    confirmButtonAriaLabel: \"\",\n    confirmButtonColor: undefined,\n    denyButtonText: \"No\",\n    denyButtonAriaLabel: \"\",\n    denyButtonColor: undefined,\n    cancelButtonText: \"Cancel\",\n    cancelButtonAriaLabel: \"\",\n    cancelButtonColor: undefined,\n    buttonsStyling: true,\n    reverseButtons: false,\n    focusConfirm: true,\n    focusDeny: false,\n    focusCancel: false,\n    returnFocus: true,\n    showCloseButton: false,\n    closeButtonHtml: \"&times;\",\n    closeButtonAriaLabel: \"Close this dialog\",\n    loaderHtml: \"\",\n    showLoaderOnConfirm: false,\n    showLoaderOnDeny: false,\n    imageUrl: undefined,\n    imageWidth: undefined,\n    imageHeight: undefined,\n    imageAlt: \"\",\n    timer: undefined,\n    timerProgressBar: false,\n    width: undefined,\n    padding: undefined,\n    background: undefined,\n    input: undefined,\n    inputPlaceholder: \"\",\n    inputLabel: \"\",\n    inputValue: \"\",\n    inputOptions: {},\n    inputAutoFocus: true,\n    inputAutoTrim: true,\n    inputAttributes: {},\n    inputValidator: undefined,\n    returnInputValueOnDeny: false,\n    validationMessage: undefined,\n    grow: false,\n    position: \"center\",\n    progressSteps: [],\n    currentProgressStep: undefined,\n    progressStepsDistance: undefined,\n    willOpen: undefined,\n    didOpen: undefined,\n    didRender: undefined,\n    willClose: undefined,\n    didClose: undefined,\n    didDestroy: undefined,\n    scrollbarPadding: true\n};\nconst updatableParams = [\n    \"allowEscapeKey\",\n    \"allowOutsideClick\",\n    \"background\",\n    \"buttonsStyling\",\n    \"cancelButtonAriaLabel\",\n    \"cancelButtonColor\",\n    \"cancelButtonText\",\n    \"closeButtonAriaLabel\",\n    \"closeButtonHtml\",\n    \"color\",\n    \"confirmButtonAriaLabel\",\n    \"confirmButtonColor\",\n    \"confirmButtonText\",\n    \"currentProgressStep\",\n    \"customClass\",\n    \"denyButtonAriaLabel\",\n    \"denyButtonColor\",\n    \"denyButtonText\",\n    \"didClose\",\n    \"didDestroy\",\n    \"footer\",\n    \"hideClass\",\n    \"html\",\n    \"icon\",\n    \"iconColor\",\n    \"iconHtml\",\n    \"imageAlt\",\n    \"imageHeight\",\n    \"imageUrl\",\n    \"imageWidth\",\n    \"preConfirm\",\n    \"preDeny\",\n    \"progressSteps\",\n    \"returnFocus\",\n    \"reverseButtons\",\n    \"showCancelButton\",\n    \"showCloseButton\",\n    \"showConfirmButton\",\n    \"showDenyButton\",\n    \"text\",\n    \"title\",\n    \"titleText\",\n    \"willClose\"\n];\n/** @type {Record<string, string | undefined>} */ const deprecatedParams = {\n    allowEnterKey: undefined\n};\nconst toastIncompatibleParams = [\n    \"allowOutsideClick\",\n    \"allowEnterKey\",\n    \"backdrop\",\n    \"focusConfirm\",\n    \"focusDeny\",\n    \"focusCancel\",\n    \"returnFocus\",\n    \"heightAuto\",\n    \"keydownListenerCapture\"\n];\n/**\n * Is valid parameter\n *\n * @param {string} paramName\n * @returns {boolean}\n */ const isValidParameter = (paramName)=>{\n    return Object.prototype.hasOwnProperty.call(defaultParams, paramName);\n};\n/**\n * Is valid parameter for Swal.update() method\n *\n * @param {string} paramName\n * @returns {boolean}\n */ const isUpdatableParameter = (paramName)=>{\n    return updatableParams.indexOf(paramName) !== -1;\n};\n/**\n * Is deprecated parameter\n *\n * @param {string} paramName\n * @returns {string | undefined}\n */ const isDeprecatedParameter = (paramName)=>{\n    return deprecatedParams[paramName];\n};\n/**\n * @param {string} param\n */ const checkIfParamIsValid = (param)=>{\n    if (!isValidParameter(param)) {\n        warn(`Unknown parameter \"${param}\"`);\n    }\n};\n/**\n * @param {string} param\n */ const checkIfToastParamIsValid = (param)=>{\n    if (toastIncompatibleParams.includes(param)) {\n        warn(`The parameter \"${param}\" is incompatible with toasts`);\n    }\n};\n/**\n * @param {string} param\n */ const checkIfParamIsDeprecated = (param)=>{\n    const isDeprecated = isDeprecatedParameter(param);\n    if (isDeprecated) {\n        warnAboutDeprecation(param, isDeprecated);\n    }\n};\n/**\n * Show relevant warnings for given params\n *\n * @param {SweetAlertOptions} params\n */ const showWarningsForParams = (params)=>{\n    if (params.backdrop === false && params.allowOutsideClick) {\n        warn('\"allowOutsideClick\" parameter requires `backdrop` parameter to be set to `true`');\n    }\n    for(const param in params){\n        checkIfParamIsValid(param);\n        if (params.toast) {\n            checkIfToastParamIsValid(param);\n        }\n        checkIfParamIsDeprecated(param);\n    }\n};\n/**\n * Updates popup parameters.\n *\n * @param {SweetAlertOptions} params\n */ function update(params) {\n    const popup = getPopup();\n    const innerParams = privateProps.innerParams.get(this);\n    if (!popup || hasClass(popup, innerParams.hideClass.popup)) {\n        warn(`You're trying to update the closed or closing popup, that won't work. Use the update() method in preConfirm parameter or show a new popup.`);\n        return;\n    }\n    const validUpdatableParams = filterValidParams(params);\n    const updatedParams = Object.assign({}, innerParams, validUpdatableParams);\n    render(this, updatedParams);\n    privateProps.innerParams.set(this, updatedParams);\n    Object.defineProperties(this, {\n        params: {\n            value: Object.assign({}, this.params, params),\n            writable: false,\n            enumerable: true\n        }\n    });\n}\n/**\n * @param {SweetAlertOptions} params\n * @returns {SweetAlertOptions}\n */ const filterValidParams = (params)=>{\n    const validUpdatableParams = {};\n    Object.keys(params).forEach((param)=>{\n        if (isUpdatableParameter(param)) {\n            validUpdatableParams[param] = params[param];\n        } else {\n            warn(`Invalid parameter to update: ${param}`);\n        }\n    });\n    return validUpdatableParams;\n};\n/**\n * Dispose the current SweetAlert2 instance\n */ function _destroy() {\n    const domCache = privateProps.domCache.get(this);\n    const innerParams = privateProps.innerParams.get(this);\n    if (!innerParams) {\n        disposeWeakMaps(this); // The WeakMaps might have been partly destroyed, we must recall it to dispose any remaining WeakMaps #2335\n        return; // This instance has already been destroyed\n    }\n    // Check if there is another Swal closing\n    if (domCache.popup && globalState.swalCloseEventFinishedCallback) {\n        globalState.swalCloseEventFinishedCallback();\n        delete globalState.swalCloseEventFinishedCallback;\n    }\n    if (typeof innerParams.didDestroy === \"function\") {\n        innerParams.didDestroy();\n    }\n    globalState.eventEmitter.emit(\"didDestroy\");\n    disposeSwal(this);\n}\n/**\n * @param {SweetAlert} instance\n */ const disposeSwal = (instance)=>{\n    disposeWeakMaps(instance);\n    // Unset this.params so GC will dispose it (#1569)\n    delete instance.params;\n    // Unset globalState props so GC will dispose globalState (#1569)\n    delete globalState.keydownHandler;\n    delete globalState.keydownTarget;\n    // Unset currentInstance\n    delete globalState.currentInstance;\n};\n/**\n * @param {SweetAlert} instance\n */ const disposeWeakMaps = (instance)=>{\n    // If the current instance is awaiting a promise result, we keep the privateMethods to call them once the promise result is retrieved #2335\n    if (instance.isAwaitingPromise) {\n        unsetWeakMaps(privateProps, instance);\n        instance.isAwaitingPromise = true;\n    } else {\n        unsetWeakMaps(privateMethods, instance);\n        unsetWeakMaps(privateProps, instance);\n        delete instance.isAwaitingPromise;\n        // Unset instance methods\n        delete instance.disableButtons;\n        delete instance.enableButtons;\n        delete instance.getInput;\n        delete instance.disableInput;\n        delete instance.enableInput;\n        delete instance.hideLoading;\n        delete instance.disableLoading;\n        delete instance.showValidationMessage;\n        delete instance.resetValidationMessage;\n        delete instance.close;\n        delete instance.closePopup;\n        delete instance.closeModal;\n        delete instance.closeToast;\n        delete instance.rejectPromise;\n        delete instance.update;\n        delete instance._destroy;\n    }\n};\n/**\n * @param {object} obj\n * @param {SweetAlert} instance\n */ const unsetWeakMaps = (obj, instance)=>{\n    for(const i in obj){\n        obj[i].delete(instance);\n    }\n};\nvar instanceMethods = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    _destroy: _destroy,\n    close: close,\n    closeModal: close,\n    closePopup: close,\n    closeToast: close,\n    disableButtons: disableButtons,\n    disableInput: disableInput,\n    disableLoading: hideLoading,\n    enableButtons: enableButtons,\n    enableInput: enableInput,\n    getInput: getInput,\n    handleAwaitingPromise: handleAwaitingPromise,\n    hideLoading: hideLoading,\n    rejectPromise: rejectPromise,\n    resetValidationMessage: resetValidationMessage,\n    showValidationMessage: showValidationMessage,\n    update: update\n});\n/**\n * @param {SweetAlertOptions} innerParams\n * @param {DomCache} domCache\n * @param {Function} dismissWith\n */ const handlePopupClick = (innerParams, domCache, dismissWith)=>{\n    if (innerParams.toast) {\n        handleToastClick(innerParams, domCache, dismissWith);\n    } else {\n        // Ignore click events that had mousedown on the popup but mouseup on the container\n        // This can happen when the user drags a slider\n        handleModalMousedown(domCache);\n        // Ignore click events that had mousedown on the container but mouseup on the popup\n        handleContainerMousedown(domCache);\n        handleModalClick(innerParams, domCache, dismissWith);\n    }\n};\n/**\n * @param {SweetAlertOptions} innerParams\n * @param {DomCache} domCache\n * @param {Function} dismissWith\n */ const handleToastClick = (innerParams, domCache, dismissWith)=>{\n    // Closing toast by internal click\n    domCache.popup.onclick = ()=>{\n        if (innerParams && (isAnyButtonShown(innerParams) || innerParams.timer || innerParams.input)) {\n            return;\n        }\n        dismissWith(DismissReason.close);\n    };\n};\n/**\n * @param {SweetAlertOptions} innerParams\n * @returns {boolean}\n */ const isAnyButtonShown = (innerParams)=>{\n    return !!(innerParams.showConfirmButton || innerParams.showDenyButton || innerParams.showCancelButton || innerParams.showCloseButton);\n};\nlet ignoreOutsideClick = false;\n/**\n * @param {DomCache} domCache\n */ const handleModalMousedown = (domCache)=>{\n    domCache.popup.onmousedown = ()=>{\n        domCache.container.onmouseup = function(e) {\n            domCache.container.onmouseup = ()=>{};\n            // We only check if the mouseup target is the container because usually it doesn't\n            // have any other direct children aside of the popup\n            if (e.target === domCache.container) {\n                ignoreOutsideClick = true;\n            }\n        };\n    };\n};\n/**\n * @param {DomCache} domCache\n */ const handleContainerMousedown = (domCache)=>{\n    domCache.container.onmousedown = (e)=>{\n        // prevent the modal text from being selected on double click on the container (allowOutsideClick: false)\n        if (e.target === domCache.container) {\n            e.preventDefault();\n        }\n        domCache.popup.onmouseup = function(e) {\n            domCache.popup.onmouseup = ()=>{};\n            // We also need to check if the mouseup target is a child of the popup\n            if (e.target === domCache.popup || e.target instanceof HTMLElement && domCache.popup.contains(e.target)) {\n                ignoreOutsideClick = true;\n            }\n        };\n    };\n};\n/**\n * @param {SweetAlertOptions} innerParams\n * @param {DomCache} domCache\n * @param {Function} dismissWith\n */ const handleModalClick = (innerParams, domCache, dismissWith)=>{\n    domCache.container.onclick = (e)=>{\n        if (ignoreOutsideClick) {\n            ignoreOutsideClick = false;\n            return;\n        }\n        if (e.target === domCache.container && callIfFunction(innerParams.allowOutsideClick)) {\n            dismissWith(DismissReason.backdrop);\n        }\n    };\n};\nconst isJqueryElement = (elem)=>typeof elem === \"object\" && elem.jquery;\nconst isElement = (elem)=>elem instanceof Element || isJqueryElement(elem);\nconst argsToParams = (args)=>{\n    const params = {};\n    if (typeof args[0] === \"object\" && !isElement(args[0])) {\n        Object.assign(params, args[0]);\n    } else {\n        [\n            \"title\",\n            \"html\",\n            \"icon\"\n        ].forEach((name, index)=>{\n            const arg = args[index];\n            if (typeof arg === \"string\" || isElement(arg)) {\n                params[name] = arg;\n            } else if (arg !== undefined) {\n                error(`Unexpected type of ${name}! Expected \"string\" or \"Element\", got ${typeof arg}`);\n            }\n        });\n    }\n    return params;\n};\n/**\n * Main method to create a new SweetAlert2 popup\n *\n * @param  {...SweetAlertOptions} args\n * @returns {Promise<SweetAlertResult>}\n */ function fire() {\n    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n        args[_key] = arguments[_key];\n    }\n    return new this(...args);\n}\n/**\n * Returns an extended version of `Swal` containing `params` as defaults.\n * Useful for reusing Swal configuration.\n *\n * For example:\n *\n * Before:\n * const textPromptOptions = { input: 'text', showCancelButton: true }\n * const {value: firstName} = await Swal.fire({ ...textPromptOptions, title: 'What is your first name?' })\n * const {value: lastName} = await Swal.fire({ ...textPromptOptions, title: 'What is your last name?' })\n *\n * After:\n * const TextPrompt = Swal.mixin({ input: 'text', showCancelButton: true })\n * const {value: firstName} = await TextPrompt('What is your first name?')\n * const {value: lastName} = await TextPrompt('What is your last name?')\n *\n * @param {SweetAlertOptions} mixinParams\n * @returns {SweetAlert}\n */ function mixin(mixinParams) {\n    class MixinSwal extends this {\n        _main(params, priorityMixinParams) {\n            return super._main(params, Object.assign({}, mixinParams, priorityMixinParams));\n        }\n    }\n    // @ts-ignore\n    return MixinSwal;\n}\n/**\n * If `timer` parameter is set, returns number of milliseconds of timer remained.\n * Otherwise, returns undefined.\n *\n * @returns {number | undefined}\n */ const getTimerLeft = ()=>{\n    return globalState.timeout && globalState.timeout.getTimerLeft();\n};\n/**\n * Stop timer. Returns number of milliseconds of timer remained.\n * If `timer` parameter isn't set, returns undefined.\n *\n * @returns {number | undefined}\n */ const stopTimer = ()=>{\n    if (globalState.timeout) {\n        stopTimerProgressBar();\n        return globalState.timeout.stop();\n    }\n};\n/**\n * Resume timer. Returns number of milliseconds of timer remained.\n * If `timer` parameter isn't set, returns undefined.\n *\n * @returns {number | undefined}\n */ const resumeTimer = ()=>{\n    if (globalState.timeout) {\n        const remaining = globalState.timeout.start();\n        animateTimerProgressBar(remaining);\n        return remaining;\n    }\n};\n/**\n * Resume timer. Returns number of milliseconds of timer remained.\n * If `timer` parameter isn't set, returns undefined.\n *\n * @returns {number | undefined}\n */ const toggleTimer = ()=>{\n    const timer = globalState.timeout;\n    return timer && (timer.running ? stopTimer() : resumeTimer());\n};\n/**\n * Increase timer. Returns number of milliseconds of an updated timer.\n * If `timer` parameter isn't set, returns undefined.\n *\n * @param {number} ms\n * @returns {number | undefined}\n */ const increaseTimer = (ms)=>{\n    if (globalState.timeout) {\n        const remaining = globalState.timeout.increase(ms);\n        animateTimerProgressBar(remaining, true);\n        return remaining;\n    }\n};\n/**\n * Check if timer is running. Returns true if timer is running\n * or false if timer is paused or stopped.\n * If `timer` parameter isn't set, returns undefined\n *\n * @returns {boolean}\n */ const isTimerRunning = ()=>{\n    return !!(globalState.timeout && globalState.timeout.isRunning());\n};\nlet bodyClickListenerAdded = false;\nconst clickHandlers = {};\n/**\n * @param {string} attr\n */ function bindClickHandler() {\n    let attr = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"data-swal-template\";\n    clickHandlers[attr] = this;\n    if (!bodyClickListenerAdded) {\n        document.body.addEventListener(\"click\", bodyClickListener);\n        bodyClickListenerAdded = true;\n    }\n}\nconst bodyClickListener = (event)=>{\n    for(let el = event.target; el && el !== document; el = el.parentNode){\n        for(const attr in clickHandlers){\n            const template = el.getAttribute(attr);\n            if (template) {\n                clickHandlers[attr].fire({\n                    template\n                });\n                return;\n            }\n        }\n    }\n};\n// Source: https://gist.github.com/mudge/5830382?permalink_comment_id=2691957#gistcomment-2691957\nclass EventEmitter {\n    constructor(){\n        /** @type {Events} */ this.events = {};\n    }\n    /**\n   * @param {string} eventName\n   * @returns {EventHandlers}\n   */ _getHandlersByEventName(eventName) {\n        if (typeof this.events[eventName] === \"undefined\") {\n            // not Set because we need to keep the FIFO order\n            // https://github.com/sweetalert2/sweetalert2/pull/2763#discussion_r1748990334\n            this.events[eventName] = [];\n        }\n        return this.events[eventName];\n    }\n    /**\n   * @param {string} eventName\n   * @param {EventHandler} eventHandler\n   */ on(eventName, eventHandler) {\n        const currentHandlers = this._getHandlersByEventName(eventName);\n        if (!currentHandlers.includes(eventHandler)) {\n            currentHandlers.push(eventHandler);\n        }\n    }\n    /**\n   * @param {string} eventName\n   * @param {EventHandler} eventHandler\n   */ once(eventName, eventHandler) {\n        var _this = this;\n        /**\n     * @param {Array} args\n     */ const onceFn = function() {\n            _this.removeListener(eventName, onceFn);\n            for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n                args[_key] = arguments[_key];\n            }\n            eventHandler.apply(_this, args);\n        };\n        this.on(eventName, onceFn);\n    }\n    /**\n   * @param {string} eventName\n   * @param {Array} args\n   */ emit(eventName) {\n        for(var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++){\n            args[_key2 - 1] = arguments[_key2];\n        }\n        this._getHandlersByEventName(eventName).forEach(/**\n     * @param {EventHandler} eventHandler\n     */ (eventHandler)=>{\n            try {\n                eventHandler.apply(this, args);\n            } catch (error) {\n                console.error(error);\n            }\n        });\n    }\n    /**\n   * @param {string} eventName\n   * @param {EventHandler} eventHandler\n   */ removeListener(eventName, eventHandler) {\n        const currentHandlers = this._getHandlersByEventName(eventName);\n        const index = currentHandlers.indexOf(eventHandler);\n        if (index > -1) {\n            currentHandlers.splice(index, 1);\n        }\n    }\n    /**\n   * @param {string} eventName\n   */ removeAllListeners(eventName) {\n        if (this.events[eventName] !== undefined) {\n            // https://github.com/sweetalert2/sweetalert2/pull/2763#discussion_r1749239222\n            this.events[eventName].length = 0;\n        }\n    }\n    reset() {\n        this.events = {};\n    }\n}\nglobalState.eventEmitter = new EventEmitter();\n/**\n * @param {string} eventName\n * @param {EventHandler} eventHandler\n */ const on = (eventName, eventHandler)=>{\n    globalState.eventEmitter.on(eventName, eventHandler);\n};\n/**\n * @param {string} eventName\n * @param {EventHandler} eventHandler\n */ const once = (eventName, eventHandler)=>{\n    globalState.eventEmitter.once(eventName, eventHandler);\n};\n/**\n * @param {string} [eventName]\n * @param {EventHandler} [eventHandler]\n */ const off = (eventName, eventHandler)=>{\n    // Remove all handlers for all events\n    if (!eventName) {\n        globalState.eventEmitter.reset();\n        return;\n    }\n    if (eventHandler) {\n        // Remove a specific handler\n        globalState.eventEmitter.removeListener(eventName, eventHandler);\n    } else {\n        // Remove all handlers for a specific event\n        globalState.eventEmitter.removeAllListeners(eventName);\n    }\n};\nvar staticMethods = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    argsToParams: argsToParams,\n    bindClickHandler: bindClickHandler,\n    clickCancel: clickCancel,\n    clickConfirm: clickConfirm,\n    clickDeny: clickDeny,\n    enableLoading: showLoading,\n    fire: fire,\n    getActions: getActions,\n    getCancelButton: getCancelButton,\n    getCloseButton: getCloseButton,\n    getConfirmButton: getConfirmButton,\n    getContainer: getContainer,\n    getDenyButton: getDenyButton,\n    getFocusableElements: getFocusableElements,\n    getFooter: getFooter,\n    getHtmlContainer: getHtmlContainer,\n    getIcon: getIcon,\n    getIconContent: getIconContent,\n    getImage: getImage,\n    getInputLabel: getInputLabel,\n    getLoader: getLoader,\n    getPopup: getPopup,\n    getProgressSteps: getProgressSteps,\n    getTimerLeft: getTimerLeft,\n    getTimerProgressBar: getTimerProgressBar,\n    getTitle: getTitle,\n    getValidationMessage: getValidationMessage,\n    increaseTimer: increaseTimer,\n    isDeprecatedParameter: isDeprecatedParameter,\n    isLoading: isLoading,\n    isTimerRunning: isTimerRunning,\n    isUpdatableParameter: isUpdatableParameter,\n    isValidParameter: isValidParameter,\n    isVisible: isVisible,\n    mixin: mixin,\n    off: off,\n    on: on,\n    once: once,\n    resumeTimer: resumeTimer,\n    showLoading: showLoading,\n    stopTimer: stopTimer,\n    toggleTimer: toggleTimer\n});\nclass Timer {\n    /**\n   * @param {Function} callback\n   * @param {number} delay\n   */ constructor(callback, delay){\n        this.callback = callback;\n        this.remaining = delay;\n        this.running = false;\n        this.start();\n    }\n    /**\n   * @returns {number}\n   */ start() {\n        if (!this.running) {\n            this.running = true;\n            this.started = new Date();\n            this.id = setTimeout(this.callback, this.remaining);\n        }\n        return this.remaining;\n    }\n    /**\n   * @returns {number}\n   */ stop() {\n        if (this.started && this.running) {\n            this.running = false;\n            clearTimeout(this.id);\n            this.remaining -= new Date().getTime() - this.started.getTime();\n        }\n        return this.remaining;\n    }\n    /**\n   * @param {number} n\n   * @returns {number}\n   */ increase(n) {\n        const running = this.running;\n        if (running) {\n            this.stop();\n        }\n        this.remaining += n;\n        if (running) {\n            this.start();\n        }\n        return this.remaining;\n    }\n    /**\n   * @returns {number}\n   */ getTimerLeft() {\n        if (this.running) {\n            this.stop();\n            this.start();\n        }\n        return this.remaining;\n    }\n    /**\n   * @returns {boolean}\n   */ isRunning() {\n        return this.running;\n    }\n}\nconst swalStringParams = [\n    \"swal-title\",\n    \"swal-html\",\n    \"swal-footer\"\n];\n/**\n * @param {SweetAlertOptions} params\n * @returns {SweetAlertOptions}\n */ const getTemplateParams = (params)=>{\n    const template = typeof params.template === \"string\" ? /** @type {HTMLTemplateElement} */ document.querySelector(params.template) : params.template;\n    if (!template) {\n        return {};\n    }\n    /** @type {DocumentFragment} */ const templateContent = template.content;\n    showWarningsForElements(templateContent);\n    const result = Object.assign(getSwalParams(templateContent), getSwalFunctionParams(templateContent), getSwalButtons(templateContent), getSwalImage(templateContent), getSwalIcon(templateContent), getSwalInput(templateContent), getSwalStringParams(templateContent, swalStringParams));\n    return result;\n};\n/**\n * @param {DocumentFragment} templateContent\n * @returns {Record<string, any>}\n */ const getSwalParams = (templateContent)=>{\n    /** @type {Record<string, any>} */ const result = {};\n    /** @type {HTMLElement[]} */ const swalParams = Array.from(templateContent.querySelectorAll(\"swal-param\"));\n    swalParams.forEach((param)=>{\n        showWarningsForAttributes(param, [\n            \"name\",\n            \"value\"\n        ]);\n        const paramName = /** @type {keyof SweetAlertOptions} */ param.getAttribute(\"name\");\n        const value = param.getAttribute(\"value\");\n        if (!paramName || !value) {\n            return;\n        }\n        if (typeof defaultParams[paramName] === \"boolean\") {\n            result[paramName] = value !== \"false\";\n        } else if (typeof defaultParams[paramName] === \"object\") {\n            result[paramName] = JSON.parse(value);\n        } else {\n            result[paramName] = value;\n        }\n    });\n    return result;\n};\n/**\n * @param {DocumentFragment} templateContent\n * @returns {Record<string, any>}\n */ const getSwalFunctionParams = (templateContent)=>{\n    /** @type {Record<string, any>} */ const result = {};\n    /** @type {HTMLElement[]} */ const swalFunctions = Array.from(templateContent.querySelectorAll(\"swal-function-param\"));\n    swalFunctions.forEach((param)=>{\n        const paramName = /** @type {keyof SweetAlertOptions} */ param.getAttribute(\"name\");\n        const value = param.getAttribute(\"value\");\n        if (!paramName || !value) {\n            return;\n        }\n        result[paramName] = new Function(`return ${value}`)();\n    });\n    return result;\n};\n/**\n * @param {DocumentFragment} templateContent\n * @returns {Record<string, any>}\n */ const getSwalButtons = (templateContent)=>{\n    /** @type {Record<string, any>} */ const result = {};\n    /** @type {HTMLElement[]} */ const swalButtons = Array.from(templateContent.querySelectorAll(\"swal-button\"));\n    swalButtons.forEach((button)=>{\n        showWarningsForAttributes(button, [\n            \"type\",\n            \"color\",\n            \"aria-label\"\n        ]);\n        const type = button.getAttribute(\"type\");\n        if (!type || ![\n            \"confirm\",\n            \"cancel\",\n            \"deny\"\n        ].includes(type)) {\n            return;\n        }\n        result[`${type}ButtonText`] = button.innerHTML;\n        result[`show${capitalizeFirstLetter(type)}Button`] = true;\n        if (button.hasAttribute(\"color\")) {\n            result[`${type}ButtonColor`] = button.getAttribute(\"color\");\n        }\n        if (button.hasAttribute(\"aria-label\")) {\n            result[`${type}ButtonAriaLabel`] = button.getAttribute(\"aria-label\");\n        }\n    });\n    return result;\n};\n/**\n * @param {DocumentFragment} templateContent\n * @returns {Pick<SweetAlertOptions, 'imageUrl' | 'imageWidth' | 'imageHeight' | 'imageAlt'>}\n */ const getSwalImage = (templateContent)=>{\n    const result = {};\n    /** @type {HTMLElement | null} */ const image = templateContent.querySelector(\"swal-image\");\n    if (image) {\n        showWarningsForAttributes(image, [\n            \"src\",\n            \"width\",\n            \"height\",\n            \"alt\"\n        ]);\n        if (image.hasAttribute(\"src\")) {\n            result.imageUrl = image.getAttribute(\"src\") || undefined;\n        }\n        if (image.hasAttribute(\"width\")) {\n            result.imageWidth = image.getAttribute(\"width\") || undefined;\n        }\n        if (image.hasAttribute(\"height\")) {\n            result.imageHeight = image.getAttribute(\"height\") || undefined;\n        }\n        if (image.hasAttribute(\"alt\")) {\n            result.imageAlt = image.getAttribute(\"alt\") || undefined;\n        }\n    }\n    return result;\n};\n/**\n * @param {DocumentFragment} templateContent\n * @returns {Record<string, any>}\n */ const getSwalIcon = (templateContent)=>{\n    const result = {};\n    /** @type {HTMLElement | null} */ const icon = templateContent.querySelector(\"swal-icon\");\n    if (icon) {\n        showWarningsForAttributes(icon, [\n            \"type\",\n            \"color\"\n        ]);\n        if (icon.hasAttribute(\"type\")) {\n            result.icon = icon.getAttribute(\"type\");\n        }\n        if (icon.hasAttribute(\"color\")) {\n            result.iconColor = icon.getAttribute(\"color\");\n        }\n        result.iconHtml = icon.innerHTML;\n    }\n    return result;\n};\n/**\n * @param {DocumentFragment} templateContent\n * @returns {Record<string, any>}\n */ const getSwalInput = (templateContent)=>{\n    /** @type {Record<string, any>} */ const result = {};\n    /** @type {HTMLElement | null} */ const input = templateContent.querySelector(\"swal-input\");\n    if (input) {\n        showWarningsForAttributes(input, [\n            \"type\",\n            \"label\",\n            \"placeholder\",\n            \"value\"\n        ]);\n        result.input = input.getAttribute(\"type\") || \"text\";\n        if (input.hasAttribute(\"label\")) {\n            result.inputLabel = input.getAttribute(\"label\");\n        }\n        if (input.hasAttribute(\"placeholder\")) {\n            result.inputPlaceholder = input.getAttribute(\"placeholder\");\n        }\n        if (input.hasAttribute(\"value\")) {\n            result.inputValue = input.getAttribute(\"value\");\n        }\n    }\n    /** @type {HTMLElement[]} */ const inputOptions = Array.from(templateContent.querySelectorAll(\"swal-input-option\"));\n    if (inputOptions.length) {\n        result.inputOptions = {};\n        inputOptions.forEach((option)=>{\n            showWarningsForAttributes(option, [\n                \"value\"\n            ]);\n            const optionValue = option.getAttribute(\"value\");\n            if (!optionValue) {\n                return;\n            }\n            const optionName = option.innerHTML;\n            result.inputOptions[optionValue] = optionName;\n        });\n    }\n    return result;\n};\n/**\n * @param {DocumentFragment} templateContent\n * @param {string[]} paramNames\n * @returns {Record<string, any>}\n */ const getSwalStringParams = (templateContent, paramNames)=>{\n    /** @type {Record<string, any>} */ const result = {};\n    for(const i in paramNames){\n        const paramName = paramNames[i];\n        /** @type {HTMLElement | null} */ const tag = templateContent.querySelector(paramName);\n        if (tag) {\n            showWarningsForAttributes(tag, []);\n            result[paramName.replace(/^swal-/, \"\")] = tag.innerHTML.trim();\n        }\n    }\n    return result;\n};\n/**\n * @param {DocumentFragment} templateContent\n */ const showWarningsForElements = (templateContent)=>{\n    const allowedElements = swalStringParams.concat([\n        \"swal-param\",\n        \"swal-function-param\",\n        \"swal-button\",\n        \"swal-image\",\n        \"swal-icon\",\n        \"swal-input\",\n        \"swal-input-option\"\n    ]);\n    Array.from(templateContent.children).forEach((el)=>{\n        const tagName = el.tagName.toLowerCase();\n        if (!allowedElements.includes(tagName)) {\n            warn(`Unrecognized element <${tagName}>`);\n        }\n    });\n};\n/**\n * @param {HTMLElement} el\n * @param {string[]} allowedAttributes\n */ const showWarningsForAttributes = (el, allowedAttributes)=>{\n    Array.from(el.attributes).forEach((attribute)=>{\n        if (allowedAttributes.indexOf(attribute.name) === -1) {\n            warn([\n                `Unrecognized attribute \"${attribute.name}\" on <${el.tagName.toLowerCase()}>.`,\n                `${allowedAttributes.length ? `Allowed attributes are: ${allowedAttributes.join(\", \")}` : \"To set the value, use HTML within the element.\"}`\n            ]);\n        }\n    });\n};\nconst SHOW_CLASS_TIMEOUT = 10;\n/**\n * Open popup, add necessary classes and styles, fix scrollbar\n *\n * @param {SweetAlertOptions} params\n */ const openPopup = (params)=>{\n    const container = getContainer();\n    const popup = getPopup();\n    if (typeof params.willOpen === \"function\") {\n        params.willOpen(popup);\n    }\n    globalState.eventEmitter.emit(\"willOpen\", popup);\n    const bodyStyles = window.getComputedStyle(document.body);\n    const initialBodyOverflow = bodyStyles.overflowY;\n    addClasses(container, popup, params);\n    // scrolling is 'hidden' until animation is done, after that 'auto'\n    setTimeout(()=>{\n        setScrollingVisibility(container, popup);\n    }, SHOW_CLASS_TIMEOUT);\n    if (isModal()) {\n        fixScrollContainer(container, params.scrollbarPadding, initialBodyOverflow);\n        setAriaHidden();\n    }\n    if (!isToast() && !globalState.previousActiveElement) {\n        globalState.previousActiveElement = document.activeElement;\n    }\n    if (typeof params.didOpen === \"function\") {\n        setTimeout(()=>params.didOpen(popup));\n    }\n    globalState.eventEmitter.emit(\"didOpen\", popup);\n    removeClass(container, swalClasses[\"no-transition\"]);\n};\n/**\n * @param {AnimationEvent} event\n */ const swalOpenAnimationFinished = (event)=>{\n    const popup = getPopup();\n    if (event.target !== popup || !animationEndEvent) {\n        return;\n    }\n    const container = getContainer();\n    popup.removeEventListener(animationEndEvent, swalOpenAnimationFinished);\n    container.style.overflowY = \"auto\";\n};\n/**\n * @param {HTMLElement} container\n * @param {HTMLElement} popup\n */ const setScrollingVisibility = (container, popup)=>{\n    if (animationEndEvent && hasCssAnimation(popup)) {\n        container.style.overflowY = \"hidden\";\n        popup.addEventListener(animationEndEvent, swalOpenAnimationFinished);\n    } else {\n        container.style.overflowY = \"auto\";\n    }\n};\n/**\n * @param {HTMLElement} container\n * @param {boolean} scrollbarPadding\n * @param {string} initialBodyOverflow\n */ const fixScrollContainer = (container, scrollbarPadding, initialBodyOverflow)=>{\n    iOSfix();\n    if (scrollbarPadding && initialBodyOverflow !== \"hidden\") {\n        replaceScrollbarWithPadding(initialBodyOverflow);\n    }\n    // sweetalert2/issues/1247\n    setTimeout(()=>{\n        container.scrollTop = 0;\n    });\n};\n/**\n * @param {HTMLElement} container\n * @param {HTMLElement} popup\n * @param {SweetAlertOptions} params\n */ const addClasses = (container, popup, params)=>{\n    addClass(container, params.showClass.backdrop);\n    if (params.animation) {\n        // this workaround with opacity is needed for https://github.com/sweetalert2/sweetalert2/issues/2059\n        popup.style.setProperty(\"opacity\", \"0\", \"important\");\n        show(popup, \"grid\");\n        setTimeout(()=>{\n            // Animate popup right after showing it\n            addClass(popup, params.showClass.popup);\n            // and remove the opacity workaround\n            popup.style.removeProperty(\"opacity\");\n        }, SHOW_CLASS_TIMEOUT); // 10ms in order to fix #2062\n    } else {\n        show(popup, \"grid\");\n    }\n    addClass([\n        document.documentElement,\n        document.body\n    ], swalClasses.shown);\n    if (params.heightAuto && params.backdrop && !params.toast) {\n        addClass([\n            document.documentElement,\n            document.body\n        ], swalClasses[\"height-auto\"]);\n    }\n};\nvar defaultInputValidators = {\n    /**\n   * @param {string} string\n   * @param {string} [validationMessage]\n   * @returns {Promise<string | void>}\n   */ email: (string, validationMessage)=>{\n        return /^[a-zA-Z0-9.+_'-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z0-9-]+$/.test(string) ? Promise.resolve() : Promise.resolve(validationMessage || \"Invalid email address\");\n    },\n    /**\n   * @param {string} string\n   * @param {string} [validationMessage]\n   * @returns {Promise<string | void>}\n   */ url: (string, validationMessage)=>{\n        // taken from https://stackoverflow.com/a/3809435 with a small change from #1306 and #2013\n        return /^https?:\\/\\/(www\\.)?[-a-zA-Z0-9@:%._+~#=]{1,256}\\.[a-z]{2,63}\\b([-a-zA-Z0-9@:%_+.~#?&/=]*)$/.test(string) ? Promise.resolve() : Promise.resolve(validationMessage || \"Invalid URL\");\n    }\n};\n/**\n * @param {SweetAlertOptions} params\n */ function setDefaultInputValidators(params) {\n    // Use default `inputValidator` for supported input types if not provided\n    if (params.inputValidator) {\n        return;\n    }\n    if (params.input === \"email\") {\n        params.inputValidator = defaultInputValidators[\"email\"];\n    }\n    if (params.input === \"url\") {\n        params.inputValidator = defaultInputValidators[\"url\"];\n    }\n}\n/**\n * @param {SweetAlertOptions} params\n */ function validateCustomTargetElement(params) {\n    // Determine if the custom target element is valid\n    if (!params.target || typeof params.target === \"string\" && !document.querySelector(params.target) || typeof params.target !== \"string\" && !params.target.appendChild) {\n        warn('Target parameter is not valid, defaulting to \"body\"');\n        params.target = \"body\";\n    }\n}\n/**\n * Set type, text and actions on popup\n *\n * @param {SweetAlertOptions} params\n */ function setParameters(params) {\n    setDefaultInputValidators(params);\n    // showLoaderOnConfirm && preConfirm\n    if (params.showLoaderOnConfirm && !params.preConfirm) {\n        warn(\"showLoaderOnConfirm is set to true, but preConfirm is not defined.\\n\" + \"showLoaderOnConfirm should be used together with preConfirm, see usage example:\\n\" + \"https://sweetalert2.github.io/#ajax-request\");\n    }\n    validateCustomTargetElement(params);\n    // Replace newlines with <br> in title\n    if (typeof params.title === \"string\") {\n        params.title = params.title.split(\"\\n\").join(\"<br />\");\n    }\n    init(params);\n}\n/** @type {SweetAlert} */ let currentInstance;\nvar _promise = /*#__PURE__*/ new WeakMap();\nclass SweetAlert {\n    /**\n   * @param {...any} args\n   * @this {SweetAlert}\n   */ constructor(){\n        /**\n     * @type {Promise<SweetAlertResult>}\n     */ _classPrivateFieldInitSpec(this, _promise, void 0);\n        // Prevent run in Node env\n        if (true) {\n            return;\n        }\n        currentInstance = this;\n        // @ts-ignore\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        const outerParams = Object.freeze(this.constructor.argsToParams(args));\n        /** @type {Readonly<SweetAlertOptions>} */ this.params = outerParams;\n        /** @type {boolean} */ this.isAwaitingPromise = false;\n        _classPrivateFieldSet2(_promise, this, this._main(currentInstance.params));\n    }\n    _main(userParams) {\n        let mixinParams = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        showWarningsForParams(Object.assign({}, mixinParams, userParams));\n        if (globalState.currentInstance) {\n            const swalPromiseResolve = privateMethods.swalPromiseResolve.get(globalState.currentInstance);\n            const { isAwaitingPromise } = globalState.currentInstance;\n            globalState.currentInstance._destroy();\n            if (!isAwaitingPromise) {\n                swalPromiseResolve({\n                    isDismissed: true\n                });\n            }\n            if (isModal()) {\n                unsetAriaHidden();\n            }\n        }\n        globalState.currentInstance = currentInstance;\n        const innerParams = prepareParams(userParams, mixinParams);\n        setParameters(innerParams);\n        Object.freeze(innerParams);\n        // clear the previous timer\n        if (globalState.timeout) {\n            globalState.timeout.stop();\n            delete globalState.timeout;\n        }\n        // clear the restore focus timeout\n        clearTimeout(globalState.restoreFocusTimeout);\n        const domCache = populateDomCache(currentInstance);\n        render(currentInstance, innerParams);\n        privateProps.innerParams.set(currentInstance, innerParams);\n        return swalPromise(currentInstance, domCache, innerParams);\n    }\n    // `catch` cannot be the name of a module export, so we define our thenable methods here instead\n    then(onFulfilled) {\n        return _classPrivateFieldGet2(_promise, this).then(onFulfilled);\n    }\n    finally(onFinally) {\n        return _classPrivateFieldGet2(_promise, this).finally(onFinally);\n    }\n}\n/**\n * @param {SweetAlert} instance\n * @param {DomCache} domCache\n * @param {SweetAlertOptions} innerParams\n * @returns {Promise}\n */ const swalPromise = (instance, domCache, innerParams)=>{\n    return new Promise((resolve, reject)=>{\n        // functions to handle all closings/dismissals\n        /**\n     * @param {DismissReason} dismiss\n     */ const dismissWith = (dismiss)=>{\n            instance.close({\n                isDismissed: true,\n                dismiss\n            });\n        };\n        privateMethods.swalPromiseResolve.set(instance, resolve);\n        privateMethods.swalPromiseReject.set(instance, reject);\n        domCache.confirmButton.onclick = ()=>{\n            handleConfirmButtonClick(instance);\n        };\n        domCache.denyButton.onclick = ()=>{\n            handleDenyButtonClick(instance);\n        };\n        domCache.cancelButton.onclick = ()=>{\n            handleCancelButtonClick(instance, dismissWith);\n        };\n        domCache.closeButton.onclick = ()=>{\n            dismissWith(DismissReason.close);\n        };\n        handlePopupClick(innerParams, domCache, dismissWith);\n        addKeydownHandler(globalState, innerParams, dismissWith);\n        handleInputOptionsAndValue(instance, innerParams);\n        openPopup(innerParams);\n        setupTimer(globalState, innerParams, dismissWith);\n        initFocus(domCache, innerParams);\n        // Scroll container to top on open (#1247, #1946)\n        setTimeout(()=>{\n            domCache.container.scrollTop = 0;\n        });\n    });\n};\n/**\n * @param {SweetAlertOptions} userParams\n * @param {SweetAlertOptions} mixinParams\n * @returns {SweetAlertOptions}\n */ const prepareParams = (userParams, mixinParams)=>{\n    const templateParams = getTemplateParams(userParams);\n    const params = Object.assign({}, defaultParams, mixinParams, templateParams, userParams); // precedence is described in #2131\n    params.showClass = Object.assign({}, defaultParams.showClass, params.showClass);\n    params.hideClass = Object.assign({}, defaultParams.hideClass, params.hideClass);\n    if (params.animation === false) {\n        params.showClass = {\n            backdrop: \"swal2-noanimation\"\n        };\n        params.hideClass = {};\n    }\n    return params;\n};\n/**\n * @param {SweetAlert} instance\n * @returns {DomCache}\n */ const populateDomCache = (instance)=>{\n    const domCache = {\n        popup: getPopup(),\n        container: getContainer(),\n        actions: getActions(),\n        confirmButton: getConfirmButton(),\n        denyButton: getDenyButton(),\n        cancelButton: getCancelButton(),\n        loader: getLoader(),\n        closeButton: getCloseButton(),\n        validationMessage: getValidationMessage(),\n        progressSteps: getProgressSteps()\n    };\n    privateProps.domCache.set(instance, domCache);\n    return domCache;\n};\n/**\n * @param {GlobalState} globalState\n * @param {SweetAlertOptions} innerParams\n * @param {Function} dismissWith\n */ const setupTimer = (globalState, innerParams, dismissWith)=>{\n    const timerProgressBar = getTimerProgressBar();\n    hide(timerProgressBar);\n    if (innerParams.timer) {\n        globalState.timeout = new Timer(()=>{\n            dismissWith(\"timer\");\n            delete globalState.timeout;\n        }, innerParams.timer);\n        if (innerParams.timerProgressBar) {\n            show(timerProgressBar);\n            applyCustomClass(timerProgressBar, innerParams, \"timerProgressBar\");\n            setTimeout(()=>{\n                if (globalState.timeout && globalState.timeout.running) {\n                    // timer can be already stopped or unset at this point\n                    animateTimerProgressBar(innerParams.timer);\n                }\n            });\n        }\n    }\n};\n/**\n * Initialize focus in the popup:\n *\n * 1. If `toast` is `true`, don't steal focus from the document.\n * 2. Else if there is an [autofocus] element, focus it.\n * 3. Else if `focusConfirm` is `true` and confirm button is visible, focus it.\n * 4. Else if `focusDeny` is `true` and deny button is visible, focus it.\n * 5. Else if `focusCancel` is `true` and cancel button is visible, focus it.\n * 6. Else focus the first focusable element in a popup (if any).\n *\n * @param {DomCache} domCache\n * @param {SweetAlertOptions} innerParams\n */ const initFocus = (domCache, innerParams)=>{\n    if (innerParams.toast) {\n        return;\n    }\n    // TODO: this is dumb, remove `allowEnterKey` param in the next major version\n    if (!callIfFunction(innerParams.allowEnterKey)) {\n        warnAboutDeprecation(\"allowEnterKey\");\n        blurActiveElement();\n        return;\n    }\n    if (focusAutofocus(domCache)) {\n        return;\n    }\n    if (focusButton(domCache, innerParams)) {\n        return;\n    }\n    setFocus(-1, 1);\n};\n/**\n * @param {DomCache} domCache\n * @returns {boolean}\n */ const focusAutofocus = (domCache)=>{\n    const autofocusElements = domCache.popup.querySelectorAll(\"[autofocus]\");\n    for (const autofocusElement of autofocusElements){\n        if (autofocusElement instanceof HTMLElement && isVisible$1(autofocusElement)) {\n            autofocusElement.focus();\n            return true;\n        }\n    }\n    return false;\n};\n/**\n * @param {DomCache} domCache\n * @param {SweetAlertOptions} innerParams\n * @returns {boolean}\n */ const focusButton = (domCache, innerParams)=>{\n    if (innerParams.focusDeny && isVisible$1(domCache.denyButton)) {\n        domCache.denyButton.focus();\n        return true;\n    }\n    if (innerParams.focusCancel && isVisible$1(domCache.cancelButton)) {\n        domCache.cancelButton.focus();\n        return true;\n    }\n    if (innerParams.focusConfirm && isVisible$1(domCache.confirmButton)) {\n        domCache.confirmButton.focus();\n        return true;\n    }\n    return false;\n};\nconst blurActiveElement = ()=>{\n    if (document.activeElement instanceof HTMLElement && typeof document.activeElement.blur === \"function\") {\n        document.activeElement.blur();\n    }\n};\n// Dear russian users visiting russian sites. Let's have fun.\nif (false) {}\n// Assign instance methods from src/instanceMethods/*.js to prototype\nSweetAlert.prototype.disableButtons = disableButtons;\nSweetAlert.prototype.enableButtons = enableButtons;\nSweetAlert.prototype.getInput = getInput;\nSweetAlert.prototype.disableInput = disableInput;\nSweetAlert.prototype.enableInput = enableInput;\nSweetAlert.prototype.hideLoading = hideLoading;\nSweetAlert.prototype.disableLoading = hideLoading;\nSweetAlert.prototype.showValidationMessage = showValidationMessage;\nSweetAlert.prototype.resetValidationMessage = resetValidationMessage;\nSweetAlert.prototype.close = close;\nSweetAlert.prototype.closePopup = close;\nSweetAlert.prototype.closeModal = close;\nSweetAlert.prototype.closeToast = close;\nSweetAlert.prototype.rejectPromise = rejectPromise;\nSweetAlert.prototype.update = update;\nSweetAlert.prototype._destroy = _destroy;\n// Assign static methods from src/staticMethods/*.js to constructor\nObject.assign(SweetAlert, staticMethods);\n// Proxy to instance methods to constructor, for now, for backwards compatibility\nObject.keys(instanceMethods).forEach((key)=>{\n    /**\n   * @param {...any} args\n   * @returns {any | undefined}\n   */ SweetAlert[key] = function() {\n        if (currentInstance && currentInstance[key]) {\n            return currentInstance[key](...arguments);\n        }\n        return null;\n    };\n});\nSweetAlert.DismissReason = DismissReason;\nSweetAlert.version = \"11.14.0\";\nconst Swal = SweetAlert;\n// @ts-ignore\nSwal.default = Swal;\n\n\"undefined\" != typeof document && function(e, t) {\n    var n = e.createElement(\"style\");\n    if (e.getElementsByTagName(\"head\")[0].appendChild(n), n.styleSheet) n.styleSheet.disabled || (n.styleSheet.cssText = t);\n    else try {\n        n.innerHTML = t;\n    } catch (e) {\n        n.innerText = t;\n    }\n}(document, '.swal2-popup.swal2-toast{box-sizing:border-box;grid-column:1/4 !important;grid-row:1/4 !important;grid-template-columns:min-content auto min-content;padding:1em;overflow-y:hidden;background:#fff;box-shadow:0 0 1px rgba(0,0,0,.075),0 1px 2px rgba(0,0,0,.075),1px 2px 4px rgba(0,0,0,.075),1px 3px 8px rgba(0,0,0,.075),2px 4px 16px rgba(0,0,0,.075);pointer-events:all}.swal2-popup.swal2-toast>*{grid-column:2}.swal2-popup.swal2-toast .swal2-title{margin:.5em 1em;padding:0;font-size:1em;text-align:initial}.swal2-popup.swal2-toast .swal2-loading{justify-content:center}.swal2-popup.swal2-toast .swal2-input{height:2em;margin:.5em;font-size:1em}.swal2-popup.swal2-toast .swal2-validation-message{font-size:1em}.swal2-popup.swal2-toast .swal2-footer{margin:.5em 0 0;padding:.5em 0 0;font-size:.8em}.swal2-popup.swal2-toast .swal2-close{grid-column:3/3;grid-row:1/99;align-self:center;width:.8em;height:.8em;margin:0;font-size:2em}.swal2-popup.swal2-toast .swal2-html-container{margin:.5em 1em;padding:0;overflow:initial;font-size:1em;text-align:initial}.swal2-popup.swal2-toast .swal2-html-container:empty{padding:0}.swal2-popup.swal2-toast .swal2-loader{grid-column:1;grid-row:1/99;align-self:center;width:2em;height:2em;margin:.25em}.swal2-popup.swal2-toast .swal2-icon{grid-column:1;grid-row:1/99;align-self:center;width:2em;min-width:2em;height:2em;margin:0 .5em 0 0}.swal2-popup.swal2-toast .swal2-icon .swal2-icon-content{display:flex;align-items:center;font-size:1.8em;font-weight:bold}.swal2-popup.swal2-toast .swal2-icon.swal2-success .swal2-success-ring{width:2em;height:2em}.swal2-popup.swal2-toast .swal2-icon.swal2-error [class^=swal2-x-mark-line]{top:.875em;width:1.375em}.swal2-popup.swal2-toast .swal2-icon.swal2-error [class^=swal2-x-mark-line][class$=left]{left:.3125em}.swal2-popup.swal2-toast .swal2-icon.swal2-error [class^=swal2-x-mark-line][class$=right]{right:.3125em}.swal2-popup.swal2-toast .swal2-actions{justify-content:flex-start;height:auto;margin:0;margin-top:.5em;padding:0 .5em}.swal2-popup.swal2-toast .swal2-styled{margin:.25em .5em;padding:.4em .6em;font-size:1em}.swal2-popup.swal2-toast .swal2-success{border-color:#a5dc86}.swal2-popup.swal2-toast .swal2-success [class^=swal2-success-circular-line]{position:absolute;width:1.6em;height:3em;border-radius:50%}.swal2-popup.swal2-toast .swal2-success [class^=swal2-success-circular-line][class$=left]{top:-0.8em;left:-0.5em;transform:rotate(-45deg);transform-origin:2em 2em;border-radius:4em 0 0 4em}.swal2-popup.swal2-toast .swal2-success [class^=swal2-success-circular-line][class$=right]{top:-0.25em;left:.9375em;transform-origin:0 1.5em;border-radius:0 4em 4em 0}.swal2-popup.swal2-toast .swal2-success .swal2-success-ring{width:2em;height:2em}.swal2-popup.swal2-toast .swal2-success .swal2-success-fix{top:0;left:.4375em;width:.4375em;height:2.6875em}.swal2-popup.swal2-toast .swal2-success [class^=swal2-success-line]{height:.3125em}.swal2-popup.swal2-toast .swal2-success [class^=swal2-success-line][class$=tip]{top:1.125em;left:.1875em;width:.75em}.swal2-popup.swal2-toast .swal2-success [class^=swal2-success-line][class$=long]{top:.9375em;right:.1875em;width:1.375em}.swal2-popup.swal2-toast .swal2-success.swal2-icon-show .swal2-success-line-tip{animation:swal2-toast-animate-success-line-tip .75s}.swal2-popup.swal2-toast .swal2-success.swal2-icon-show .swal2-success-line-long{animation:swal2-toast-animate-success-line-long .75s}.swal2-popup.swal2-toast.swal2-show{animation:swal2-toast-show .5s}.swal2-popup.swal2-toast.swal2-hide{animation:swal2-toast-hide .1s forwards}div:where(.swal2-container){display:grid;position:fixed;z-index:1060;inset:0;box-sizing:border-box;grid-template-areas:\"top-start     top            top-end\" \"center-start  center         center-end\" \"bottom-start  bottom-center  bottom-end\";grid-template-rows:minmax(min-content, auto) minmax(min-content, auto) minmax(min-content, auto);height:100%;padding:.625em;overflow-x:hidden;transition:background-color .1s;-webkit-overflow-scrolling:touch}div:where(.swal2-container).swal2-backdrop-show,div:where(.swal2-container).swal2-noanimation{background:rgba(0,0,0,.4)}div:where(.swal2-container).swal2-backdrop-hide{background:rgba(0,0,0,0) !important}div:where(.swal2-container).swal2-top-start,div:where(.swal2-container).swal2-center-start,div:where(.swal2-container).swal2-bottom-start{grid-template-columns:minmax(0, 1fr) auto auto}div:where(.swal2-container).swal2-top,div:where(.swal2-container).swal2-center,div:where(.swal2-container).swal2-bottom{grid-template-columns:auto minmax(0, 1fr) auto}div:where(.swal2-container).swal2-top-end,div:where(.swal2-container).swal2-center-end,div:where(.swal2-container).swal2-bottom-end{grid-template-columns:auto auto minmax(0, 1fr)}div:where(.swal2-container).swal2-top-start>.swal2-popup{align-self:start}div:where(.swal2-container).swal2-top>.swal2-popup{grid-column:2;place-self:start center}div:where(.swal2-container).swal2-top-end>.swal2-popup,div:where(.swal2-container).swal2-top-right>.swal2-popup{grid-column:3;place-self:start end}div:where(.swal2-container).swal2-center-start>.swal2-popup,div:where(.swal2-container).swal2-center-left>.swal2-popup{grid-row:2;align-self:center}div:where(.swal2-container).swal2-center>.swal2-popup{grid-column:2;grid-row:2;place-self:center center}div:where(.swal2-container).swal2-center-end>.swal2-popup,div:where(.swal2-container).swal2-center-right>.swal2-popup{grid-column:3;grid-row:2;place-self:center end}div:where(.swal2-container).swal2-bottom-start>.swal2-popup,div:where(.swal2-container).swal2-bottom-left>.swal2-popup{grid-column:1;grid-row:3;align-self:end}div:where(.swal2-container).swal2-bottom>.swal2-popup{grid-column:2;grid-row:3;place-self:end center}div:where(.swal2-container).swal2-bottom-end>.swal2-popup,div:where(.swal2-container).swal2-bottom-right>.swal2-popup{grid-column:3;grid-row:3;place-self:end end}div:where(.swal2-container).swal2-grow-row>.swal2-popup,div:where(.swal2-container).swal2-grow-fullscreen>.swal2-popup{grid-column:1/4;width:100%}div:where(.swal2-container).swal2-grow-column>.swal2-popup,div:where(.swal2-container).swal2-grow-fullscreen>.swal2-popup{grid-row:1/4;align-self:stretch}div:where(.swal2-container).swal2-no-transition{transition:none !important}div:where(.swal2-container) div:where(.swal2-popup){display:none;position:relative;box-sizing:border-box;grid-template-columns:minmax(0, 100%);width:32em;max-width:100%;padding:0 0 1.25em;border:none;border-radius:5px;background:#fff;color:#545454;font-family:inherit;font-size:1rem}div:where(.swal2-container) div:where(.swal2-popup):focus{outline:none}div:where(.swal2-container) div:where(.swal2-popup).swal2-loading{overflow-y:hidden}div:where(.swal2-container) h2:where(.swal2-title){position:relative;max-width:100%;margin:0;padding:.8em 1em 0;color:inherit;font-size:1.875em;font-weight:600;text-align:center;text-transform:none;word-wrap:break-word}div:where(.swal2-container) div:where(.swal2-actions){display:flex;z-index:1;box-sizing:border-box;flex-wrap:wrap;align-items:center;justify-content:center;width:auto;margin:1.25em auto 0;padding:0}div:where(.swal2-container) div:where(.swal2-actions):not(.swal2-loading) .swal2-styled[disabled]{opacity:.4}div:where(.swal2-container) div:where(.swal2-actions):not(.swal2-loading) .swal2-styled:hover{background-image:linear-gradient(rgba(0, 0, 0, 0.1), rgba(0, 0, 0, 0.1))}div:where(.swal2-container) div:where(.swal2-actions):not(.swal2-loading) .swal2-styled:active{background-image:linear-gradient(rgba(0, 0, 0, 0.2), rgba(0, 0, 0, 0.2))}div:where(.swal2-container) div:where(.swal2-loader){display:none;align-items:center;justify-content:center;width:2.2em;height:2.2em;margin:0 1.875em;animation:swal2-rotate-loading 1.5s linear 0s infinite normal;border-width:.25em;border-style:solid;border-radius:100%;border-color:#2778c4 rgba(0,0,0,0) #2778c4 rgba(0,0,0,0)}div:where(.swal2-container) button:where(.swal2-styled){margin:.3125em;padding:.625em 1.1em;transition:box-shadow .1s;box-shadow:0 0 0 3px rgba(0,0,0,0);font-weight:500}div:where(.swal2-container) button:where(.swal2-styled):not([disabled]){cursor:pointer}div:where(.swal2-container) button:where(.swal2-styled):where(.swal2-confirm){border:0;border-radius:.25em;background:initial;background-color:#7066e0;color:#fff;font-size:1em}div:where(.swal2-container) button:where(.swal2-styled):where(.swal2-confirm):focus-visible{box-shadow:0 0 0 3px rgba(112,102,224,.5)}div:where(.swal2-container) button:where(.swal2-styled):where(.swal2-deny){border:0;border-radius:.25em;background:initial;background-color:#dc3741;color:#fff;font-size:1em}div:where(.swal2-container) button:where(.swal2-styled):where(.swal2-deny):focus-visible{box-shadow:0 0 0 3px rgba(220,55,65,.5)}div:where(.swal2-container) button:where(.swal2-styled):where(.swal2-cancel){border:0;border-radius:.25em;background:initial;background-color:#6e7881;color:#fff;font-size:1em}div:where(.swal2-container) button:where(.swal2-styled):where(.swal2-cancel):focus-visible{box-shadow:0 0 0 3px rgba(110,120,129,.5)}div:where(.swal2-container) button:where(.swal2-styled).swal2-default-outline:focus-visible{box-shadow:0 0 0 3px rgba(100,150,200,.5)}div:where(.swal2-container) button:where(.swal2-styled):focus-visible{outline:none}div:where(.swal2-container) button:where(.swal2-styled)::-moz-focus-inner{border:0}div:where(.swal2-container) div:where(.swal2-footer){margin:1em 0 0;padding:1em 1em 0;border-top:1px solid #eee;color:inherit;font-size:1em;text-align:center}div:where(.swal2-container) .swal2-timer-progress-bar-container{position:absolute;right:0;bottom:0;left:0;grid-column:auto !important;overflow:hidden;border-bottom-right-radius:5px;border-bottom-left-radius:5px}div:where(.swal2-container) div:where(.swal2-timer-progress-bar){width:100%;height:.25em;background:rgba(0,0,0,.2)}div:where(.swal2-container) img:where(.swal2-image){max-width:100%;margin:2em auto 1em}div:where(.swal2-container) button:where(.swal2-close){z-index:2;align-items:center;justify-content:center;width:1.2em;height:1.2em;margin-top:0;margin-right:0;margin-bottom:-1.2em;padding:0;overflow:hidden;transition:color .1s,box-shadow .1s;border:none;border-radius:5px;background:rgba(0,0,0,0);color:#ccc;font-family:monospace;font-size:2.5em;cursor:pointer;justify-self:end}div:where(.swal2-container) button:where(.swal2-close):hover{transform:none;background:rgba(0,0,0,0);color:#f27474}div:where(.swal2-container) button:where(.swal2-close):focus-visible{outline:none;box-shadow:inset 0 0 0 3px rgba(100,150,200,.5)}div:where(.swal2-container) button:where(.swal2-close)::-moz-focus-inner{border:0}div:where(.swal2-container) .swal2-html-container{z-index:1;justify-content:center;margin:0;padding:1em 1.6em .3em;overflow:auto;color:inherit;font-size:1.125em;font-weight:normal;line-height:normal;text-align:center;word-wrap:break-word;word-break:break-word}div:where(.swal2-container) input:where(.swal2-input),div:where(.swal2-container) input:where(.swal2-file),div:where(.swal2-container) textarea:where(.swal2-textarea),div:where(.swal2-container) select:where(.swal2-select),div:where(.swal2-container) div:where(.swal2-radio),div:where(.swal2-container) label:where(.swal2-checkbox){margin:1em 2em 3px}div:where(.swal2-container) input:where(.swal2-input),div:where(.swal2-container) input:where(.swal2-file),div:where(.swal2-container) textarea:where(.swal2-textarea){box-sizing:border-box;width:auto;transition:border-color .1s,box-shadow .1s;border:1px solid #d9d9d9;border-radius:.1875em;background:rgba(0,0,0,0);box-shadow:inset 0 1px 1px rgba(0,0,0,.06),0 0 0 3px rgba(0,0,0,0);color:inherit;font-size:1.125em}div:where(.swal2-container) input:where(.swal2-input).swal2-inputerror,div:where(.swal2-container) input:where(.swal2-file).swal2-inputerror,div:where(.swal2-container) textarea:where(.swal2-textarea).swal2-inputerror{border-color:#f27474 !important;box-shadow:0 0 2px #f27474 !important}div:where(.swal2-container) input:where(.swal2-input):focus,div:where(.swal2-container) input:where(.swal2-file):focus,div:where(.swal2-container) textarea:where(.swal2-textarea):focus{border:1px solid #b4dbed;outline:none;box-shadow:inset 0 1px 1px rgba(0,0,0,.06),0 0 0 3px rgba(100,150,200,.5)}div:where(.swal2-container) input:where(.swal2-input)::placeholder,div:where(.swal2-container) input:where(.swal2-file)::placeholder,div:where(.swal2-container) textarea:where(.swal2-textarea)::placeholder{color:#ccc}div:where(.swal2-container) .swal2-range{margin:1em 2em 3px;background:#fff}div:where(.swal2-container) .swal2-range input{width:80%}div:where(.swal2-container) .swal2-range output{width:20%;color:inherit;font-weight:600;text-align:center}div:where(.swal2-container) .swal2-range input,div:where(.swal2-container) .swal2-range output{height:2.625em;padding:0;font-size:1.125em;line-height:2.625em}div:where(.swal2-container) .swal2-input{height:2.625em;padding:0 .75em}div:where(.swal2-container) .swal2-file{width:75%;margin-right:auto;margin-left:auto;background:rgba(0,0,0,0);font-size:1.125em}div:where(.swal2-container) .swal2-textarea{height:6.75em;padding:.75em}div:where(.swal2-container) .swal2-select{min-width:50%;max-width:100%;padding:.375em .625em;background:rgba(0,0,0,0);color:inherit;font-size:1.125em}div:where(.swal2-container) .swal2-radio,div:where(.swal2-container) .swal2-checkbox{align-items:center;justify-content:center;background:#fff;color:inherit}div:where(.swal2-container) .swal2-radio label,div:where(.swal2-container) .swal2-checkbox label{margin:0 .6em;font-size:1.125em}div:where(.swal2-container) .swal2-radio input,div:where(.swal2-container) .swal2-checkbox input{flex-shrink:0;margin:0 .4em}div:where(.swal2-container) label:where(.swal2-input-label){display:flex;justify-content:center;margin:1em auto 0}div:where(.swal2-container) div:where(.swal2-validation-message){align-items:center;justify-content:center;margin:1em 0 0;padding:.625em;overflow:hidden;background:#f0f0f0;color:#666;font-size:1em;font-weight:300}div:where(.swal2-container) div:where(.swal2-validation-message)::before{content:\"!\";display:inline-block;width:1.5em;min-width:1.5em;height:1.5em;margin:0 .625em;border-radius:50%;background-color:#f27474;color:#fff;font-weight:600;line-height:1.5em;text-align:center}div:where(.swal2-container) .swal2-progress-steps{flex-wrap:wrap;align-items:center;max-width:100%;margin:1.25em auto;padding:0;background:rgba(0,0,0,0);font-weight:600}div:where(.swal2-container) .swal2-progress-steps li{display:inline-block;position:relative}div:where(.swal2-container) .swal2-progress-steps .swal2-progress-step{z-index:20;flex-shrink:0;width:2em;height:2em;border-radius:2em;background:#2778c4;color:#fff;line-height:2em;text-align:center}div:where(.swal2-container) .swal2-progress-steps .swal2-progress-step.swal2-active-progress-step{background:#2778c4}div:where(.swal2-container) .swal2-progress-steps .swal2-progress-step.swal2-active-progress-step~.swal2-progress-step{background:#add8e6;color:#fff}div:where(.swal2-container) .swal2-progress-steps .swal2-progress-step.swal2-active-progress-step~.swal2-progress-step-line{background:#add8e6}div:where(.swal2-container) .swal2-progress-steps .swal2-progress-step-line{z-index:10;flex-shrink:0;width:2.5em;height:.4em;margin:0 -1px;background:#2778c4}div:where(.swal2-icon){position:relative;box-sizing:content-box;justify-content:center;width:5em;height:5em;margin:2.5em auto .6em;border:0.25em solid rgba(0,0,0,0);border-radius:50%;border-color:#000;font-family:inherit;line-height:5em;cursor:default;user-select:none}div:where(.swal2-icon) .swal2-icon-content{display:flex;align-items:center;font-size:3.75em}div:where(.swal2-icon).swal2-error{border-color:#f27474;color:#f27474}div:where(.swal2-icon).swal2-error .swal2-x-mark{position:relative;flex-grow:1}div:where(.swal2-icon).swal2-error [class^=swal2-x-mark-line]{display:block;position:absolute;top:2.3125em;width:2.9375em;height:.3125em;border-radius:.125em;background-color:#f27474}div:where(.swal2-icon).swal2-error [class^=swal2-x-mark-line][class$=left]{left:1.0625em;transform:rotate(45deg)}div:where(.swal2-icon).swal2-error [class^=swal2-x-mark-line][class$=right]{right:1em;transform:rotate(-45deg)}div:where(.swal2-icon).swal2-error.swal2-icon-show{animation:swal2-animate-error-icon .5s}div:where(.swal2-icon).swal2-error.swal2-icon-show .swal2-x-mark{animation:swal2-animate-error-x-mark .5s}div:where(.swal2-icon).swal2-warning{border-color:#facea8;color:#f8bb86}div:where(.swal2-icon).swal2-warning.swal2-icon-show{animation:swal2-animate-error-icon .5s}div:where(.swal2-icon).swal2-warning.swal2-icon-show .swal2-icon-content{animation:swal2-animate-i-mark .5s}div:where(.swal2-icon).swal2-info{border-color:#9de0f6;color:#3fc3ee}div:where(.swal2-icon).swal2-info.swal2-icon-show{animation:swal2-animate-error-icon .5s}div:where(.swal2-icon).swal2-info.swal2-icon-show .swal2-icon-content{animation:swal2-animate-i-mark .8s}div:where(.swal2-icon).swal2-question{border-color:#c9dae1;color:#87adbd}div:where(.swal2-icon).swal2-question.swal2-icon-show{animation:swal2-animate-error-icon .5s}div:where(.swal2-icon).swal2-question.swal2-icon-show .swal2-icon-content{animation:swal2-animate-question-mark .8s}div:where(.swal2-icon).swal2-success{border-color:#a5dc86;color:#a5dc86}div:where(.swal2-icon).swal2-success [class^=swal2-success-circular-line]{position:absolute;width:3.75em;height:7.5em;border-radius:50%}div:where(.swal2-icon).swal2-success [class^=swal2-success-circular-line][class$=left]{top:-0.4375em;left:-2.0635em;transform:rotate(-45deg);transform-origin:3.75em 3.75em;border-radius:7.5em 0 0 7.5em}div:where(.swal2-icon).swal2-success [class^=swal2-success-circular-line][class$=right]{top:-0.6875em;left:1.875em;transform:rotate(-45deg);transform-origin:0 3.75em;border-radius:0 7.5em 7.5em 0}div:where(.swal2-icon).swal2-success .swal2-success-ring{position:absolute;z-index:2;top:-0.25em;left:-0.25em;box-sizing:content-box;width:100%;height:100%;border:.25em solid rgba(165,220,134,.3);border-radius:50%}div:where(.swal2-icon).swal2-success .swal2-success-fix{position:absolute;z-index:1;top:.5em;left:1.625em;width:.4375em;height:5.625em;transform:rotate(-45deg)}div:where(.swal2-icon).swal2-success [class^=swal2-success-line]{display:block;position:absolute;z-index:2;height:.3125em;border-radius:.125em;background-color:#a5dc86}div:where(.swal2-icon).swal2-success [class^=swal2-success-line][class$=tip]{top:2.875em;left:.8125em;width:1.5625em;transform:rotate(45deg)}div:where(.swal2-icon).swal2-success [class^=swal2-success-line][class$=long]{top:2.375em;right:.5em;width:2.9375em;transform:rotate(-45deg)}div:where(.swal2-icon).swal2-success.swal2-icon-show .swal2-success-line-tip{animation:swal2-animate-success-line-tip .75s}div:where(.swal2-icon).swal2-success.swal2-icon-show .swal2-success-line-long{animation:swal2-animate-success-line-long .75s}div:where(.swal2-icon).swal2-success.swal2-icon-show .swal2-success-circular-line-right{animation:swal2-rotate-success-circular-line 4.25s ease-in}[class^=swal2]{-webkit-tap-highlight-color:rgba(0,0,0,0)}.swal2-show{animation:swal2-show .3s}.swal2-hide{animation:swal2-hide .15s forwards}.swal2-noanimation{transition:none}.swal2-scrollbar-measure{position:absolute;top:-9999px;width:50px;height:50px;overflow:scroll}.swal2-rtl .swal2-close{margin-right:initial;margin-left:0}.swal2-rtl .swal2-timer-progress-bar{right:0;left:auto}@keyframes swal2-toast-show{0%{transform:translateY(-0.625em) rotateZ(2deg)}33%{transform:translateY(0) rotateZ(-2deg)}66%{transform:translateY(0.3125em) rotateZ(2deg)}100%{transform:translateY(0) rotateZ(0deg)}}@keyframes swal2-toast-hide{100%{transform:rotateZ(1deg);opacity:0}}@keyframes swal2-toast-animate-success-line-tip{0%{top:.5625em;left:.0625em;width:0}54%{top:.125em;left:.125em;width:0}70%{top:.625em;left:-0.25em;width:1.625em}84%{top:1.0625em;left:.75em;width:.5em}100%{top:1.125em;left:.1875em;width:.75em}}@keyframes swal2-toast-animate-success-line-long{0%{top:1.625em;right:1.375em;width:0}65%{top:1.25em;right:.9375em;width:0}84%{top:.9375em;right:0;width:1.125em}100%{top:.9375em;right:.1875em;width:1.375em}}@keyframes swal2-show{0%{transform:scale(0.7)}45%{transform:scale(1.05)}80%{transform:scale(0.95)}100%{transform:scale(1)}}@keyframes swal2-hide{0%{transform:scale(1);opacity:1}100%{transform:scale(0.5);opacity:0}}@keyframes swal2-animate-success-line-tip{0%{top:1.1875em;left:.0625em;width:0}54%{top:1.0625em;left:.125em;width:0}70%{top:2.1875em;left:-0.375em;width:3.125em}84%{top:3em;left:1.3125em;width:1.0625em}100%{top:2.8125em;left:.8125em;width:1.5625em}}@keyframes swal2-animate-success-line-long{0%{top:3.375em;right:2.875em;width:0}65%{top:3.375em;right:2.875em;width:0}84%{top:2.1875em;right:0;width:3.4375em}100%{top:2.375em;right:.5em;width:2.9375em}}@keyframes swal2-rotate-success-circular-line{0%{transform:rotate(-45deg)}5%{transform:rotate(-45deg)}12%{transform:rotate(-405deg)}100%{transform:rotate(-405deg)}}@keyframes swal2-animate-error-x-mark{0%{margin-top:1.625em;transform:scale(0.4);opacity:0}50%{margin-top:1.625em;transform:scale(0.4);opacity:0}80%{margin-top:-0.375em;transform:scale(1.15)}100%{margin-top:0;transform:scale(1);opacity:1}}@keyframes swal2-animate-error-icon{0%{transform:rotateX(100deg);opacity:0}100%{transform:rotateX(0deg);opacity:1}}@keyframes swal2-rotate-loading{0%{transform:rotate(0deg)}100%{transform:rotate(360deg)}}@keyframes swal2-animate-question-mark{0%{transform:rotateY(-360deg)}100%{transform:rotateY(0)}}@keyframes swal2-animate-i-mark{0%{transform:rotateZ(45deg);opacity:0}25%{transform:rotateZ(-25deg);opacity:.4}50%{transform:rotateZ(15deg);opacity:.8}75%{transform:rotateZ(-5deg);opacity:1}100%{transform:rotateX(0);opacity:1}}body.swal2-shown:not(.swal2-no-backdrop):not(.swal2-toast-shown){overflow:hidden}body.swal2-height-auto{height:auto !important}body.swal2-no-backdrop .swal2-container{background-color:rgba(0,0,0,0) !important;pointer-events:none}body.swal2-no-backdrop .swal2-container .swal2-popup{pointer-events:all}body.swal2-no-backdrop .swal2-container .swal2-modal{box-shadow:0 0 10px rgba(0,0,0,.4)}@media print{body.swal2-shown:not(.swal2-no-backdrop):not(.swal2-toast-shown){overflow-y:scroll !important}body.swal2-shown:not(.swal2-no-backdrop):not(.swal2-toast-shown)>[aria-hidden=true]{display:none}body.swal2-shown:not(.swal2-no-backdrop):not(.swal2-toast-shown) .swal2-container{position:static !important}}body.swal2-toast-shown .swal2-container{box-sizing:border-box;width:360px;max-width:100%;background-color:rgba(0,0,0,0);pointer-events:none}body.swal2-toast-shown .swal2-container.swal2-top{inset:0 auto auto 50%;transform:translateX(-50%)}body.swal2-toast-shown .swal2-container.swal2-top-end,body.swal2-toast-shown .swal2-container.swal2-top-right{inset:0 0 auto auto}body.swal2-toast-shown .swal2-container.swal2-top-start,body.swal2-toast-shown .swal2-container.swal2-top-left{inset:0 auto auto 0}body.swal2-toast-shown .swal2-container.swal2-center-start,body.swal2-toast-shown .swal2-container.swal2-center-left{inset:50% auto auto 0;transform:translateY(-50%)}body.swal2-toast-shown .swal2-container.swal2-center{inset:50% auto auto 50%;transform:translate(-50%, -50%)}body.swal2-toast-shown .swal2-container.swal2-center-end,body.swal2-toast-shown .swal2-container.swal2-center-right{inset:50% 0 auto auto;transform:translateY(-50%)}body.swal2-toast-shown .swal2-container.swal2-bottom-start,body.swal2-toast-shown .swal2-container.swal2-bottom-left{inset:auto auto 0 0}body.swal2-toast-shown .swal2-container.swal2-bottom{inset:auto auto 0 50%;transform:translateX(-50%)}body.swal2-toast-shown .swal2-container.swal2-bottom-end,body.swal2-toast-shown .swal2-container.swal2-bottom-right{inset:auto 0 0 auto}');\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc3dlZXRhbGVydDIvZGlzdC9zd2VldGFsZXJ0Mi5lc20uYWxsLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTs7O0FBR0EsR0FDQSxTQUFTQSxrQkFBa0JDLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxDQUFDO0lBQ2hDLElBQUksY0FBYyxPQUFPRixJQUFJQSxNQUFNQyxJQUFJRCxFQUFFRyxHQUFHLENBQUNGLElBQUksT0FBT0csVUFBVUMsTUFBTSxHQUFHLElBQUlKLElBQUlDO0lBQ25GLE1BQU0sSUFBSUksVUFBVTtBQUN0QjtBQUNBLFNBQVNDLDJCQUEyQlAsQ0FBQyxFQUFFQyxDQUFDO0lBQ3RDLElBQUlBLEVBQUVFLEdBQUcsQ0FBQ0gsSUFBSSxNQUFNLElBQUlNLFVBQVU7QUFDcEM7QUFDQSxTQUFTRSx1QkFBdUJDLENBQUMsRUFBRUMsQ0FBQztJQUNsQyxPQUFPRCxFQUFFRSxHQUFHLENBQUNaLGtCQUFrQlUsR0FBR0M7QUFDcEM7QUFDQSxTQUFTRSwyQkFBMkJaLENBQUMsRUFBRUMsQ0FBQyxFQUFFUyxDQUFDO0lBQ3pDSCwyQkFBMkJQLEdBQUdDLElBQUlBLEVBQUVZLEdBQUcsQ0FBQ2IsR0FBR1U7QUFDN0M7QUFDQSxTQUFTSSx1QkFBdUJMLENBQUMsRUFBRUMsQ0FBQyxFQUFFSyxDQUFDO0lBQ3JDLE9BQU9OLEVBQUVJLEdBQUcsQ0FBQ2Qsa0JBQWtCVSxHQUFHQyxJQUFJSyxJQUFJQTtBQUM1QztBQUVBLE1BQU1DLHdCQUF3QjtBQUU5Qix3QkFBd0IsR0FDeEIsTUFBTUMsY0FBYyxDQUFDO0FBQ3JCLE1BQU1DLDZCQUE2QjtJQUNqQyxJQUFJRCxZQUFZRSxxQkFBcUIsWUFBWUMsYUFBYTtRQUM1REgsWUFBWUUscUJBQXFCLENBQUNFLEtBQUs7UUFDdkNKLFlBQVlFLHFCQUFxQixHQUFHO0lBQ3RDLE9BQU8sSUFBSUcsU0FBU0MsSUFBSSxFQUFFO1FBQ3hCRCxTQUFTQyxJQUFJLENBQUNGLEtBQUs7SUFDckI7QUFDRjtBQUVBOzs7OztDQUtDLEdBQ0QsTUFBTUcsdUJBQXVCQyxDQUFBQTtJQUMzQixPQUFPLElBQUlDLFFBQVFDLENBQUFBO1FBQ2pCLElBQUksQ0FBQ0YsYUFBYTtZQUNoQixPQUFPRTtRQUNUO1FBQ0EsTUFBTUMsSUFBSUMsT0FBT0MsT0FBTztRQUN4QixNQUFNQyxJQUFJRixPQUFPRyxPQUFPO1FBQ3hCZixZQUFZZ0IsbUJBQW1CLEdBQUdDLFdBQVc7WUFDM0NoQjtZQUNBUztRQUNGLEdBQUdYLHdCQUF3QixhQUFhO1FBRXhDYSxPQUFPTSxRQUFRLENBQUNQLEdBQUdHO0lBQ3JCO0FBQ0Y7QUFFQSxNQUFNSyxhQUFhO0FBRW5COztDQUVDLEdBRUQ7OztDQUdDLEdBRUQsd0JBQXdCLEdBQ3hCLE1BQU1DLGFBQWE7SUFBQztJQUFhO0lBQVM7SUFBZTtJQUFVO0lBQVM7SUFBUztJQUFlO0lBQWlCO0lBQVM7SUFBZTtJQUFRO0lBQVE7SUFBUztJQUFTO0lBQWtCO0lBQVc7SUFBVztJQUFRO0lBQVU7SUFBbUI7SUFBVTtJQUFRO0lBQWdCO0lBQVM7SUFBUztJQUFRO0lBQVM7SUFBVTtJQUFTO0lBQVk7SUFBUztJQUFZO0lBQWM7SUFBZTtJQUFzQjtJQUFrQjtJQUF3QjtJQUFpQjtJQUFzQjtJQUFVO0lBQVc7SUFBVTtJQUFPO0lBQWE7SUFBVztJQUFZO0lBQWE7SUFBVTtJQUFnQjtJQUFjO0lBQWU7SUFBZ0I7SUFBVTtJQUFnQjtJQUFjO0lBQWU7SUFBZ0I7SUFBWTtJQUFlO0lBQW1CO0lBQU87SUFBc0I7SUFBZ0M7SUFBcUI7SUFBZ0I7SUFBZ0I7SUFBYTtJQUFpQjtDQUFhO0FBQ3o2QixNQUFNQyxjQUFjRCxXQUFXRSxNQUFNLENBQUMsQ0FBQ0MsS0FBS0M7SUFDMUNELEdBQUcsQ0FBQ0MsVUFBVSxHQUFHTCxhQUFhSztJQUM5QixPQUFPRDtBQUNULEdBQUcsd0JBQXdCLEdBQUUsQ0FBQztBQUU5Qix1QkFBdUIsR0FDdkIsTUFBTUUsUUFBUTtJQUFDO0lBQVc7SUFBVztJQUFRO0lBQVk7Q0FBUTtBQUNqRSxNQUFNQyxZQUFZRCxNQUFNSCxNQUFNLENBQUMsQ0FBQ0MsS0FBS0k7SUFDbkNKLEdBQUcsQ0FBQ0ksS0FBSyxHQUFHUixhQUFhUTtJQUN6QixPQUFPSjtBQUNULEdBQUcsc0JBQXNCLEdBQUUsQ0FBQztBQUU1QixNQUFNSyxnQkFBZ0I7QUFFdEI7Ozs7O0NBS0MsR0FDRCxNQUFNQyx3QkFBd0JDLENBQUFBLE1BQU9BLElBQUlDLE1BQU0sQ0FBQyxHQUFHQyxXQUFXLEtBQUtGLElBQUlHLEtBQUssQ0FBQztBQUU3RTs7OztDQUlDLEdBQ0QsTUFBTUMsT0FBT0MsQ0FBQUE7SUFDWEMsUUFBUUYsSUFBSSxDQUFDLENBQUMsRUFBRU4sY0FBYyxDQUFDLEVBQUUsT0FBT08sWUFBWSxXQUFXQSxRQUFRRSxJQUFJLENBQUMsT0FBT0YsUUFBUSxDQUFDO0FBQzlGO0FBRUE7Ozs7Q0FJQyxHQUNELE1BQU1HLFFBQVFILENBQUFBO0lBQ1pDLFFBQVFFLEtBQUssQ0FBQyxDQUFDLEVBQUVWLGNBQWMsQ0FBQyxFQUFFTyxRQUFRLENBQUM7QUFDN0M7QUFFQTs7Ozs7Q0FLQyxHQUNELE1BQU1JLDJCQUEyQixFQUFFO0FBRW5DOzs7O0NBSUMsR0FDRCxNQUFNQyxXQUFXTCxDQUFBQTtJQUNmLElBQUksQ0FBQ0kseUJBQXlCRSxRQUFRLENBQUNOLFVBQVU7UUFDL0NJLHlCQUF5QkcsSUFBSSxDQUFDUDtRQUM5QkQsS0FBS0M7SUFDUDtBQUNGO0FBRUE7Ozs7O0NBS0MsR0FDRCxNQUFNUSx1QkFBdUIsU0FBVUMsZUFBZTtJQUNwRCxJQUFJQyxhQUFhMUQsVUFBVUMsTUFBTSxHQUFHLEtBQUtELFNBQVMsQ0FBQyxFQUFFLEtBQUsyRCxZQUFZM0QsU0FBUyxDQUFDLEVBQUUsR0FBRztJQUNyRnFELFNBQVMsQ0FBQyxDQUFDLEVBQUVJLGdCQUFnQiw4REFBOEQsRUFBRUMsYUFBYSxDQUFDLE1BQU0sRUFBRUEsV0FBVyxVQUFVLENBQUMsR0FBRyxHQUFHLENBQUM7QUFDbEo7QUFFQTs7Ozs7O0NBTUMsR0FDRCxNQUFNRSxpQkFBaUJDLENBQUFBLE1BQU8sT0FBT0EsUUFBUSxhQUFhQSxRQUFRQTtBQUVsRTs7O0NBR0MsR0FDRCxNQUFNQyxpQkFBaUJELENBQUFBLE1BQU9BLE9BQU8sT0FBT0EsSUFBSUUsU0FBUyxLQUFLO0FBRTlEOzs7Q0FHQyxHQUNELE1BQU1DLFlBQVlILENBQUFBLE1BQU9DLGVBQWVELE9BQU9BLElBQUlFLFNBQVMsS0FBS3pDLFFBQVFDLE9BQU8sQ0FBQ3NDO0FBRWpGOzs7Q0FHQyxHQUNELE1BQU1JLFlBQVlKLENBQUFBLE1BQU9BLE9BQU92QyxRQUFRQyxPQUFPLENBQUNzQyxTQUFTQTtBQUV6RDs7OztDQUlDLEdBQ0QsTUFBTUssZUFBZSxJQUFNaEQsU0FBU0MsSUFBSSxDQUFDZ0QsYUFBYSxDQUFDLENBQUMsQ0FBQyxFQUFFakMsWUFBWWtDLFNBQVMsQ0FBQyxDQUFDO0FBRWxGOzs7Q0FHQyxHQUNELE1BQU1DLG9CQUFvQkMsQ0FBQUE7SUFDeEIsTUFBTUYsWUFBWUY7SUFDbEIsT0FBT0UsWUFBWUEsVUFBVUQsYUFBYSxDQUFDRyxrQkFBa0I7QUFDL0Q7QUFFQTs7O0NBR0MsR0FDRCxNQUFNQyxpQkFBaUJsQyxDQUFBQTtJQUNyQixPQUFPZ0Msa0JBQWtCLENBQUMsQ0FBQyxFQUFFaEMsVUFBVSxDQUFDO0FBQzFDO0FBRUE7O0NBRUMsR0FDRCxNQUFNbUMsV0FBVyxJQUFNRCxlQUFlckMsWUFBWXVDLEtBQUs7QUFFdkQ7O0NBRUMsR0FDRCxNQUFNQyxVQUFVLElBQU1ILGVBQWVyQyxZQUFZTSxJQUFJO0FBRXJEOztDQUVDLEdBQ0QsTUFBTW1DLGlCQUFpQixJQUFNSixlQUFlckMsV0FBVyxDQUFDLGVBQWU7QUFFdkU7O0NBRUMsR0FDRCxNQUFNMEMsV0FBVyxJQUFNTCxlQUFlckMsWUFBWTJDLEtBQUs7QUFFdkQ7O0NBRUMsR0FDRCxNQUFNQyxtQkFBbUIsSUFBTVAsZUFBZXJDLFdBQVcsQ0FBQyxpQkFBaUI7QUFFM0U7O0NBRUMsR0FDRCxNQUFNNkMsV0FBVyxJQUFNUixlQUFlckMsWUFBWThDLEtBQUs7QUFFdkQ7O0NBRUMsR0FDRCxNQUFNQyxtQkFBbUIsSUFBTVYsZUFBZXJDLFdBQVcsQ0FBQyxpQkFBaUI7QUFFM0U7O0NBRUMsR0FDRCxNQUFNZ0QsdUJBQXVCLElBQU1YLGVBQWVyQyxXQUFXLENBQUMscUJBQXFCO0FBRW5GOztDQUVDLEdBQ0QsTUFBTWlELG1CQUFtQixJQUFPLDhCQUE4QixHQUFFZCxrQkFBa0IsQ0FBQyxDQUFDLEVBQUVuQyxZQUFZa0QsT0FBTyxDQUFDLEVBQUUsRUFBRWxELFlBQVltRCxPQUFPLENBQUMsQ0FBQztBQUVuSTs7Q0FFQyxHQUNELE1BQU1DLGtCQUFrQixJQUFPLDhCQUE4QixHQUFFakIsa0JBQWtCLENBQUMsQ0FBQyxFQUFFbkMsWUFBWWtELE9BQU8sQ0FBQyxFQUFFLEVBQUVsRCxZQUFZcUQsTUFBTSxDQUFDLENBQUM7QUFFakk7O0NBRUMsR0FDRCxNQUFNQyxnQkFBZ0IsSUFBTyw4QkFBOEIsR0FBRW5CLGtCQUFrQixDQUFDLENBQUMsRUFBRW5DLFlBQVlrRCxPQUFPLENBQUMsRUFBRSxFQUFFbEQsWUFBWXVELElBQUksQ0FBQyxDQUFDO0FBRTdIOztDQUVDLEdBQ0QsTUFBTUMsZ0JBQWdCLElBQU1uQixlQUFlckMsV0FBVyxDQUFDLGNBQWM7QUFFckU7O0NBRUMsR0FDRCxNQUFNeUQsWUFBWSxJQUFNdEIsa0JBQWtCLENBQUMsQ0FBQyxFQUFFbkMsWUFBWTBELE1BQU0sQ0FBQyxDQUFDO0FBRWxFOztDQUVDLEdBQ0QsTUFBTUMsYUFBYSxJQUFNdEIsZUFBZXJDLFlBQVlrRCxPQUFPO0FBRTNEOztDQUVDLEdBQ0QsTUFBTVUsWUFBWSxJQUFNdkIsZUFBZXJDLFlBQVk2RCxNQUFNO0FBRXpEOztDQUVDLEdBQ0QsTUFBTUMsc0JBQXNCLElBQU16QixlQUFlckMsV0FBVyxDQUFDLHFCQUFxQjtBQUVsRjs7Q0FFQyxHQUNELE1BQU0rRCxpQkFBaUIsSUFBTTFCLGVBQWVyQyxZQUFZZ0UsS0FBSztBQUU3RCx5REFBeUQ7QUFDekQsTUFBTUMsWUFBWSxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7QUFlbkIsQ0FBQztBQUNEOztDQUVDLEdBQ0QsTUFBTUMsdUJBQXVCO0lBQzNCLE1BQU0zQixRQUFRRDtJQUNkLElBQUksQ0FBQ0MsT0FBTztRQUNWLE9BQU8sRUFBRTtJQUNYO0lBQ0Esb0NBQW9DLEdBQ3BDLE1BQU00QixnQ0FBZ0M1QixNQUFNNkIsZ0JBQWdCLENBQUM7SUFDN0QsTUFBTUMsc0NBQXNDQyxNQUFNQyxJQUFJLENBQUNKLDhCQUN2RCw2QkFBNkI7S0FDNUJLLElBQUksQ0FBQyxDQUFDcEcsR0FBR3FHO1FBQ1IsTUFBTUMsWUFBWUMsU0FBU3ZHLEVBQUV3RyxZQUFZLENBQUMsZUFBZTtRQUN6RCxNQUFNQyxZQUFZRixTQUFTRixFQUFFRyxZQUFZLENBQUMsZUFBZTtRQUN6RCxJQUFJRixZQUFZRyxXQUFXO1lBQ3pCLE9BQU87UUFDVCxPQUFPLElBQUlILFlBQVlHLFdBQVc7WUFDaEMsT0FBTyxDQUFDO1FBQ1Y7UUFDQSxPQUFPO0lBQ1Q7SUFFQSxvQ0FBb0MsR0FDcEMsTUFBTUMseUJBQXlCdkMsTUFBTTZCLGdCQUFnQixDQUFDSDtJQUN0RCxNQUFNYyxpQ0FBaUNULE1BQU1DLElBQUksQ0FBQ08sd0JBQXdCRSxNQUFNLENBQUNDLENBQUFBLEtBQU1BLEdBQUdMLFlBQVksQ0FBQyxnQkFBZ0I7SUFDdkgsT0FBTztXQUFJLElBQUlNLElBQUliLG9DQUFvQ2MsTUFBTSxDQUFDSjtLQUFpQyxDQUFDQyxNQUFNLENBQUNDLENBQUFBLEtBQU1HLFlBQVlIO0FBQzNIO0FBRUE7O0NBRUMsR0FDRCxNQUFNSSxVQUFVO0lBQ2QsT0FBT0MsU0FBU3RHLFNBQVNDLElBQUksRUFBRWUsWUFBWXVGLEtBQUssS0FBSyxDQUFDRCxTQUFTdEcsU0FBU0MsSUFBSSxFQUFFZSxXQUFXLENBQUMsY0FBYyxLQUFLLENBQUNzRixTQUFTdEcsU0FBU0MsSUFBSSxFQUFFZSxXQUFXLENBQUMsY0FBYztBQUNsSztBQUVBOztDQUVDLEdBQ0QsTUFBTXdGLFVBQVU7SUFDZCxNQUFNakQsUUFBUUQ7SUFDZCxJQUFJLENBQUNDLE9BQU87UUFDVixPQUFPO0lBQ1Q7SUFDQSxPQUFPK0MsU0FBUy9DLE9BQU92QyxZQUFZeUYsS0FBSztBQUMxQztBQUVBOztDQUVDLEdBQ0QsTUFBTUMsWUFBWTtJQUNoQixNQUFNbkQsUUFBUUQ7SUFDZCxJQUFJLENBQUNDLE9BQU87UUFDVixPQUFPO0lBQ1Q7SUFDQSxPQUFPQSxNQUFNb0QsWUFBWSxDQUFDO0FBQzVCO0FBRUE7Ozs7OztDQU1DLEdBQ0QsTUFBTUMsZUFBZSxDQUFDQyxNQUFNQztJQUMxQkQsS0FBS0UsV0FBVyxHQUFHO0lBQ25CLElBQUlELE1BQU07UUFDUixNQUFNRSxTQUFTLElBQUlDO1FBQ25CLE1BQU1DLFNBQVNGLE9BQU9HLGVBQWUsQ0FBQ0wsTUFBTSxDQUFDLFNBQVMsQ0FBQztRQUN2RCxNQUFNTSxPQUFPRixPQUFPakUsYUFBYSxDQUFDO1FBQ2xDLElBQUltRSxNQUFNO1lBQ1I5QixNQUFNQyxJQUFJLENBQUM2QixLQUFLQyxVQUFVLEVBQUVDLE9BQU8sQ0FBQ0MsQ0FBQUE7Z0JBQ2xDVixLQUFLVyxXQUFXLENBQUNEO1lBQ25CO1FBQ0Y7UUFDQSxNQUFNdEgsT0FBT2lILE9BQU9qRSxhQUFhLENBQUM7UUFDbEMsSUFBSWhELE1BQU07WUFDUnFGLE1BQU1DLElBQUksQ0FBQ3RGLEtBQUtvSCxVQUFVLEVBQUVDLE9BQU8sQ0FBQ0MsQ0FBQUE7Z0JBQ2xDLElBQUlBLGlCQUFpQkUsb0JBQW9CRixpQkFBaUJHLGtCQUFrQjtvQkFDMUViLEtBQUtXLFdBQVcsQ0FBQ0QsTUFBTUksU0FBUyxDQUFDLFFBQVEseURBQXlEO2dCQUNwRyxPQUFPO29CQUNMZCxLQUFLVyxXQUFXLENBQUNEO2dCQUNuQjtZQUNGO1FBQ0Y7SUFDRjtBQUNGO0FBRUE7Ozs7Q0FJQyxHQUNELE1BQU1qQixXQUFXLENBQUNPLE1BQU0xRjtJQUN0QixJQUFJLENBQUNBLFdBQVc7UUFDZCxPQUFPO0lBQ1Q7SUFDQSxNQUFNeUcsWUFBWXpHLFVBQVUwRyxLQUFLLENBQUM7SUFDbEMsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlGLFVBQVU3SSxNQUFNLEVBQUUrSSxJQUFLO1FBQ3pDLElBQUksQ0FBQ2pCLEtBQUtlLFNBQVMsQ0FBQ0csUUFBUSxDQUFDSCxTQUFTLENBQUNFLEVBQUUsR0FBRztZQUMxQyxPQUFPO1FBQ1Q7SUFDRjtJQUNBLE9BQU87QUFDVDtBQUVBOzs7Q0FHQyxHQUNELE1BQU1FLHNCQUFzQixDQUFDbkIsTUFBTW9CO0lBQ2pDM0MsTUFBTUMsSUFBSSxDQUFDc0IsS0FBS2UsU0FBUyxFQUFFTixPQUFPLENBQUNuRyxDQUFBQTtRQUNqQyxJQUFJLENBQUMrRyxPQUFPQyxNQUFNLENBQUNuSCxhQUFhb0IsUUFBUSxDQUFDakIsY0FBYyxDQUFDK0csT0FBT0MsTUFBTSxDQUFDOUcsV0FBV2UsUUFBUSxDQUFDakIsY0FBYyxDQUFDK0csT0FBT0MsTUFBTSxDQUFDRixPQUFPRyxTQUFTLElBQUksQ0FBQyxHQUFHaEcsUUFBUSxDQUFDakIsWUFBWTtZQUNsSzBGLEtBQUtlLFNBQVMsQ0FBQ1MsTUFBTSxDQUFDbEg7UUFDeEI7SUFDRjtBQUNGO0FBRUE7Ozs7Q0FJQyxHQUNELE1BQU1tSCxtQkFBbUIsQ0FBQ3pCLE1BQU1vQixRQUFROUc7SUFDdEM2RyxvQkFBb0JuQixNQUFNb0I7SUFDMUIsSUFBSSxDQUFDQSxPQUFPTSxXQUFXLEVBQUU7UUFDdkI7SUFDRjtJQUNBLE1BQU1BLGNBQWNOLE9BQU9NLFdBQVcsQ0FBRSx3Q0FBd0MsR0FBRXBILFVBQVc7SUFDN0YsSUFBSSxDQUFDb0gsYUFBYTtRQUNoQjtJQUNGO0lBQ0EsSUFBSSxPQUFPQSxnQkFBZ0IsWUFBWSxDQUFDQSxZQUFZakIsT0FBTyxFQUFFO1FBQzNEekYsS0FBSyxDQUFDLDRCQUE0QixFQUFFVixVQUFVLDJDQUEyQyxFQUFFLE9BQU9vSCxZQUFZLENBQUMsQ0FBQztRQUNoSDtJQUNGO0lBQ0FDLFNBQVMzQixNQUFNMEI7QUFDakI7QUFFQTs7OztDQUlDLEdBQ0QsTUFBTUUsYUFBYSxDQUFDbEYsT0FBT21GO0lBQ3pCLElBQUksQ0FBQ0EsWUFBWTtRQUNmLE9BQU87SUFDVDtJQUNBLE9BQVFBO1FBQ04sS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1lBQ0gsT0FBT25GLE1BQU1OLGFBQWEsQ0FBQyxDQUFDLENBQUMsRUFBRWpDLFlBQVl1QyxLQUFLLENBQUMsSUFBSSxFQUFFdkMsV0FBVyxDQUFDMEgsV0FBVyxDQUFDLENBQUM7UUFDbEYsS0FBSztZQUNILE9BQU9uRixNQUFNTixhQUFhLENBQUMsQ0FBQyxDQUFDLEVBQUVqQyxZQUFZdUMsS0FBSyxDQUFDLElBQUksRUFBRXZDLFlBQVkySCxRQUFRLENBQUMsTUFBTSxDQUFDO1FBQ3JGLEtBQUs7WUFDSCxPQUFPcEYsTUFBTU4sYUFBYSxDQUFDLENBQUMsQ0FBQyxFQUFFakMsWUFBWXVDLEtBQUssQ0FBQyxJQUFJLEVBQUV2QyxZQUFZNEgsS0FBSyxDQUFDLGNBQWMsQ0FBQyxLQUFLckYsTUFBTU4sYUFBYSxDQUFDLENBQUMsQ0FBQyxFQUFFakMsWUFBWXVDLEtBQUssQ0FBQyxJQUFJLEVBQUV2QyxZQUFZNEgsS0FBSyxDQUFDLGtCQUFrQixDQUFDO1FBQ3BMLEtBQUs7WUFDSCxPQUFPckYsTUFBTU4sYUFBYSxDQUFDLENBQUMsQ0FBQyxFQUFFakMsWUFBWXVDLEtBQUssQ0FBQyxJQUFJLEVBQUV2QyxZQUFZNkgsS0FBSyxDQUFDLE1BQU0sQ0FBQztRQUNsRjtZQUNFLE9BQU90RixNQUFNTixhQUFhLENBQUMsQ0FBQyxDQUFDLEVBQUVqQyxZQUFZdUMsS0FBSyxDQUFDLElBQUksRUFBRXZDLFlBQVk4SCxLQUFLLENBQUMsQ0FBQztJQUM5RTtBQUNGO0FBRUE7O0NBRUMsR0FDRCxNQUFNQyxhQUFhRCxDQUFBQTtJQUNqQkEsTUFBTS9JLEtBQUs7SUFFWCw0Q0FBNEM7SUFDNUMsSUFBSStJLE1BQU1FLElBQUksS0FBSyxRQUFRO1FBQ3pCLHFDQUFxQztRQUNyQyxNQUFNQyxNQUFNSCxNQUFNSSxLQUFLO1FBQ3ZCSixNQUFNSSxLQUFLLEdBQUc7UUFDZEosTUFBTUksS0FBSyxHQUFHRDtJQUNoQjtBQUNGO0FBRUE7Ozs7Q0FJQyxHQUNELE1BQU1FLGNBQWMsQ0FBQ0MsUUFBUXhCLFdBQVd5QjtJQUN0QyxJQUFJLENBQUNELFVBQVUsQ0FBQ3hCLFdBQVc7UUFDekI7SUFDRjtJQUNBLElBQUksT0FBT0EsY0FBYyxVQUFVO1FBQ2pDQSxZQUFZQSxVQUFVQyxLQUFLLENBQUMsT0FBTzdCLE1BQU0sQ0FBQ3NEO0lBQzVDO0lBQ0ExQixVQUFVTixPQUFPLENBQUNuRyxDQUFBQTtRQUNoQixJQUFJbUUsTUFBTWlFLE9BQU8sQ0FBQ0gsU0FBUztZQUN6QkEsT0FBTzlCLE9BQU8sQ0FBQ1QsQ0FBQUE7Z0JBQ2IsSUFBSXdDLFdBQVc7b0JBQ2J4QyxLQUFLZSxTQUFTLENBQUM0QixHQUFHLENBQUNySTtnQkFDckIsT0FBTztvQkFDTDBGLEtBQUtlLFNBQVMsQ0FBQ1MsTUFBTSxDQUFDbEg7Z0JBQ3hCO1lBQ0Y7UUFDRixPQUFPO1lBQ0wsSUFBSWtJLFdBQVc7Z0JBQ2JELE9BQU94QixTQUFTLENBQUM0QixHQUFHLENBQUNySTtZQUN2QixPQUFPO2dCQUNMaUksT0FBT3hCLFNBQVMsQ0FBQ1MsTUFBTSxDQUFDbEg7WUFDMUI7UUFDRjtJQUNGO0FBQ0Y7QUFFQTs7O0NBR0MsR0FDRCxNQUFNcUgsV0FBVyxDQUFDWSxRQUFReEI7SUFDeEJ1QixZQUFZQyxRQUFReEIsV0FBVztBQUNqQztBQUVBOzs7Q0FHQyxHQUNELE1BQU02QixjQUFjLENBQUNMLFFBQVF4QjtJQUMzQnVCLFlBQVlDLFFBQVF4QixXQUFXO0FBQ2pDO0FBRUE7Ozs7OztDQU1DLEdBQ0QsTUFBTThCLHdCQUF3QixDQUFDN0MsTUFBTTFGO0lBQ25DLE1BQU13SSxXQUFXckUsTUFBTUMsSUFBSSxDQUFDc0IsS0FBSzhDLFFBQVE7SUFDekMsSUFBSyxJQUFJN0IsSUFBSSxHQUFHQSxJQUFJNkIsU0FBUzVLLE1BQU0sRUFBRStJLElBQUs7UUFDeEMsTUFBTVAsUUFBUW9DLFFBQVEsQ0FBQzdCLEVBQUU7UUFDekIsSUFBSVAsaUJBQWlCekgsZUFBZXdHLFNBQVNpQixPQUFPcEcsWUFBWTtZQUM5RCxPQUFPb0c7UUFDVDtJQUNGO0FBQ0Y7QUFFQTs7OztDQUlDLEdBQ0QsTUFBTXFDLHNCQUFzQixDQUFDL0MsTUFBTWdELFVBQVVYO0lBQzNDLElBQUlBLFVBQVUsQ0FBQyxFQUFFdkQsU0FBU3VELE9BQU8sQ0FBQyxFQUFFO1FBQ2xDQSxRQUFRdkQsU0FBU3VEO0lBQ25CO0lBQ0EsSUFBSUEsU0FBU3ZELFNBQVN1RCxXQUFXLEdBQUc7UUFDbENyQyxLQUFLaUQsS0FBSyxDQUFDQyxXQUFXLENBQUNGLFVBQVUsT0FBT1gsVUFBVSxXQUFXLENBQUMsRUFBRUEsTUFBTSxFQUFFLENBQUMsR0FBR0E7SUFDOUUsT0FBTztRQUNMckMsS0FBS2lELEtBQUssQ0FBQ0UsY0FBYyxDQUFDSDtJQUM1QjtBQUNGO0FBRUE7OztDQUdDLEdBQ0QsTUFBTUksT0FBTyxTQUFVcEQsSUFBSTtJQUN6QixJQUFJcUQsVUFBVXBMLFVBQVVDLE1BQU0sR0FBRyxLQUFLRCxTQUFTLENBQUMsRUFBRSxLQUFLMkQsWUFBWTNELFNBQVMsQ0FBQyxFQUFFLEdBQUc7SUFDbEYsSUFBSSxDQUFDK0gsTUFBTTtRQUNUO0lBQ0Y7SUFDQUEsS0FBS2lELEtBQUssQ0FBQ0ksT0FBTyxHQUFHQTtBQUN2QjtBQUVBOztDQUVDLEdBQ0QsTUFBTUMsT0FBT3RELENBQUFBO0lBQ1gsSUFBSSxDQUFDQSxNQUFNO1FBQ1Q7SUFDRjtJQUNBQSxLQUFLaUQsS0FBSyxDQUFDSSxPQUFPLEdBQUc7QUFDdkI7QUFFQTs7O0NBR0MsR0FDRCxNQUFNRSwyQkFBMkIsU0FBVXZELElBQUk7SUFDN0MsSUFBSXFELFVBQVVwTCxVQUFVQyxNQUFNLEdBQUcsS0FBS0QsU0FBUyxDQUFDLEVBQUUsS0FBSzJELFlBQVkzRCxTQUFTLENBQUMsRUFBRSxHQUFHO0lBQ2xGLElBQUksQ0FBQytILE1BQU07UUFDVDtJQUNGO0lBQ0EsSUFBSXdELGlCQUFpQjtRQUNuQkMsT0FBT3pELE1BQU1BLEtBQUswRCxTQUFTLEVBQUVMO0lBQy9CLEdBQUdNLE9BQU8sQ0FBQzNELE1BQU07UUFDZjRELFdBQVc7UUFDWEMsU0FBUztJQUNYO0FBQ0Y7QUFFQTs7Ozs7Q0FLQyxHQUNELE1BQU1DLFdBQVcsQ0FBQ0MsUUFBUUMsVUFBVWhCLFVBQVVYO0lBQzVDLCtCQUErQixHQUMvQixNQUFNakQsS0FBSzJFLE9BQU8zSCxhQUFhLENBQUM0SDtJQUNoQyxJQUFJNUUsSUFBSTtRQUNOQSxHQUFHNkQsS0FBSyxDQUFDQyxXQUFXLENBQUNGLFVBQVVYO0lBQ2pDO0FBQ0Y7QUFFQTs7OztDQUlDLEdBQ0QsTUFBTW9CLFNBQVMsU0FBVXpELElBQUksRUFBRXdDLFNBQVM7SUFDdEMsSUFBSWEsVUFBVXBMLFVBQVVDLE1BQU0sR0FBRyxLQUFLRCxTQUFTLENBQUMsRUFBRSxLQUFLMkQsWUFBWTNELFNBQVMsQ0FBQyxFQUFFLEdBQUc7SUFDbEYsSUFBSXVLLFdBQVc7UUFDYlksS0FBS3BELE1BQU1xRDtJQUNiLE9BQU87UUFDTEMsS0FBS3REO0lBQ1A7QUFDRjtBQUVBOzs7OztDQUtDLEdBQ0QsTUFBTVQsY0FBY1MsQ0FBQUEsT0FBUSxDQUFDLENBQUVBLENBQUFBLFFBQVNBLENBQUFBLEtBQUtpRSxXQUFXLElBQUlqRSxLQUFLa0UsWUFBWSxJQUFJbEUsS0FBS21FLGNBQWMsR0FBR2pNLE1BQU07QUFFN0c7O0NBRUMsR0FDRCxNQUFNa00sc0JBQXNCLElBQU0sQ0FBQzdFLFlBQVluQyx1QkFBdUIsQ0FBQ21DLFlBQVk5QixvQkFBb0IsQ0FBQzhCLFlBQVloQztBQUVwSDs7O0NBR0MsR0FDRCxNQUFNOEcsZUFBZXJFLENBQUFBLE9BQVEsQ0FBQyxDQUFFQSxDQUFBQSxLQUFLc0UsWUFBWSxHQUFHdEUsS0FBS3VFLFlBQVk7QUFFckU7Ozs7O0NBS0MsR0FDRCxNQUFNQyxrQkFBa0J4RSxDQUFBQTtJQUN0QixNQUFNaUQsUUFBUXZKLE9BQU8rSyxnQkFBZ0IsQ0FBQ3pFO0lBQ3RDLE1BQU0wRSxlQUFlQyxXQUFXMUIsTUFBTTJCLGdCQUFnQixDQUFDLHlCQUF5QjtJQUNoRixNQUFNQyxnQkFBZ0JGLFdBQVcxQixNQUFNMkIsZ0JBQWdCLENBQUMsMEJBQTBCO0lBQ2xGLE9BQU9GLGVBQWUsS0FBS0csZ0JBQWdCO0FBQzdDO0FBRUE7OztDQUdDLEdBQ0QsTUFBTUMsMEJBQTBCLFNBQVVDLEtBQUs7SUFDN0MsSUFBSUMsUUFBUS9NLFVBQVVDLE1BQU0sR0FBRyxLQUFLRCxTQUFTLENBQUMsRUFBRSxLQUFLMkQsWUFBWTNELFNBQVMsQ0FBQyxFQUFFLEdBQUc7SUFDaEYsTUFBTWdOLG1CQUFtQmhIO0lBQ3pCLElBQUksQ0FBQ2dILGtCQUFrQjtRQUNyQjtJQUNGO0lBQ0EsSUFBSTFGLFlBQVkwRixtQkFBbUI7UUFDakMsSUFBSUQsT0FBTztZQUNUQyxpQkFBaUJoQyxLQUFLLENBQUNpQyxVQUFVLEdBQUc7WUFDcENELGlCQUFpQmhDLEtBQUssQ0FBQ2tDLEtBQUssR0FBRztRQUNqQztRQUNBcEwsV0FBVztZQUNUa0wsaUJBQWlCaEMsS0FBSyxDQUFDaUMsVUFBVSxHQUFHLENBQUMsTUFBTSxFQUFFSCxRQUFRLEtBQUssUUFBUSxDQUFDO1lBQ25FRSxpQkFBaUJoQyxLQUFLLENBQUNrQyxLQUFLLEdBQUc7UUFDakMsR0FBRztJQUNMO0FBQ0Y7QUFDQSxNQUFNQyx1QkFBdUI7SUFDM0IsTUFBTUgsbUJBQW1CaEg7SUFDekIsSUFBSSxDQUFDZ0gsa0JBQWtCO1FBQ3JCO0lBQ0Y7SUFDQSxNQUFNSSx3QkFBd0J2RyxTQUFTcEYsT0FBTytLLGdCQUFnQixDQUFDUSxrQkFBa0JFLEtBQUs7SUFDdEZGLGlCQUFpQmhDLEtBQUssQ0FBQ0UsY0FBYyxDQUFDO0lBQ3RDOEIsaUJBQWlCaEMsS0FBSyxDQUFDa0MsS0FBSyxHQUFHO0lBQy9CLE1BQU1HLDRCQUE0QnhHLFNBQVNwRixPQUFPK0ssZ0JBQWdCLENBQUNRLGtCQUFrQkUsS0FBSztJQUMxRixNQUFNSSwwQkFBMEJGLHdCQUF3QkMsNEJBQTRCO0lBQ3BGTCxpQkFBaUJoQyxLQUFLLENBQUNrQyxLQUFLLEdBQUcsQ0FBQyxFQUFFSSx3QkFBd0IsQ0FBQyxDQUFDO0FBQzlEO0FBRUE7Ozs7Q0FJQyxHQUNELE1BQU1DLFlBQVksSUFBTSxLQUFrQixJQUFlLENBQW9CO0FBRTdFLE1BQU1DLFlBQVksQ0FBQzt1QkFDSSxFQUFFdEwsWUFBWTJDLEtBQUssQ0FBQyxvQkFBb0IsRUFBRTNDLFdBQVcsQ0FBQyxpQkFBaUIsQ0FBQyxTQUFTLEVBQUVBLFlBQVl1QyxLQUFLLENBQUM7Z0NBQzVGLEVBQUV2QyxZQUFZZ0UsS0FBSyxDQUFDO2NBQ3RDLEVBQUVoRSxXQUFXLENBQUMsaUJBQWlCLENBQUM7ZUFDL0IsRUFBRUEsWUFBWU0sSUFBSSxDQUFDO2VBQ25CLEVBQUVOLFlBQVk4QyxLQUFLLENBQUM7Y0FDckIsRUFBRTlDLFlBQVkyQyxLQUFLLENBQUMsTUFBTSxFQUFFM0MsWUFBWTJDLEtBQUssQ0FBQztlQUM3QyxFQUFFM0MsV0FBVyxDQUFDLGlCQUFpQixDQUFDLE1BQU0sRUFBRUEsV0FBVyxDQUFDLGlCQUFpQixDQUFDO2lCQUNwRSxFQUFFQSxZQUFZOEgsS0FBSyxDQUFDLE1BQU0sRUFBRTlILFlBQVk4SCxLQUFLLENBQUM7NkJBQ2xDLEVBQUU5SCxZQUFZdUwsSUFBSSxDQUFDO2VBQ2pDLEVBQUV2TCxZQUFZNkgsS0FBSyxDQUFDOzs7O2tCQUlqQixFQUFFN0gsWUFBWXdMLE1BQU0sQ0FBQyxNQUFNLEVBQUV4TCxZQUFZd0wsTUFBTSxDQUFDO2VBQ25ELEVBQUV4TCxZQUFZNEgsS0FBSyxDQUFDO2lCQUNsQixFQUFFNUgsWUFBWTJILFFBQVEsQ0FBQztnQ0FDUixFQUFFM0gsWUFBWTJILFFBQVEsQ0FBQztrQkFDckMsRUFBRTNILFlBQVl5TCxLQUFLLENBQUM7O29CQUVsQixFQUFFekwsWUFBWTBMLFFBQVEsQ0FBQyxNQUFNLEVBQUUxTCxZQUFZMEwsUUFBUSxDQUFDO2VBQ3pELEVBQUUxTCxXQUFXLENBQUMscUJBQXFCLENBQUMsTUFBTSxFQUFFQSxXQUFXLENBQUMscUJBQXFCLENBQUM7ZUFDOUUsRUFBRUEsWUFBWWtELE9BQU8sQ0FBQztpQkFDcEIsRUFBRWxELFlBQVkwRCxNQUFNLENBQUM7a0NBQ0osRUFBRTFELFlBQVltRCxPQUFPLENBQUM7a0NBQ3RCLEVBQUVuRCxZQUFZdUQsSUFBSSxDQUFDO2tDQUNuQixFQUFFdkQsWUFBWXFELE1BQU0sQ0FBQzs7ZUFFeEMsRUFBRXJELFlBQVk2RCxNQUFNLENBQUM7ZUFDckIsRUFBRTdELFdBQVcsQ0FBQywrQkFBK0IsQ0FBQztpQkFDNUMsRUFBRUEsV0FBVyxDQUFDLHFCQUFxQixDQUFDOzs7QUFHckQsQ0FBQyxDQUFDMkwsT0FBTyxDQUFDLGNBQWM7QUFFeEI7O0NBRUMsR0FDRCxNQUFNQyxvQkFBb0I7SUFDeEIsTUFBTUMsZUFBZTdKO0lBQ3JCLElBQUksQ0FBQzZKLGNBQWM7UUFDakIsT0FBTztJQUNUO0lBQ0FBLGFBQWF4RSxNQUFNO0lBQ25Cb0IsWUFBWTtRQUFDekosU0FBUzhNLGVBQWU7UUFBRTlNLFNBQVNDLElBQUk7S0FBQyxFQUFFO1FBQUNlLFdBQVcsQ0FBQyxjQUFjO1FBQUVBLFdBQVcsQ0FBQyxjQUFjO1FBQUVBLFdBQVcsQ0FBQyxhQUFhO0tBQUM7SUFDMUksT0FBTztBQUNUO0FBQ0EsTUFBTStMLDJCQUEyQjtJQUMvQnBOLFlBQVlxTixlQUFlLENBQUNDLHNCQUFzQjtBQUNwRDtBQUNBLE1BQU1DLDBCQUEwQjtJQUM5QixNQUFNM0osUUFBUUQ7SUFDZCxNQUFNd0YsUUFBUVksc0JBQXNCbkcsT0FBT3ZDLFlBQVk4SCxLQUFLO0lBQzVELE1BQU15RCxPQUFPN0Msc0JBQXNCbkcsT0FBT3ZDLFlBQVl1TCxJQUFJO0lBQzFELDZCQUE2QixHQUM3QixNQUFNMUQsUUFBUXRGLE1BQU1OLGFBQWEsQ0FBQyxDQUFDLENBQUMsRUFBRWpDLFlBQVk2SCxLQUFLLENBQUMsTUFBTSxDQUFDO0lBQy9ELDhCQUE4QixHQUM5QixNQUFNc0UsY0FBYzVKLE1BQU1OLGFBQWEsQ0FBQyxDQUFDLENBQUMsRUFBRWpDLFlBQVk2SCxLQUFLLENBQUMsT0FBTyxDQUFDO0lBQ3RFLE1BQU0yRCxTQUFTOUMsc0JBQXNCbkcsT0FBT3ZDLFlBQVl3TCxNQUFNO0lBQzlELDZCQUE2QixHQUM3QixNQUFNN0QsV0FBV3BGLE1BQU1OLGFBQWEsQ0FBQyxDQUFDLENBQUMsRUFBRWpDLFlBQVkySCxRQUFRLENBQUMsTUFBTSxDQUFDO0lBQ3JFLE1BQU0rRCxXQUFXaEQsc0JBQXNCbkcsT0FBT3ZDLFlBQVkwTCxRQUFRO0lBQ2xFNUQsTUFBTXNFLE9BQU8sR0FBR0w7SUFDaEJSLEtBQUtjLFFBQVEsR0FBR047SUFDaEJQLE9BQU9hLFFBQVEsR0FBR047SUFDbEJwRSxTQUFTMEUsUUFBUSxHQUFHTjtJQUNwQkwsU0FBU1UsT0FBTyxHQUFHTDtJQUNuQmxFLE1BQU11RSxPQUFPLEdBQUc7UUFDZEw7UUFDQUksWUFBWWpFLEtBQUssR0FBR0wsTUFBTUssS0FBSztJQUNqQztJQUNBTCxNQUFNd0UsUUFBUSxHQUFHO1FBQ2ZOO1FBQ0FJLFlBQVlqRSxLQUFLLEdBQUdMLE1BQU1LLEtBQUs7SUFDakM7QUFDRjtBQUVBOzs7Q0FHQyxHQUNELE1BQU1vRSxZQUFZbEUsQ0FBQUEsU0FBVSxPQUFPQSxXQUFXLFdBQVdwSixTQUFTaUQsYUFBYSxDQUFDbUcsVUFBVUE7QUFFMUY7O0NBRUMsR0FDRCxNQUFNbUUscUJBQXFCdEYsQ0FBQUE7SUFDekIsTUFBTTFFLFFBQVFEO0lBQ2RDLE1BQU1pSyxZQUFZLENBQUMsUUFBUXZGLE9BQU94QixLQUFLLEdBQUcsVUFBVTtJQUNwRGxELE1BQU1pSyxZQUFZLENBQUMsYUFBYXZGLE9BQU94QixLQUFLLEdBQUcsV0FBVztJQUMxRCxJQUFJLENBQUN3QixPQUFPeEIsS0FBSyxFQUFFO1FBQ2pCbEQsTUFBTWlLLFlBQVksQ0FBQyxjQUFjO0lBQ25DO0FBQ0Y7QUFFQTs7Q0FFQyxHQUNELE1BQU1DLFdBQVdDLENBQUFBO0lBQ2YsSUFBSW5OLE9BQU8rSyxnQkFBZ0IsQ0FBQ29DLGVBQWVDLFNBQVMsS0FBSyxPQUFPO1FBQzlEbkYsU0FBU3hGLGdCQUFnQmhDLFlBQVk0TSxHQUFHO0lBQzFDO0FBQ0Y7QUFFQTs7OztDQUlDLEdBQ0QsTUFBTUMsT0FBTzVGLENBQUFBO0lBQ1gsZ0RBQWdEO0lBQ2hELE1BQU02RixzQkFBc0JsQjtJQUM1QixJQUFJUCxhQUFhO1FBQ2ZwSyxNQUFNO1FBQ047SUFDRjtJQUNBLE1BQU1pQixZQUFZbEQsU0FBUytOLGFBQWEsQ0FBQztJQUN6QzdLLFVBQVUvQixTQUFTLEdBQUdILFlBQVlrQyxTQUFTO0lBQzNDLElBQUk0SyxxQkFBcUI7UUFDdkJ0RixTQUFTdEYsV0FBV2xDLFdBQVcsQ0FBQyxnQkFBZ0I7SUFDbEQ7SUFDQTRGLGFBQWExRCxXQUFXb0o7SUFDeEIsTUFBTW9CLGdCQUFnQkosVUFBVXJGLE9BQU9tQixNQUFNO0lBQzdDc0UsY0FBY2xHLFdBQVcsQ0FBQ3RFO0lBQzFCcUssbUJBQW1CdEY7SUFDbkJ3RixTQUFTQztJQUNUUjtBQUNGO0FBRUE7OztDQUdDLEdBQ0QsTUFBTWMsdUJBQXVCLENBQUNDLE9BQU83RTtJQUNuQyxjQUFjO0lBQ2QsSUFBSTZFLGlCQUFpQm5PLGFBQWE7UUFDaENzSixPQUFPNUIsV0FBVyxDQUFDeUc7SUFDckIsT0FHSyxJQUFJLE9BQU9BLFVBQVUsVUFBVTtRQUNsQ0MsYUFBYUQsT0FBTzdFO0lBQ3RCLE9BR0ssSUFBSTZFLE9BQU87UUFDZHJILGFBQWF3QyxRQUFRNkU7SUFDdkI7QUFDRjtBQUVBOzs7Q0FHQyxHQUNELE1BQU1DLGVBQWUsQ0FBQ0QsT0FBTzdFO0lBQzNCLG9CQUFvQjtJQUNwQixJQUFJNkUsTUFBTUUsTUFBTSxFQUFFO1FBQ2hCQyxpQkFBaUJoRixRQUFRNkU7SUFDM0IsT0FHSztRQUNIckgsYUFBYXdDLFFBQVE2RSxNQUFNSSxRQUFRO0lBQ3JDO0FBQ0Y7QUFFQTs7O0NBR0MsR0FDRCxNQUFNRCxtQkFBbUIsQ0FBQ2hGLFFBQVF2QztJQUNoQ3VDLE9BQU9yQyxXQUFXLEdBQUc7SUFDckIsSUFBSSxLQUFLRixNQUFNO1FBQ2IsSUFBSyxJQUFJaUIsSUFBSSxHQUFHQSxDQUFBQSxLQUFLakIsSUFBRyxHQUFHaUIsSUFBSztZQUM5QnNCLE9BQU81QixXQUFXLENBQUNYLElBQUksQ0FBQ2lCLEVBQUUsQ0FBQ0gsU0FBUyxDQUFDO1FBQ3ZDO0lBQ0YsT0FBTztRQUNMeUIsT0FBTzVCLFdBQVcsQ0FBQ1gsS0FBS2MsU0FBUyxDQUFDO0lBQ3BDO0FBQ0Y7QUFFQTs7Q0FFQyxHQUNELE1BQU0yRyxvQkFBb0IsQ0FBQztJQUN6QiwwQkFBMEI7SUFDMUIsSUFBSWpDLGFBQWE7UUFDZixPQUFPO0lBQ1Q7SUFDQSxNQUFNa0MsU0FBU3ZPLFNBQVMrTixhQUFhLENBQUM7SUFFdEMsMkJBQTJCO0lBQzNCLElBQUksT0FBT1EsT0FBT3pFLEtBQUssQ0FBQzBFLGVBQWUsS0FBSyxhQUFhO1FBQ3ZELE9BQU87SUFDVDtJQUVBLGtCQUFrQjtJQUNsQixJQUFJLE9BQU9ELE9BQU96RSxLQUFLLENBQUMyRSxTQUFTLEtBQUssYUFBYTtRQUNqRCxPQUFPO0lBQ1Q7SUFDQSxPQUFPO0FBQ1Q7QUFFQTs7O0NBR0MsR0FDRCxNQUFNQyxnQkFBZ0IsQ0FBQ0MsVUFBVTFHO0lBQy9CLE1BQU0vRCxVQUFVUztJQUNoQixNQUFNRCxTQUFTRDtJQUNmLElBQUksQ0FBQ1AsV0FBVyxDQUFDUSxRQUFRO1FBQ3ZCO0lBQ0Y7SUFFQSw0QkFBNEI7SUFDNUIsSUFBSSxDQUFDdUQsT0FBTzJHLGlCQUFpQixJQUFJLENBQUMzRyxPQUFPNEcsY0FBYyxJQUFJLENBQUM1RyxPQUFPNkcsZ0JBQWdCLEVBQUU7UUFDbkYzRSxLQUFLakc7SUFDUCxPQUFPO1FBQ0wrRixLQUFLL0Y7SUFDUDtJQUVBLGVBQWU7SUFDZm9FLGlCQUFpQnBFLFNBQVMrRCxRQUFRO0lBRWxDLHlCQUF5QjtJQUN6QjhHLGNBQWM3SyxTQUFTUSxRQUFRdUQ7SUFFL0IsU0FBUztJQUNUckIsYUFBYWxDLFFBQVF1RCxPQUFPK0csVUFBVSxJQUFJO0lBQzFDMUcsaUJBQWlCNUQsUUFBUXVELFFBQVE7QUFDbkM7QUFFQTs7OztDQUlDLEdBQ0QsU0FBUzhHLGNBQWM3SyxPQUFPLEVBQUVRLE1BQU0sRUFBRXVELE1BQU07SUFDNUMsTUFBTWdILGdCQUFnQmhMO0lBQ3RCLE1BQU1pTCxhQUFhNUs7SUFDbkIsTUFBTTZLLGVBQWUvSztJQUNyQixJQUFJLENBQUM2SyxpQkFBaUIsQ0FBQ0MsY0FBYyxDQUFDQyxjQUFjO1FBQ2xEO0lBQ0Y7SUFFQSxpQkFBaUI7SUFDakJDLGFBQWFILGVBQWUsV0FBV2hIO0lBQ3ZDbUgsYUFBYUYsWUFBWSxRQUFRakg7SUFDakNtSCxhQUFhRCxjQUFjLFVBQVVsSDtJQUNyQ29ILHFCQUFxQkosZUFBZUMsWUFBWUMsY0FBY2xIO0lBQzlELElBQUlBLE9BQU9xSCxjQUFjLEVBQUU7UUFDekIsSUFBSXJILE9BQU94QixLQUFLLEVBQUU7WUFDaEJ2QyxRQUFRcUwsWUFBWSxDQUFDSixjQUFjRjtZQUNuQy9LLFFBQVFxTCxZQUFZLENBQUNMLFlBQVlEO1FBQ25DLE9BQU87WUFDTC9LLFFBQVFxTCxZQUFZLENBQUNKLGNBQWN6SztZQUNuQ1IsUUFBUXFMLFlBQVksQ0FBQ0wsWUFBWXhLO1lBQ2pDUixRQUFRcUwsWUFBWSxDQUFDTixlQUFldks7UUFDdEM7SUFDRjtBQUNGO0FBRUE7Ozs7O0NBS0MsR0FDRCxTQUFTMksscUJBQXFCSixhQUFhLEVBQUVDLFVBQVUsRUFBRUMsWUFBWSxFQUFFbEgsTUFBTTtJQUMzRSxJQUFJLENBQUNBLE9BQU91SCxjQUFjLEVBQUU7UUFDMUIvRixZQUFZO1lBQUN3RjtZQUFlQztZQUFZQztTQUFhLEVBQUVuTyxZQUFZeU8sTUFBTTtRQUN6RTtJQUNGO0lBQ0FqSCxTQUFTO1FBQUN5RztRQUFlQztRQUFZQztLQUFhLEVBQUVuTyxZQUFZeU8sTUFBTTtJQUV0RSw0QkFBNEI7SUFDNUIsSUFBSXhILE9BQU95SCxrQkFBa0IsRUFBRTtRQUM3QlQsY0FBY25GLEtBQUssQ0FBQzZGLGVBQWUsR0FBRzFILE9BQU95SCxrQkFBa0I7UUFDL0RsSCxTQUFTeUcsZUFBZWpPLFdBQVcsQ0FBQyxrQkFBa0I7SUFDeEQ7SUFDQSxJQUFJaUgsT0FBTzJILGVBQWUsRUFBRTtRQUMxQlYsV0FBV3BGLEtBQUssQ0FBQzZGLGVBQWUsR0FBRzFILE9BQU8ySCxlQUFlO1FBQ3pEcEgsU0FBUzBHLFlBQVlsTyxXQUFXLENBQUMsa0JBQWtCO0lBQ3JEO0lBQ0EsSUFBSWlILE9BQU80SCxpQkFBaUIsRUFBRTtRQUM1QlYsYUFBYXJGLEtBQUssQ0FBQzZGLGVBQWUsR0FBRzFILE9BQU80SCxpQkFBaUI7UUFDN0RySCxTQUFTMkcsY0FBY25PLFdBQVcsQ0FBQyxrQkFBa0I7SUFDdkQ7QUFDRjtBQUVBOzs7O0NBSUMsR0FDRCxTQUFTb08sYUFBYVUsTUFBTSxFQUFFQyxVQUFVLEVBQUU5SCxNQUFNO0lBQzlDLE1BQU0rSCxhQUFhLDBDQUEwQyxHQUFFeE8sc0JBQXNCdU87SUFDckZ6RixPQUFPd0YsUUFBUTdILE1BQU0sQ0FBQyxDQUFDLElBQUksRUFBRStILFdBQVcsTUFBTSxDQUFDLENBQUMsRUFBRTtJQUNsRHBKLGFBQWFrSixRQUFRN0gsTUFBTSxDQUFDLENBQUMsRUFBRThILFdBQVcsVUFBVSxDQUFDLENBQUMsSUFBSSxLQUFLLG1CQUFtQjtJQUNsRkQsT0FBT3RDLFlBQVksQ0FBQyxjQUFjdkYsTUFBTSxDQUFDLENBQUMsRUFBRThILFdBQVcsZUFBZSxDQUFDLENBQUMsSUFBSSxLQUFLLGFBQWE7SUFFOUYsNkJBQTZCO0lBQzdCRCxPQUFPM08sU0FBUyxHQUFHSCxXQUFXLENBQUMrTyxXQUFXO0lBQzFDekgsaUJBQWlCd0gsUUFBUTdILFFBQVEsQ0FBQyxFQUFFOEgsV0FBVyxNQUFNLENBQUM7QUFDeEQ7QUFFQTs7O0NBR0MsR0FDRCxNQUFNRSxvQkFBb0IsQ0FBQ3RCLFVBQVUxRztJQUNuQyxNQUFNaUksY0FBY25MO0lBQ3BCLElBQUksQ0FBQ21MLGFBQWE7UUFDaEI7SUFDRjtJQUNBdEosYUFBYXNKLGFBQWFqSSxPQUFPa0ksZUFBZSxJQUFJO0lBRXBELGVBQWU7SUFDZjdILGlCQUFpQjRILGFBQWFqSSxRQUFRO0lBQ3RDcUMsT0FBTzRGLGFBQWFqSSxPQUFPbUksZUFBZTtJQUMxQ0YsWUFBWTFDLFlBQVksQ0FBQyxjQUFjdkYsT0FBT29JLG9CQUFvQixJQUFJO0FBQ3hFO0FBRUE7OztDQUdDLEdBQ0QsTUFBTUMsa0JBQWtCLENBQUMzQixVQUFVMUc7SUFDakMsTUFBTS9FLFlBQVlGO0lBQ2xCLElBQUksQ0FBQ0UsV0FBVztRQUNkO0lBQ0Y7SUFDQXFOLG9CQUFvQnJOLFdBQVcrRSxPQUFPdUksUUFBUTtJQUM5Q0Msb0JBQW9Cdk4sV0FBVytFLE9BQU95SSxRQUFRO0lBQzlDQyxnQkFBZ0J6TixXQUFXK0UsT0FBTzJJLElBQUk7SUFFdEMsZUFBZTtJQUNmdEksaUJBQWlCcEYsV0FBVytFLFFBQVE7QUFDdEM7QUFFQTs7O0NBR0MsR0FDRCxTQUFTc0ksb0JBQW9Cck4sU0FBUyxFQUFFc04sUUFBUTtJQUM5QyxJQUFJLE9BQU9BLGFBQWEsVUFBVTtRQUNoQ3ROLFVBQVU0RyxLQUFLLENBQUMrRyxVQUFVLEdBQUdMO0lBQy9CLE9BQU8sSUFBSSxDQUFDQSxVQUFVO1FBQ3BCaEksU0FBUztZQUFDeEksU0FBUzhNLGVBQWU7WUFBRTlNLFNBQVNDLElBQUk7U0FBQyxFQUFFZSxXQUFXLENBQUMsY0FBYztJQUNoRjtBQUNGO0FBRUE7OztDQUdDLEdBQ0QsU0FBU3lQLG9CQUFvQnZOLFNBQVMsRUFBRXdOLFFBQVE7SUFDOUMsSUFBSSxDQUFDQSxVQUFVO1FBQ2I7SUFDRjtJQUNBLElBQUlBLFlBQVkxUCxhQUFhO1FBQzNCd0gsU0FBU3RGLFdBQVdsQyxXQUFXLENBQUMwUCxTQUFTO0lBQzNDLE9BQU87UUFDTDdPLEtBQUs7UUFDTDJHLFNBQVN0RixXQUFXbEMsWUFBWThQLE1BQU07SUFDeEM7QUFDRjtBQUVBOzs7Q0FHQyxHQUNELFNBQVNILGdCQUFnQnpOLFNBQVMsRUFBRTBOLElBQUk7SUFDdEMsSUFBSSxDQUFDQSxNQUFNO1FBQ1Q7SUFDRjtJQUNBcEksU0FBU3RGLFdBQVdsQyxXQUFXLENBQUMsQ0FBQyxLQUFLLEVBQUU0UCxLQUFLLENBQUMsQ0FBQztBQUNqRDtBQUVBOzs7Ozs7OztDQVFDLEdBRUQsSUFBSUcsZUFBZTtJQUNqQkMsYUFBYSxJQUFJQztJQUNqQkMsVUFBVSxJQUFJRDtBQUNoQjtBQUVBLG9EQUFvRDtBQUdwRCx5QkFBeUIsR0FDekIsTUFBTUUsZUFBZTtJQUFDO0lBQVM7SUFBUTtJQUFTO0lBQVU7SUFBUztJQUFZO0NBQVc7QUFFMUY7OztDQUdDLEdBQ0QsTUFBTUMsY0FBYyxDQUFDekMsVUFBVTFHO0lBQzdCLE1BQU0xRSxRQUFRRDtJQUNkLElBQUksQ0FBQ0MsT0FBTztRQUNWO0lBQ0Y7SUFDQSxNQUFNeU4sY0FBY0QsYUFBYUMsV0FBVyxDQUFDM1IsR0FBRyxDQUFDc1A7SUFDakQsTUFBTTBDLFdBQVcsQ0FBQ0wsZUFBZS9JLE9BQU9hLEtBQUssS0FBS2tJLFlBQVlsSSxLQUFLO0lBQ25FcUksYUFBYTdKLE9BQU8sQ0FBQ29CLENBQUFBO1FBQ25CLE1BQU00SSxpQkFBaUI1SCxzQkFBc0JuRyxPQUFPdkMsV0FBVyxDQUFDMEgsV0FBVztRQUMzRSxJQUFJLENBQUM0SSxnQkFBZ0I7WUFDbkI7UUFDRjtRQUVBLGlCQUFpQjtRQUNqQkMsY0FBYzdJLFlBQVlULE9BQU91SixlQUFlO1FBRWhELFlBQVk7UUFDWkYsZUFBZW5RLFNBQVMsR0FBR0gsV0FBVyxDQUFDMEgsV0FBVztRQUNsRCxJQUFJMkksVUFBVTtZQUNabEgsS0FBS21IO1FBQ1A7SUFDRjtJQUNBLElBQUlySixPQUFPYSxLQUFLLEVBQUU7UUFDaEIsSUFBSXVJLFVBQVU7WUFDWkksVUFBVXhKO1FBQ1o7UUFDQSxtQkFBbUI7UUFDbkJ5SixlQUFleko7SUFDakI7QUFDRjtBQUVBOztDQUVDLEdBQ0QsTUFBTXdKLFlBQVl4SixDQUFBQTtJQUNoQixJQUFJLENBQUNBLE9BQU9hLEtBQUssRUFBRTtRQUNqQjtJQUNGO0lBQ0EsSUFBSSxDQUFDNkksZUFBZSxDQUFDMUosT0FBT2EsS0FBSyxDQUFDLEVBQUU7UUFDbEM3RyxNQUFNLENBQUMsbUNBQW1DLEVBQUVpRyxPQUFPMEosSUFBSSxDQUFDRCxpQkFBaUIzUCxJQUFJLENBQUMsT0FBTyxPQUFPLEVBQUVpRyxPQUFPYSxLQUFLLENBQUMsQ0FBQyxDQUFDO1FBQzdHO0lBQ0Y7SUFDQSxNQUFNd0ksaUJBQWlCTyxrQkFBa0I1SixPQUFPYSxLQUFLO0lBQ3JELElBQUksQ0FBQ3dJLGdCQUFnQjtRQUNuQjtJQUNGO0lBQ0EsTUFBTXhJLFFBQVE2SSxlQUFlLENBQUMxSixPQUFPYSxLQUFLLENBQUMsQ0FBQ3dJLGdCQUFnQnJKO0lBQzVEZ0MsS0FBS3FIO0lBRUwsa0JBQWtCO0lBQ2xCLElBQUlySixPQUFPNkosY0FBYyxFQUFFO1FBQ3pCbFIsV0FBVztZQUNUbUksV0FBV0Q7UUFDYjtJQUNGO0FBQ0Y7QUFFQTs7Q0FFQyxHQUNELE1BQU1pSixtQkFBbUJqSixDQUFBQTtJQUN2QixJQUFLLElBQUloQixJQUFJLEdBQUdBLElBQUlnQixNQUFNa0osVUFBVSxDQUFDalQsTUFBTSxFQUFFK0ksSUFBSztRQUNoRCxNQUFNbUssV0FBV25KLE1BQU1rSixVQUFVLENBQUNsSyxFQUFFLENBQUNvSyxJQUFJO1FBQ3pDLElBQUksQ0FBQztZQUFDO1lBQU07WUFBUTtZQUFTO1NBQVEsQ0FBQzlQLFFBQVEsQ0FBQzZQLFdBQVc7WUFDeERuSixNQUFNcUosZUFBZSxDQUFDRjtRQUN4QjtJQUNGO0FBQ0Y7QUFFQTs7O0NBR0MsR0FDRCxNQUFNVixnQkFBZ0IsQ0FBQzdJLFlBQVk4STtJQUNqQyxNQUFNak8sUUFBUUQ7SUFDZCxJQUFJLENBQUNDLE9BQU87UUFDVjtJQUNGO0lBQ0EsTUFBTXVGLFFBQVFMLFdBQVdsRixPQUFPbUY7SUFDaEMsSUFBSSxDQUFDSSxPQUFPO1FBQ1Y7SUFDRjtJQUNBaUosaUJBQWlCako7SUFDakIsSUFBSyxNQUFNc0osUUFBUVosZ0JBQWlCO1FBQ2xDMUksTUFBTTBFLFlBQVksQ0FBQzRFLE1BQU1aLGVBQWUsQ0FBQ1ksS0FBSztJQUNoRDtBQUNGO0FBRUE7O0NBRUMsR0FDRCxNQUFNVixpQkFBaUJ6SixDQUFBQTtJQUNyQixJQUFJLENBQUNBLE9BQU9hLEtBQUssRUFBRTtRQUNqQjtJQUNGO0lBQ0EsTUFBTXdJLGlCQUFpQk8sa0JBQWtCNUosT0FBT2EsS0FBSztJQUNyRCxJQUFJd0ksZ0JBQWdCO1FBQ2xCaEosaUJBQWlCZ0osZ0JBQWdCckosUUFBUTtJQUMzQztBQUNGO0FBRUE7OztDQUdDLEdBQ0QsTUFBTW9LLHNCQUFzQixDQUFDdkosT0FBT2I7SUFDbEMsSUFBSSxDQUFDYSxNQUFNd0osV0FBVyxJQUFJckssT0FBT3NLLGdCQUFnQixFQUFFO1FBQ2pEekosTUFBTXdKLFdBQVcsR0FBR3JLLE9BQU9zSyxnQkFBZ0I7SUFDN0M7QUFDRjtBQUVBOzs7O0NBSUMsR0FDRCxNQUFNQyxnQkFBZ0IsQ0FBQzFKLE9BQU8ySixXQUFXeEs7SUFDdkMsSUFBSUEsT0FBT3lLLFVBQVUsRUFBRTtRQUNyQixNQUFNakcsUUFBUXpNLFNBQVMrTixhQUFhLENBQUM7UUFDckMsTUFBTTRFLGFBQWEzUixXQUFXLENBQUMsY0FBYztRQUM3Q3lMLE1BQU1lLFlBQVksQ0FBQyxPQUFPMUUsTUFBTThKLEVBQUU7UUFDbENuRyxNQUFNdEwsU0FBUyxHQUFHd1I7UUFDbEIsSUFBSSxPQUFPMUssT0FBT00sV0FBVyxLQUFLLFVBQVU7WUFDMUNDLFNBQVNpRSxPQUFPeEUsT0FBT00sV0FBVyxDQUFDbUssVUFBVTtRQUMvQztRQUNBakcsTUFBTW9HLFNBQVMsR0FBRzVLLE9BQU95SyxVQUFVO1FBQ25DRCxVQUFVSyxxQkFBcUIsQ0FBQyxlQUFlckc7SUFDakQ7QUFDRjtBQUVBOzs7Q0FHQyxHQUNELE1BQU1vRixvQkFBb0JrQixDQUFBQTtJQUN4QixNQUFNeFAsUUFBUUQ7SUFDZCxJQUFJLENBQUNDLE9BQU87UUFDVjtJQUNGO0lBQ0EsT0FBT21HLHNCQUFzQm5HLE9BQU92QyxXQUFXLENBQUUsc0JBQXNCLEdBQUUrUixVQUFXLElBQUkvUixZQUFZOEgsS0FBSztBQUMzRztBQUVBOzs7Q0FHQyxHQUNELE1BQU1rSyx3QkFBd0IsQ0FBQ2xLLE9BQU9tSztJQUNwQyxJQUFJO1FBQUM7UUFBVTtLQUFTLENBQUM3USxRQUFRLENBQUMsT0FBTzZRLGFBQWE7UUFDcERuSyxNQUFNSSxLQUFLLEdBQUcsQ0FBQyxFQUFFK0osV0FBVyxDQUFDO0lBQy9CLE9BQU8sSUFBSSxDQUFDbFEsVUFBVWtRLGFBQWE7UUFDakNwUixLQUFLLENBQUMsOEVBQThFLEVBQUUsT0FBT29SLFdBQVcsQ0FBQyxDQUFDO0lBQzVHO0FBQ0Y7QUFFQSxzR0FBc0csR0FDdEcsTUFBTXRCLGtCQUFrQixDQUFDO0FBRXpCOzs7O0NBSUMsR0FDREEsZ0JBQWdCdUIsSUFBSSxHQUFHdkIsZ0JBQWdCd0IsS0FBSyxHQUFHeEIsZ0JBQWdCeUIsUUFBUSxHQUFHekIsZ0JBQWdCMEIsTUFBTSxHQUFHMUIsZ0JBQWdCMkIsR0FBRyxHQUFHM0IsZ0JBQWdCNEIsR0FBRyxHQUFHNUIsZ0JBQWdCNkIsTUFBTSxHQUFHN0IsZ0JBQWdCOEIsSUFBSSxHQUFHOUIsZUFBZSxDQUFDLGlCQUFpQixHQUFHQSxnQkFBZ0IrQixJQUFJLEdBQUcvQixnQkFBZ0JnQyxJQUFJLEdBQUdoQyxnQkFBZ0JpQyxLQUFLLEdBQUcsNkVBQTZFLEdBQ3RYLENBQUM5SyxPQUFPYjtJQUNOK0ssc0JBQXNCbEssT0FBT2IsT0FBT2dMLFVBQVU7SUFDOUNULGNBQWMxSixPQUFPQSxPQUFPYjtJQUM1Qm9LLG9CQUFvQnZKLE9BQU9iO0lBQzNCYSxNQUFNRSxJQUFJLEdBQUdmLE9BQU9hLEtBQUs7SUFDekIsT0FBT0E7QUFDVDtBQUVBOzs7O0NBSUMsR0FDRDZJLGdCQUFnQnBGLElBQUksR0FBRyxDQUFDekQsT0FBT2I7SUFDN0J1SyxjQUFjMUosT0FBT0EsT0FBT2I7SUFDNUJvSyxvQkFBb0J2SixPQUFPYjtJQUMzQixPQUFPYTtBQUNUO0FBRUE7Ozs7Q0FJQyxHQUNENkksZ0JBQWdCOUksS0FBSyxHQUFHLENBQUNBLE9BQU9aO0lBQzlCLE1BQU00TCxhQUFhaEwsTUFBTTVGLGFBQWEsQ0FBQztJQUN2QyxNQUFNa0ssY0FBY3RFLE1BQU01RixhQUFhLENBQUM7SUFDeEMrUCxzQkFBc0JhLFlBQVk1TCxPQUFPZ0wsVUFBVTtJQUNuRFksV0FBVzdLLElBQUksR0FBR2YsT0FBT2EsS0FBSztJQUM5QmtLLHNCQUFzQjdGLGFBQWFsRixPQUFPZ0wsVUFBVTtJQUNwRFQsY0FBY3FCLFlBQVloTCxPQUFPWjtJQUNqQyxPQUFPWTtBQUNUO0FBRUE7Ozs7Q0FJQyxHQUNEOEksZ0JBQWdCbkYsTUFBTSxHQUFHLENBQUNBLFFBQVF2RTtJQUNoQ3VFLE9BQU96RixXQUFXLEdBQUc7SUFDckIsSUFBSWtCLE9BQU9zSyxnQkFBZ0IsRUFBRTtRQUMzQixNQUFNRCxjQUFjdFMsU0FBUytOLGFBQWEsQ0FBQztRQUMzQ25ILGFBQWEwTCxhQUFhckssT0FBT3NLLGdCQUFnQjtRQUNqREQsWUFBWXBKLEtBQUssR0FBRztRQUNwQm9KLFlBQVl3QixRQUFRLEdBQUc7UUFDdkJ4QixZQUFZeUIsUUFBUSxHQUFHO1FBQ3ZCdkgsT0FBT2hGLFdBQVcsQ0FBQzhLO0lBQ3JCO0lBQ0FFLGNBQWNoRyxRQUFRQSxRQUFRdkU7SUFDOUIsT0FBT3VFO0FBQ1Q7QUFFQTs7O0NBR0MsR0FDRG1GLGdCQUFnQi9JLEtBQUssR0FBR0EsQ0FBQUE7SUFDdEJBLE1BQU03QixXQUFXLEdBQUc7SUFDcEIsT0FBTzZCO0FBQ1Q7QUFFQTs7OztDQUlDLEdBQ0QrSSxnQkFBZ0JoSixRQUFRLEdBQUcsQ0FBQ3FMLG1CQUFtQi9MO0lBQzdDLE1BQU1VLFdBQVdGLFdBQVduRixZQUFZO0lBQ3hDcUYsU0FBU08sS0FBSyxHQUFHO0lBQ2pCUCxTQUFTc0wsT0FBTyxHQUFHM0ssUUFBUXJCLE9BQU9nTCxVQUFVO0lBQzVDLE1BQU14RyxRQUFRdUgsa0JBQWtCL1EsYUFBYSxDQUFDO0lBQzlDMkQsYUFBYTZGLE9BQU94RSxPQUFPc0ssZ0JBQWdCLElBQUl0SyxPQUFPeUssVUFBVTtJQUNoRSxPQUFPL0o7QUFDVDtBQUVBOzs7O0NBSUMsR0FDRGdKLGdCQUFnQmpGLFFBQVEsR0FBRyxDQUFDQSxVQUFVekU7SUFDcEMrSyxzQkFBc0J0RyxVQUFVekUsT0FBT2dMLFVBQVU7SUFDakRaLG9CQUFvQjNGLFVBQVV6RTtJQUM5QnVLLGNBQWM5RixVQUFVQSxVQUFVekU7SUFFbEM7OztHQUdDLEdBQ0QsTUFBTWlNLFlBQVlqTyxDQUFBQSxLQUFNTixTQUFTcEYsT0FBTytLLGdCQUFnQixDQUFDckYsSUFBSWtPLFVBQVUsSUFBSXhPLFNBQVNwRixPQUFPK0ssZ0JBQWdCLENBQUNyRixJQUFJbU8sV0FBVztJQUUzSCx5REFBeUQ7SUFDekR4VCxXQUFXO1FBQ1QseURBQXlEO1FBQ3pELElBQUksc0JBQXNCTCxRQUFRO1lBQ2hDLE1BQU04VCxvQkFBb0IxTyxTQUFTcEYsT0FBTytLLGdCQUFnQixDQUFDaEksWUFBWTBJLEtBQUs7WUFDNUUsTUFBTXNJLHdCQUF3QjtnQkFDNUIsbUZBQW1GO2dCQUNuRixJQUFJLENBQUN0VSxTQUFTQyxJQUFJLENBQUM4SCxRQUFRLENBQUMyRSxXQUFXO29CQUNyQztnQkFDRjtnQkFDQSxNQUFNNkgsZ0JBQWdCN0gsU0FBUzVCLFdBQVcsR0FBR29KLFVBQVV4SDtnQkFDdkQsSUFBSTZILGdCQUFnQkYsbUJBQW1CO29CQUNyQy9RLFdBQVd3RyxLQUFLLENBQUNrQyxLQUFLLEdBQUcsQ0FBQyxFQUFFdUksY0FBYyxFQUFFLENBQUM7Z0JBQy9DLE9BQU87b0JBQ0wzSyxvQkFBb0J0RyxZQUFZLFNBQVMyRSxPQUFPK0QsS0FBSztnQkFDdkQ7WUFDRjtZQUNBLElBQUkzQixpQkFBaUJpSyx1QkFBdUI5SixPQUFPLENBQUNrQyxVQUFVO2dCQUM1RHNGLFlBQVk7Z0JBQ1p3QyxpQkFBaUI7b0JBQUM7aUJBQVE7WUFDNUI7UUFDRjtJQUNGO0lBQ0EsT0FBTzlIO0FBQ1Q7QUFFQTs7O0NBR0MsR0FDRCxNQUFNK0gsZ0JBQWdCLENBQUM5RixVQUFVMUc7SUFDL0IsTUFBTXlNLGdCQUFnQjlRO0lBQ3RCLElBQUksQ0FBQzhRLGVBQWU7UUFDbEI7SUFDRjtJQUNBdEsseUJBQXlCc0s7SUFDekJwTSxpQkFBaUJvTSxlQUFlek0sUUFBUTtJQUV4QyxrQkFBa0I7SUFDbEIsSUFBSUEsT0FBT25CLElBQUksRUFBRTtRQUNma0gscUJBQXFCL0YsT0FBT25CLElBQUksRUFBRTROO1FBQ2xDekssS0FBS3lLLGVBQWU7SUFDdEIsT0FHSyxJQUFJek0sT0FBT2lMLElBQUksRUFBRTtRQUNwQndCLGNBQWMzTixXQUFXLEdBQUdrQixPQUFPaUwsSUFBSTtRQUN2Q2pKLEtBQUt5SyxlQUFlO0lBQ3RCLE9BR0s7UUFDSHZLLEtBQUt1SztJQUNQO0lBQ0F0RCxZQUFZekMsVUFBVTFHO0FBQ3hCO0FBRUE7OztDQUdDLEdBQ0QsTUFBTTBNLGVBQWUsQ0FBQ2hHLFVBQVUxRztJQUM5QixNQUFNcEQsU0FBU0Q7SUFDZixJQUFJLENBQUNDLFFBQVE7UUFDWDtJQUNGO0lBQ0F1Rix5QkFBeUJ2RjtJQUN6QnlGLE9BQU96RixRQUFRb0QsT0FBT3BELE1BQU0sRUFBRTtJQUM5QixJQUFJb0QsT0FBT3BELE1BQU0sRUFBRTtRQUNqQm1KLHFCQUFxQi9GLE9BQU9wRCxNQUFNLEVBQUVBO0lBQ3RDO0lBRUEsZUFBZTtJQUNmeUQsaUJBQWlCekQsUUFBUW9ELFFBQVE7QUFDbkM7QUFFQTs7O0NBR0MsR0FDRCxNQUFNMk0sYUFBYSxDQUFDakcsVUFBVTFHO0lBQzVCLE1BQU0rSSxjQUFjRCxhQUFhQyxXQUFXLENBQUMzUixHQUFHLENBQUNzUDtJQUNqRCxNQUFNck4sT0FBT2tDO0lBQ2IsSUFBSSxDQUFDbEMsTUFBTTtRQUNUO0lBQ0Y7SUFFQSxzRkFBc0Y7SUFDdEYsSUFBSTBQLGVBQWUvSSxPQUFPM0csSUFBSSxLQUFLMFAsWUFBWTFQLElBQUksRUFBRTtRQUNuRCw0QkFBNEI7UUFDNUJ1VCxXQUFXdlQsTUFBTTJHO1FBQ2pCNk0sWUFBWXhULE1BQU0yRztRQUNsQjtJQUNGO0lBQ0EsSUFBSSxDQUFDQSxPQUFPM0csSUFBSSxJQUFJLENBQUMyRyxPQUFPOE0sUUFBUSxFQUFFO1FBQ3BDNUssS0FBSzdJO1FBQ0w7SUFDRjtJQUNBLElBQUkyRyxPQUFPM0csSUFBSSxJQUFJNEcsT0FBTzBKLElBQUksQ0FBQ3ZRLFdBQVcyVCxPQUFPLENBQUMvTSxPQUFPM0csSUFBSSxNQUFNLENBQUMsR0FBRztRQUNyRVcsTUFBTSxDQUFDLGlGQUFpRixFQUFFZ0csT0FBTzNHLElBQUksQ0FBQyxDQUFDLENBQUM7UUFDeEc2SSxLQUFLN0k7UUFDTDtJQUNGO0lBQ0EySSxLQUFLM0k7SUFFTCw0QkFBNEI7SUFDNUJ1VCxXQUFXdlQsTUFBTTJHO0lBQ2pCNk0sWUFBWXhULE1BQU0yRztJQUVsQixlQUFlO0lBQ2ZPLFNBQVNsSCxNQUFNMkcsT0FBT0csU0FBUyxJQUFJSCxPQUFPRyxTQUFTLENBQUM5RyxJQUFJO0FBQzFEO0FBRUE7OztDQUdDLEdBQ0QsTUFBTXdULGNBQWMsQ0FBQ3hULE1BQU0yRztJQUN6QixLQUFLLE1BQU0sQ0FBQ2dOLFVBQVVDLGNBQWMsSUFBSWhOLE9BQU9pTixPQUFPLENBQUM5VCxXQUFZO1FBQ2pFLElBQUk0RyxPQUFPM0csSUFBSSxLQUFLMlQsVUFBVTtZQUM1QnhMLFlBQVluSSxNQUFNNFQ7UUFDcEI7SUFDRjtJQUNBMU0sU0FBU2xILE1BQU0yRyxPQUFPM0csSUFBSSxJQUFJRCxTQUFTLENBQUM0RyxPQUFPM0csSUFBSSxDQUFDO0lBRXBELGFBQWE7SUFDYjhULFNBQVM5VCxNQUFNMkc7SUFFZixnQ0FBZ0M7SUFDaENvTjtJQUVBLGVBQWU7SUFDZi9NLGlCQUFpQmhILE1BQU0yRyxRQUFRO0FBQ2pDO0FBRUEsMkVBQTJFO0FBQzNFLE1BQU1vTixtQ0FBbUM7SUFDdkMsTUFBTTlSLFFBQVFEO0lBQ2QsSUFBSSxDQUFDQyxPQUFPO1FBQ1Y7SUFDRjtJQUNBLE1BQU0rUix1QkFBdUIvVSxPQUFPK0ssZ0JBQWdCLENBQUMvSCxPQUFPa0ksZ0JBQWdCLENBQUM7SUFDN0Usb0NBQW9DLEdBQ3BDLE1BQU04SixtQkFBbUJoUyxNQUFNNkIsZ0JBQWdCLENBQUM7SUFDaEQsSUFBSyxJQUFJMEMsSUFBSSxHQUFHQSxJQUFJeU4saUJBQWlCeFcsTUFBTSxFQUFFK0ksSUFBSztRQUNoRHlOLGdCQUFnQixDQUFDek4sRUFBRSxDQUFDZ0MsS0FBSyxDQUFDNkYsZUFBZSxHQUFHMkY7SUFDOUM7QUFDRjtBQUNBLE1BQU1FLGtCQUFrQixDQUFDOzs7OztBQUt6QixDQUFDO0FBQ0QsTUFBTUMsZ0JBQWdCLENBQUM7Ozs7O0FBS3ZCLENBQUM7QUFFRDs7O0NBR0MsR0FDRCxNQUFNWixhQUFhLENBQUN2VCxNQUFNMkc7SUFDeEIsSUFBSSxDQUFDQSxPQUFPM0csSUFBSSxJQUFJLENBQUMyRyxPQUFPOE0sUUFBUSxFQUFFO1FBQ3BDO0lBQ0Y7SUFDQSxJQUFJVyxhQUFhcFUsS0FBS2lKLFNBQVM7SUFDL0IsSUFBSW9MLGFBQWE7SUFDakIsSUFBSTFOLE9BQU84TSxRQUFRLEVBQUU7UUFDbkJZLGFBQWFDLFlBQVkzTixPQUFPOE0sUUFBUTtJQUMxQyxPQUFPLElBQUk5TSxPQUFPM0csSUFBSSxLQUFLLFdBQVc7UUFDcENxVSxhQUFhSDtRQUNiRSxhQUFhQSxXQUFXL0ksT0FBTyxDQUFDLGlCQUFpQixLQUFLLDBDQUEwQztJQUNsRyxPQUFPLElBQUkxRSxPQUFPM0csSUFBSSxLQUFLLFNBQVM7UUFDbENxVSxhQUFhRjtJQUNmLE9BQU8sSUFBSXhOLE9BQU8zRyxJQUFJLEVBQUU7UUFDdEIsTUFBTXVVLGtCQUFrQjtZQUN0QkMsVUFBVTtZQUNWQyxTQUFTO1lBQ1RDLE1BQU07UUFDUjtRQUNBTCxhQUFhQyxZQUFZQyxlQUFlLENBQUM1TixPQUFPM0csSUFBSSxDQUFDO0lBQ3ZEO0lBQ0EsSUFBSW9VLFdBQVdPLElBQUksT0FBT04sV0FBV00sSUFBSSxJQUFJO1FBQzNDclAsYUFBYXRGLE1BQU1xVTtJQUNyQjtBQUNGO0FBRUE7OztDQUdDLEdBQ0QsTUFBTVAsV0FBVyxDQUFDOVQsTUFBTTJHO0lBQ3RCLElBQUksQ0FBQ0EsT0FBT2lPLFNBQVMsRUFBRTtRQUNyQjtJQUNGO0lBQ0E1VSxLQUFLd0ksS0FBSyxDQUFDcU0sS0FBSyxHQUFHbE8sT0FBT2lPLFNBQVM7SUFDbkM1VSxLQUFLd0ksS0FBSyxDQUFDc00sV0FBVyxHQUFHbk8sT0FBT2lPLFNBQVM7SUFDekMsS0FBSyxNQUFNRyxPQUFPO1FBQUM7UUFBMkI7UUFBNEI7UUFBMkI7S0FBMkIsQ0FBRTtRQUNoSTFMLFNBQVNySixNQUFNK1UsS0FBSyxvQkFBb0JwTyxPQUFPaU8sU0FBUztJQUMxRDtJQUNBdkwsU0FBU3JKLE1BQU0sdUJBQXVCLGdCQUFnQjJHLE9BQU9pTyxTQUFTO0FBQ3hFO0FBRUE7OztDQUdDLEdBQ0QsTUFBTU4sY0FBY1UsQ0FBQUEsVUFBVyxDQUFDLFlBQVksRUFBRXRWLFdBQVcsQ0FBQyxlQUFlLENBQUMsRUFBRSxFQUFFc1YsUUFBUSxNQUFNLENBQUM7QUFFN0Y7OztDQUdDLEdBQ0QsTUFBTUMsY0FBYyxDQUFDNUgsVUFBVTFHO0lBQzdCLE1BQU1uRSxRQUFRRDtJQUNkLElBQUksQ0FBQ0MsT0FBTztRQUNWO0lBQ0Y7SUFDQSxJQUFJLENBQUNtRSxPQUFPdU8sUUFBUSxFQUFFO1FBQ3BCck0sS0FBS3JHO1FBQ0w7SUFDRjtJQUNBbUcsS0FBS25HLE9BQU87SUFFWixXQUFXO0lBQ1hBLE1BQU0wSixZQUFZLENBQUMsT0FBT3ZGLE9BQU91TyxRQUFRO0lBQ3pDMVMsTUFBTTBKLFlBQVksQ0FBQyxPQUFPdkYsT0FBT3dPLFFBQVEsSUFBSTtJQUU3QyxnQkFBZ0I7SUFDaEI3TSxvQkFBb0I5RixPQUFPLFNBQVNtRSxPQUFPeU8sVUFBVTtJQUNyRDlNLG9CQUFvQjlGLE9BQU8sVUFBVW1FLE9BQU8wTyxXQUFXO0lBRXZELFFBQVE7SUFDUjdTLE1BQU0zQyxTQUFTLEdBQUdILFlBQVk4QyxLQUFLO0lBQ25Dd0UsaUJBQWlCeEUsT0FBT21FLFFBQVE7QUFDbEM7QUFFQTs7O0NBR0MsR0FDRCxNQUFNMk8sY0FBYyxDQUFDakksVUFBVTFHO0lBQzdCLE1BQU0vRSxZQUFZRjtJQUNsQixNQUFNTyxRQUFRRDtJQUNkLElBQUksQ0FBQ0osYUFBYSxDQUFDSyxPQUFPO1FBQ3hCO0lBQ0Y7SUFFQSxRQUFRO0lBQ1IseURBQXlEO0lBQ3pELElBQUkwRSxPQUFPeEIsS0FBSyxFQUFFO1FBQ2hCbUQsb0JBQW9CMUcsV0FBVyxTQUFTK0UsT0FBTytELEtBQUs7UUFDcER6SSxNQUFNdUcsS0FBSyxDQUFDa0MsS0FBSyxHQUFHO1FBQ3BCLE1BQU10SCxTQUFTRDtRQUNmLElBQUlDLFFBQVE7WUFDVm5CLE1BQU1nTSxZQUFZLENBQUM3SyxRQUFRbEI7UUFDN0I7SUFDRixPQUFPO1FBQ0xvRyxvQkFBb0JyRyxPQUFPLFNBQVMwRSxPQUFPK0QsS0FBSztJQUNsRDtJQUVBLFVBQVU7SUFDVnBDLG9CQUFvQnJHLE9BQU8sV0FBVzBFLE9BQU80TyxPQUFPO0lBRXBELFFBQVE7SUFDUixJQUFJNU8sT0FBT2tPLEtBQUssRUFBRTtRQUNoQjVTLE1BQU11RyxLQUFLLENBQUNxTSxLQUFLLEdBQUdsTyxPQUFPa08sS0FBSztJQUNsQztJQUVBLGFBQWE7SUFDYixJQUFJbE8sT0FBTzRJLFVBQVUsRUFBRTtRQUNyQnROLE1BQU11RyxLQUFLLENBQUMrRyxVQUFVLEdBQUc1SSxPQUFPNEksVUFBVTtJQUM1QztJQUNBMUcsS0FBS25HO0lBRUwsVUFBVTtJQUNWOFMsYUFBYXZULE9BQU8wRTtBQUN0QjtBQUVBOzs7Q0FHQyxHQUNELE1BQU02TyxlQUFlLENBQUN2VCxPQUFPMEU7SUFDM0IsTUFBTUcsWUFBWUgsT0FBT0csU0FBUyxJQUFJLENBQUM7SUFDdkMsMERBQTBEO0lBQzFEN0UsTUFBTXBDLFNBQVMsR0FBRyxDQUFDLEVBQUVILFlBQVl1QyxLQUFLLENBQUMsQ0FBQyxFQUFFNkMsWUFBWTdDLFNBQVM2RSxVQUFVN0UsS0FBSyxHQUFHLEdBQUcsQ0FBQztJQUNyRixJQUFJMEUsT0FBT3hCLEtBQUssRUFBRTtRQUNoQitCLFNBQVM7WUFBQ3hJLFNBQVM4TSxlQUFlO1lBQUU5TSxTQUFTQyxJQUFJO1NBQUMsRUFBRWUsV0FBVyxDQUFDLGNBQWM7UUFDOUV3SCxTQUFTakYsT0FBT3ZDLFlBQVl5RixLQUFLO0lBQ25DLE9BQU87UUFDTCtCLFNBQVNqRixPQUFPdkMsWUFBWStWLEtBQUs7SUFDbkM7SUFFQSxlQUFlO0lBQ2Z6TyxpQkFBaUIvRSxPQUFPMEUsUUFBUTtJQUNoQyxpQ0FBaUM7SUFDakMsSUFBSSxPQUFPQSxPQUFPTSxXQUFXLEtBQUssVUFBVTtRQUMxQ0MsU0FBU2pGLE9BQU8wRSxPQUFPTSxXQUFXO0lBQ3BDO0lBRUEscUJBQXFCO0lBQ3JCLElBQUlOLE9BQU8zRyxJQUFJLEVBQUU7UUFDZmtILFNBQVNqRixPQUFPdkMsV0FBVyxDQUFDLENBQUMsS0FBSyxFQUFFaUgsT0FBTzNHLElBQUksQ0FBQyxDQUFDLENBQUM7SUFDcEQ7QUFDRjtBQUVBOzs7Q0FHQyxHQUNELE1BQU0wVixzQkFBc0IsQ0FBQ3JJLFVBQVUxRztJQUNyQyxNQUFNZ1AseUJBQXlCbFQ7SUFDL0IsSUFBSSxDQUFDa1Qsd0JBQXdCO1FBQzNCO0lBQ0Y7SUFDQSxNQUFNLEVBQ0pDLGFBQWEsRUFDYkMsbUJBQW1CLEVBQ3BCLEdBQUdsUDtJQUNKLElBQUksQ0FBQ2lQLGlCQUFpQkEsY0FBY25ZLE1BQU0sS0FBSyxLQUFLb1ksd0JBQXdCMVUsV0FBVztRQUNyRjBILEtBQUs4TTtRQUNMO0lBQ0Y7SUFDQWhOLEtBQUtnTjtJQUNMQSx1QkFBdUJsUSxXQUFXLEdBQUc7SUFDckMsSUFBSW9RLHVCQUF1QkQsY0FBY25ZLE1BQU0sRUFBRTtRQUMvQzhDLEtBQUssd0ZBQXdGO0lBQy9GO0lBQ0FxVixjQUFjNVAsT0FBTyxDQUFDLENBQUM4UCxNQUFNQztRQUMzQixNQUFNQyxTQUFTQyxrQkFBa0JIO1FBQ2pDSCx1QkFBdUJ6UCxXQUFXLENBQUM4UDtRQUNuQyxJQUFJRCxVQUFVRixxQkFBcUI7WUFDakMzTyxTQUFTOE8sUUFBUXRXLFdBQVcsQ0FBQyx1QkFBdUI7UUFDdEQ7UUFDQSxJQUFJcVcsVUFBVUgsY0FBY25ZLE1BQU0sR0FBRyxHQUFHO1lBQ3RDLE1BQU15WSxTQUFTQyxrQkFBa0J4UDtZQUNqQ2dQLHVCQUF1QnpQLFdBQVcsQ0FBQ2dRO1FBQ3JDO0lBQ0Y7QUFDRjtBQUVBOzs7Q0FHQyxHQUNELE1BQU1ELG9CQUFvQkgsQ0FBQUE7SUFDeEIsTUFBTUUsU0FBU3RYLFNBQVMrTixhQUFhLENBQUM7SUFDdEN2RixTQUFTOE8sUUFBUXRXLFdBQVcsQ0FBQyxnQkFBZ0I7SUFDN0M0RixhQUFhMFEsUUFBUUY7SUFDckIsT0FBT0U7QUFDVDtBQUVBOzs7Q0FHQyxHQUNELE1BQU1HLG9CQUFvQnhQLENBQUFBO0lBQ3hCLE1BQU11UCxTQUFTeFgsU0FBUytOLGFBQWEsQ0FBQztJQUN0Q3ZGLFNBQVNnUCxRQUFReFcsV0FBVyxDQUFDLHFCQUFxQjtJQUNsRCxJQUFJaUgsT0FBT3lQLHFCQUFxQixFQUFFO1FBQ2hDOU4sb0JBQW9CNE4sUUFBUSxTQUFTdlAsT0FBT3lQLHFCQUFxQjtJQUNuRTtJQUNBLE9BQU9GO0FBQ1Q7QUFFQTs7O0NBR0MsR0FDRCxNQUFNRyxjQUFjLENBQUNoSixVQUFVMUc7SUFDN0IsTUFBTXRFLFFBQVFEO0lBQ2QsSUFBSSxDQUFDQyxPQUFPO1FBQ1Y7SUFDRjtJQUNBeUcseUJBQXlCekc7SUFDekIyRyxPQUFPM0csT0FBT3NFLE9BQU90RSxLQUFLLElBQUlzRSxPQUFPMlAsU0FBUyxFQUFFO0lBQ2hELElBQUkzUCxPQUFPdEUsS0FBSyxFQUFFO1FBQ2hCcUsscUJBQXFCL0YsT0FBT3RFLEtBQUssRUFBRUE7SUFDckM7SUFDQSxJQUFJc0UsT0FBTzJQLFNBQVMsRUFBRTtRQUNwQmpVLE1BQU1rUCxTQUFTLEdBQUc1SyxPQUFPMlAsU0FBUztJQUNwQztJQUVBLGVBQWU7SUFDZnRQLGlCQUFpQjNFLE9BQU9zRSxRQUFRO0FBQ2xDO0FBRUE7OztDQUdDLEdBQ0QsTUFBTTRQLFNBQVMsQ0FBQ2xKLFVBQVUxRztJQUN4QjJPLFlBQVlqSSxVQUFVMUc7SUFDdEJxSSxnQkFBZ0IzQixVQUFVMUc7SUFDMUIrTyxvQkFBb0JySSxVQUFVMUc7SUFDOUIyTSxXQUFXakcsVUFBVTFHO0lBQ3JCc08sWUFBWTVILFVBQVUxRztJQUN0QjBQLFlBQVloSixVQUFVMUc7SUFDdEJnSSxrQkFBa0J0QixVQUFVMUc7SUFDNUJ3TSxjQUFjOUYsVUFBVTFHO0lBQ3hCeUcsY0FBY0MsVUFBVTFHO0lBQ3hCME0sYUFBYWhHLFVBQVUxRztJQUN2QixNQUFNMUUsUUFBUUQ7SUFDZCxJQUFJLE9BQU8yRSxPQUFPNlAsU0FBUyxLQUFLLGNBQWN2VSxPQUFPO1FBQ25EMEUsT0FBTzZQLFNBQVMsQ0FBQ3ZVO0lBQ25CO0lBQ0E1RCxZQUFZb1ksWUFBWSxDQUFDQyxJQUFJLENBQUMsYUFBYXpVO0FBQzdDO0FBRUE7O0NBRUMsR0FDRCxNQUFNMFUsWUFBWTtJQUNoQixPQUFPN1IsWUFBWTlDO0FBQ3JCO0FBRUE7O0NBRUMsR0FDRCxNQUFNNFUsZUFBZTtJQUNuQixJQUFJQztJQUNKLE9BQU8sQ0FBQ0Esd0JBQXdCbFUsa0JBQWlCLE1BQU8sUUFBUWtVLDBCQUEwQixLQUFLLElBQUksS0FBSyxJQUFJQSxzQkFBc0JDLEtBQUs7QUFDekk7QUFFQTs7Q0FFQyxHQUNELE1BQU1DLFlBQVk7SUFDaEIsSUFBSUM7SUFDSixPQUFPLENBQUNBLHFCQUFxQmhVLGVBQWMsTUFBTyxRQUFRZ1UsdUJBQXVCLEtBQUssSUFBSSxLQUFLLElBQUlBLG1CQUFtQkYsS0FBSztBQUM3SDtBQUVBOztDQUVDLEdBQ0QsTUFBTUcsY0FBYztJQUNsQixJQUFJQztJQUNKLE9BQU8sQ0FBQ0EsdUJBQXVCcFUsaUJBQWdCLE1BQU8sUUFBUW9VLHlCQUF5QixLQUFLLElBQUksS0FBSyxJQUFJQSxxQkFBcUJKLEtBQUs7QUFDckk7QUFFQSwrRUFBK0UsR0FFL0UsaURBQWlELEdBQ2pELE1BQU1LLGdCQUFnQnZRLE9BQU93USxNQUFNLENBQUM7SUFDbENyVSxRQUFRO0lBQ1JtTSxVQUFVO0lBQ1Z4TCxPQUFPO0lBQ1AyVCxLQUFLO0lBQ0wvTSxPQUFPO0FBQ1Q7QUFFQTs7Q0FFQyxHQUNELE1BQU1nTix1QkFBdUJqWixDQUFBQTtJQUMzQixJQUFJQSxZQUFZa1osYUFBYSxJQUFJbFosWUFBWW1aLG1CQUFtQixFQUFFO1FBQ2hFblosWUFBWWtaLGFBQWEsQ0FBQ0UsbUJBQW1CLENBQUMsV0FBV3BaLFlBQVlxWixjQUFjLEVBQUU7WUFDbkZDLFNBQVN0WixZQUFZdVosc0JBQXNCO1FBQzdDO1FBQ0F2WixZQUFZbVosbUJBQW1CLEdBQUc7SUFDcEM7QUFDRjtBQUVBOzs7O0NBSUMsR0FDRCxNQUFNSyxvQkFBb0IsQ0FBQ3haLGFBQWFxUixhQUFhb0k7SUFDbkRSLHFCQUFxQmpaO0lBQ3JCLElBQUksQ0FBQ3FSLFlBQVl2SyxLQUFLLEVBQUU7UUFDdEI5RyxZQUFZcVosY0FBYyxHQUFHdGEsQ0FBQUEsSUFBS3NhLGVBQWVoSSxhQUFhdFMsR0FBRzBhO1FBQ2pFelosWUFBWWtaLGFBQWEsR0FBRzdILFlBQVlrSSxzQkFBc0IsR0FBRzNZLFNBQVMrQztRQUMxRTNELFlBQVl1WixzQkFBc0IsR0FBR2xJLFlBQVlrSSxzQkFBc0I7UUFDdkV2WixZQUFZa1osYUFBYSxDQUFDUSxnQkFBZ0IsQ0FBQyxXQUFXMVosWUFBWXFaLGNBQWMsRUFBRTtZQUNoRkMsU0FBU3RaLFlBQVl1WixzQkFBc0I7UUFDN0M7UUFDQXZaLFlBQVltWixtQkFBbUIsR0FBRztJQUNwQztBQUNGO0FBRUE7OztDQUdDLEdBQ0QsTUFBTVEsV0FBVyxDQUFDakMsT0FBT2tDO0lBQ3ZCLElBQUlDO0lBQ0osTUFBTUMsb0JBQW9CdlU7SUFDMUIsaUVBQWlFO0lBQ2pFLElBQUl1VSxrQkFBa0IxYSxNQUFNLEVBQUU7UUFDNUJzWSxRQUFRQSxRQUFRa0M7UUFFaEIseUJBQXlCO1FBQ3pCLElBQUlsQyxVQUFVb0Msa0JBQWtCMWEsTUFBTSxFQUFFO1lBQ3RDc1ksUUFBUTtRQUVSLGtCQUFrQjtRQUNwQixPQUFPLElBQUlBLFVBQVUsQ0FBQyxHQUFHO1lBQ3ZCQSxRQUFRb0Msa0JBQWtCMWEsTUFBTSxHQUFHO1FBQ3JDO1FBQ0EwYSxpQkFBaUIsQ0FBQ3BDLE1BQU0sQ0FBQ3RYLEtBQUs7UUFDOUI7SUFDRjtJQUNBLGlEQUFpRDtJQUNoRHlaLENBQUFBLGdCQUFnQmxXLFVBQVMsTUFBTyxRQUFRa1csa0JBQWtCLEtBQUssS0FBS0EsY0FBY3paLEtBQUs7QUFDMUY7QUFDQSxNQUFNMlosc0JBQXNCO0lBQUM7SUFBYztDQUFZO0FBQ3ZELE1BQU1DLDBCQUEwQjtJQUFDO0lBQWE7Q0FBVTtBQUV4RDs7OztDQUlDLEdBQ0QsTUFBTVgsaUJBQWlCLENBQUNoSSxhQUFhNEksT0FBT1I7SUFDMUMsSUFBSSxDQUFDcEksYUFBYTtRQUNoQixRQUFRLDJDQUEyQztJQUNyRDtJQUVBLHdDQUF3QztJQUN4QyxrSEFBa0g7SUFDbEgsd0RBQXdEO0lBQ3hELHlEQUF5RDtJQUN6RCxJQUFJNEksTUFBTUMsV0FBVyxJQUFJRCxNQUFNRSxPQUFPLEtBQUssS0FBSztRQUM5QztJQUNGO0lBQ0EsSUFBSTlJLFlBQVkrSSxzQkFBc0IsRUFBRTtRQUN0Q0gsTUFBTUksZUFBZTtJQUN2QjtJQUVBLFFBQVE7SUFDUixJQUFJSixNQUFNSyxHQUFHLEtBQUssU0FBUztRQUN6QkMsWUFBWU4sT0FBTzVJO0lBQ3JCLE9BR0ssSUFBSTRJLE1BQU1LLEdBQUcsS0FBSyxPQUFPO1FBQzVCRSxVQUFVUDtJQUNaLE9BR0ssSUFBSTtXQUFJRjtXQUF3QkM7S0FBd0IsQ0FBQ3ZYLFFBQVEsQ0FBQ3dYLE1BQU1LLEdBQUcsR0FBRztRQUNqRkcsYUFBYVIsTUFBTUssR0FBRztJQUN4QixPQUdLLElBQUlMLE1BQU1LLEdBQUcsS0FBSyxVQUFVO1FBQy9CSSxVQUFVVCxPQUFPNUksYUFBYW9JO0lBQ2hDO0FBQ0Y7QUFFQTs7O0NBR0MsR0FDRCxNQUFNYyxjQUFjLENBQUNOLE9BQU81STtJQUMxQix5REFBeUQ7SUFDekQsSUFBSSxDQUFDdE8sZUFBZXNPLFlBQVlzSixhQUFhLEdBQUc7UUFDOUM7SUFDRjtJQUNBLE1BQU14UixRQUFRTCxXQUFXbkYsWUFBWTBOLFlBQVlsSSxLQUFLO0lBQ3RELElBQUk4USxNQUFNeFEsTUFBTSxJQUFJTixTQUFTOFEsTUFBTXhRLE1BQU0sWUFBWXRKLGVBQWU4WixNQUFNeFEsTUFBTSxDQUFDbVIsU0FBUyxLQUFLelIsTUFBTXlSLFNBQVMsRUFBRTtRQUM5RyxJQUFJO1lBQUM7WUFBWTtTQUFPLENBQUNuWSxRQUFRLENBQUM0TyxZQUFZbEksS0FBSyxHQUFHO1lBQ3BELFFBQVEsZ0JBQWdCO1FBQzFCO1FBQ0FvUDtRQUNBMEIsTUFBTVksY0FBYztJQUN0QjtBQUNGO0FBRUE7O0NBRUMsR0FDRCxNQUFNTCxZQUFZUCxDQUFBQTtJQUNoQixNQUFNbE0sZ0JBQWdCa00sTUFBTXhRLE1BQU07SUFDbEMsTUFBTXFRLG9CQUFvQnZVO0lBQzFCLElBQUl1VixXQUFXLENBQUM7SUFDaEIsSUFBSyxJQUFJM1MsSUFBSSxHQUFHQSxJQUFJMlIsa0JBQWtCMWEsTUFBTSxFQUFFK0ksSUFBSztRQUNqRCxJQUFJNEYsa0JBQWtCK0wsaUJBQWlCLENBQUMzUixFQUFFLEVBQUU7WUFDMUMyUyxXQUFXM1M7WUFDWDtRQUNGO0lBQ0Y7SUFFQSwyQkFBMkI7SUFDM0IsSUFBSSxDQUFDOFIsTUFBTWMsUUFBUSxFQUFFO1FBQ25CcEIsU0FBU21CLFVBQVU7SUFDckIsT0FHSztRQUNIbkIsU0FBU21CLFVBQVUsQ0FBQztJQUN0QjtJQUNBYixNQUFNSSxlQUFlO0lBQ3JCSixNQUFNWSxjQUFjO0FBQ3RCO0FBRUE7O0NBRUMsR0FDRCxNQUFNSixlQUFlSCxDQUFBQTtJQUNuQixNQUFNL1YsVUFBVVM7SUFDaEIsTUFBTXNLLGdCQUFnQmhMO0lBQ3RCLE1BQU1pTCxhQUFhNUs7SUFDbkIsTUFBTTZLLGVBQWUvSztJQUNyQixJQUFJLENBQUNGLFdBQVcsQ0FBQytLLGlCQUFpQixDQUFDQyxjQUFjLENBQUNDLGNBQWM7UUFDOUQ7SUFDRjtJQUNBLHdCQUF3QixHQUN4QixNQUFNd0wsVUFBVTtRQUFDMUw7UUFBZUM7UUFBWUM7S0FBYTtJQUN6RCxJQUFJblAsU0FBUzRhLGFBQWEsWUFBWTlhLGVBQWUsQ0FBQzZhLFFBQVF2WSxRQUFRLENBQUNwQyxTQUFTNGEsYUFBYSxHQUFHO1FBQzlGO0lBQ0Y7SUFDQSxNQUFNQyxVQUFVbkIsb0JBQW9CdFgsUUFBUSxDQUFDNlgsT0FBTyx1QkFBdUI7SUFDM0UsSUFBSWEsZ0JBQWdCOWEsU0FBUzRhLGFBQWE7SUFDMUMsSUFBSSxDQUFDRSxlQUFlO1FBQ2xCO0lBQ0Y7SUFDQSxJQUFLLElBQUloVCxJQUFJLEdBQUdBLElBQUk1RCxRQUFReUYsUUFBUSxDQUFDNUssTUFBTSxFQUFFK0ksSUFBSztRQUNoRGdULGdCQUFnQkEsYUFBYSxDQUFDRCxRQUFRO1FBQ3RDLElBQUksQ0FBQ0MsZUFBZTtZQUNsQjtRQUNGO1FBQ0EsSUFBSUEseUJBQXlCQyxxQkFBcUIzVSxZQUFZMFUsZ0JBQWdCO1lBQzVFO1FBQ0Y7SUFDRjtJQUNBLElBQUlBLHlCQUF5QkMsbUJBQW1CO1FBQzlDRCxjQUFjL2EsS0FBSztJQUNyQjtBQUNGO0FBRUE7Ozs7Q0FJQyxHQUNELE1BQU1zYSxZQUFZLENBQUNULE9BQU81SSxhQUFhb0k7SUFDckMsSUFBSTFXLGVBQWVzTyxZQUFZZ0ssY0FBYyxHQUFHO1FBQzlDcEIsTUFBTVksY0FBYztRQUNwQnBCLFlBQVlYLGNBQWNFLEdBQUc7SUFDL0I7QUFDRjtBQUVBOzs7Ozs7OztDQVFDLEdBRUQsSUFBSXNDLGlCQUFpQjtJQUNuQkMsb0JBQW9CLElBQUlqSztJQUN4QmtLLG1CQUFtQixJQUFJbEs7QUFDekI7QUFFQSx5R0FBeUc7QUFDekcsd0ZBQXdGO0FBQ3hGLDRGQUE0RjtBQUM1Rix3RkFBd0Y7QUFFeEYsTUFBTW1LLGdCQUFnQjtJQUNwQixNQUFNbFksWUFBWUY7SUFDbEIsTUFBTXFZLGVBQWUvVixNQUFNQyxJQUFJLENBQUN2RixTQUFTQyxJQUFJLENBQUMwSixRQUFRO0lBQ3REMFIsYUFBYS9ULE9BQU8sQ0FBQ3JCLENBQUFBO1FBQ25CLElBQUlBLEdBQUc4QixRQUFRLENBQUM3RSxZQUFZO1lBQzFCO1FBQ0Y7UUFDQSxJQUFJK0MsR0FBR1UsWUFBWSxDQUFDLGdCQUFnQjtZQUNsQ1YsR0FBR3VILFlBQVksQ0FBQyw2QkFBNkJ2SCxHQUFHTCxZQUFZLENBQUMsa0JBQWtCO1FBQ2pGO1FBQ0FLLEdBQUd1SCxZQUFZLENBQUMsZUFBZTtJQUNqQztBQUNGO0FBQ0EsTUFBTThOLGtCQUFrQjtJQUN0QixNQUFNRCxlQUFlL1YsTUFBTUMsSUFBSSxDQUFDdkYsU0FBU0MsSUFBSSxDQUFDMEosUUFBUTtJQUN0RDBSLGFBQWEvVCxPQUFPLENBQUNyQixDQUFBQTtRQUNuQixJQUFJQSxHQUFHVSxZQUFZLENBQUMsOEJBQThCO1lBQ2hEVixHQUFHdUgsWUFBWSxDQUFDLGVBQWV2SCxHQUFHTCxZQUFZLENBQUMsZ0NBQWdDO1lBQy9FSyxHQUFHa00sZUFBZSxDQUFDO1FBQ3JCLE9BQU87WUFDTGxNLEdBQUdrTSxlQUFlLENBQUM7UUFDckI7SUFDRjtBQUNGO0FBRUEsYUFBYTtBQUNiLE1BQU1vSixnQkFBZ0IsTUFBa0IsSUFBZSxDQUFxQixFQUFFLGtGQUFrRjtBQUVoSzs7O0NBR0MsR0FDRCxNQUFNRSxTQUFTO0lBQ2IsSUFBSUYsaUJBQWlCLENBQUNqVixTQUFTdEcsU0FBU0MsSUFBSSxFQUFFZSxZQUFZMGEsTUFBTSxHQUFHO1FBQ2pFLE1BQU1DLFNBQVMzYixTQUFTQyxJQUFJLENBQUMyYixTQUFTO1FBQ3RDNWIsU0FBU0MsSUFBSSxDQUFDNkosS0FBSyxDQUFDK1IsR0FBRyxHQUFHLENBQUMsRUFBRUYsU0FBUyxDQUFDLEVBQUUsRUFBRSxDQUFDO1FBQzVDblQsU0FBU3hJLFNBQVNDLElBQUksRUFBRWUsWUFBWTBhLE1BQU07UUFDMUNJO0lBQ0Y7QUFDRjtBQUVBOztDQUVDLEdBQ0QsTUFBTUEsaUJBQWlCO0lBQ3JCLE1BQU01WSxZQUFZRjtJQUNsQixJQUFJLENBQUNFLFdBQVc7UUFDZDtJQUNGO0lBQ0Esb0JBQW9CLEdBQ3BCLElBQUk2WTtJQUNKOztHQUVDLEdBQ0Q3WSxVQUFVOFksWUFBWSxHQUFHcEMsQ0FBQUE7UUFDdkJtQyxtQkFBbUJFLHVCQUF1QnJDO0lBQzVDO0lBQ0E7O0dBRUMsR0FDRDFXLFVBQVVnWixXQUFXLEdBQUd0QyxDQUFBQTtRQUN0QixJQUFJbUMsa0JBQWtCO1lBQ3BCbkMsTUFBTVksY0FBYztZQUNwQlosTUFBTUksZUFBZTtRQUN2QjtJQUNGO0FBQ0Y7QUFFQTs7O0NBR0MsR0FDRCxNQUFNaUMseUJBQXlCckMsQ0FBQUE7SUFDN0IsTUFBTXhRLFNBQVN3USxNQUFNeFEsTUFBTTtJQUMzQixNQUFNbEcsWUFBWUY7SUFDbEIsTUFBTTBSLGdCQUFnQjlRO0lBQ3RCLElBQUksQ0FBQ1YsYUFBYSxDQUFDd1IsZUFBZTtRQUNoQyxPQUFPO0lBQ1Q7SUFDQSxJQUFJeUgsU0FBU3ZDLFVBQVV3QyxPQUFPeEMsUUFBUTtRQUNwQyxPQUFPO0lBQ1Q7SUFDQSxJQUFJeFEsV0FBV2xHLFdBQVc7UUFDeEIsT0FBTztJQUNUO0lBQ0EsSUFBSSxDQUFDZ0ksYUFBYWhJLGNBQWNrRyxrQkFBa0J0SixlQUFlc0osT0FBT2lULE9BQU8sS0FBSyxXQUNwRixRQUFRO0lBQ1JqVCxPQUFPaVQsT0FBTyxLQUFLLGNBQ25CLFFBQVE7SUFDUixDQUFFblIsQ0FBQUEsYUFBYXdKLGtCQUNmLFFBQVE7SUFDUkEsY0FBYzNNLFFBQVEsQ0FBQ3FCLE9BQU0sR0FBSTtRQUMvQixPQUFPO0lBQ1Q7SUFDQSxPQUFPO0FBQ1Q7QUFFQTs7Ozs7Q0FLQyxHQUNELE1BQU0rUyxXQUFXdkMsQ0FBQUE7SUFDZixPQUFPQSxNQUFNMEMsT0FBTyxJQUFJMUMsTUFBTTBDLE9BQU8sQ0FBQ3ZkLE1BQU0sSUFBSTZhLE1BQU0wQyxPQUFPLENBQUMsRUFBRSxDQUFDQyxTQUFTLEtBQUs7QUFDakY7QUFFQTs7Ozs7Q0FLQyxHQUNELE1BQU1ILFNBQVN4QyxDQUFBQTtJQUNiLE9BQU9BLE1BQU0wQyxPQUFPLElBQUkxQyxNQUFNMEMsT0FBTyxDQUFDdmQsTUFBTSxHQUFHO0FBQ2pEO0FBQ0EsTUFBTXlkLGFBQWE7SUFDakIsSUFBSWxXLFNBQVN0RyxTQUFTQyxJQUFJLEVBQUVlLFlBQVkwYSxNQUFNLEdBQUc7UUFDL0MsTUFBTUMsU0FBU2hXLFNBQVMzRixTQUFTQyxJQUFJLENBQUM2SixLQUFLLENBQUMrUixHQUFHLEVBQUU7UUFDakRwUyxZQUFZekosU0FBU0MsSUFBSSxFQUFFZSxZQUFZMGEsTUFBTTtRQUM3QzFiLFNBQVNDLElBQUksQ0FBQzZKLEtBQUssQ0FBQytSLEdBQUcsR0FBRztRQUMxQjdiLFNBQVNDLElBQUksQ0FBQzJiLFNBQVMsR0FBR0QsU0FBUyxDQUFDO0lBQ3RDO0FBQ0Y7QUFFQTs7Ozs7Q0FLQyxHQUNELE1BQU1jLG1CQUFtQjtJQUN2QixNQUFNQyxZQUFZMWMsU0FBUytOLGFBQWEsQ0FBQztJQUN6QzJPLFVBQVV2YixTQUFTLEdBQUdILFdBQVcsQ0FBQyxvQkFBb0I7SUFDdERoQixTQUFTQyxJQUFJLENBQUN1SCxXQUFXLENBQUNrVjtJQUMxQixNQUFNQyxpQkFBaUJELFVBQVVFLHFCQUFxQixHQUFHNVEsS0FBSyxHQUFHMFEsVUFBVUcsV0FBVztJQUN0RjdjLFNBQVNDLElBQUksQ0FBQzZjLFdBQVcsQ0FBQ0o7SUFDMUIsT0FBT0M7QUFDVDtBQUVBOzs7Q0FHQyxHQUNELElBQUlJLHNCQUFzQjtBQUUxQjs7Q0FFQyxHQUNELE1BQU1DLDhCQUE4QkMsQ0FBQUE7SUFDbEMsNENBQTRDO0lBQzVDLElBQUlGLHdCQUF3QixNQUFNO1FBQ2hDO0lBQ0Y7SUFDQSwyQkFBMkI7SUFDM0IsSUFBSS9jLFNBQVNDLElBQUksQ0FBQ2tMLFlBQVksR0FBRzVLLE9BQU8yYyxXQUFXLElBQUlELHdCQUF3QixTQUFTLHlEQUF5RDtNQUMvSTtRQUNBLHNFQUFzRTtRQUN0RUYsc0JBQXNCcFgsU0FBU3BGLE9BQU8rSyxnQkFBZ0IsQ0FBQ3RMLFNBQVNDLElBQUksRUFBRXdMLGdCQUFnQixDQUFDO1FBQ3ZGekwsU0FBU0MsSUFBSSxDQUFDNkosS0FBSyxDQUFDcVQsWUFBWSxHQUFHLENBQUMsRUFBRUosc0JBQXNCTixtQkFBbUIsRUFBRSxDQUFDO0lBQ3BGO0FBQ0Y7QUFDQSxNQUFNVyxrQ0FBa0M7SUFDdEMsSUFBSUwsd0JBQXdCLE1BQU07UUFDaEMvYyxTQUFTQyxJQUFJLENBQUM2SixLQUFLLENBQUNxVCxZQUFZLEdBQUcsQ0FBQyxFQUFFSixvQkFBb0IsRUFBRSxDQUFDO1FBQzdEQSxzQkFBc0I7SUFDeEI7QUFDRjtBQUVBOzs7OztDQUtDLEdBQ0QsU0FBU00seUJBQXlCMU8sUUFBUSxFQUFFekwsU0FBUyxFQUFFL0MsV0FBVyxFQUFFbWQsUUFBUTtJQUMxRSxJQUFJOVcsV0FBVztRQUNiK1csMEJBQTBCNU8sVUFBVTJPO0lBQ3RDLE9BQU87UUFDTHBkLHFCQUFxQkMsYUFBYXFkLElBQUksQ0FBQyxJQUFNRCwwQkFBMEI1TyxVQUFVMk87UUFDakYxRSxxQkFBcUJqWjtJQUN2QjtJQUVBLHdFQUF3RTtJQUN4RSxzRkFBc0Y7SUFDdEYsSUFBSTRiLGVBQWU7UUFDakJyWSxVQUFVc0ssWUFBWSxDQUFDLFNBQVM7UUFDaEN0SyxVQUFVaVAsZUFBZSxDQUFDO1FBQzFCalAsVUFBVXFILFNBQVMsR0FBRztJQUN4QixPQUFPO1FBQ0xySCxVQUFVbUYsTUFBTTtJQUNsQjtJQUNBLElBQUloQyxXQUFXO1FBQ2IrVztRQUNBWjtRQUNBbEI7SUFDRjtJQUNBbUM7QUFDRjtBQUVBOztDQUVDLEdBQ0QsU0FBU0E7SUFDUGhVLFlBQVk7UUFBQ3pKLFNBQVM4TSxlQUFlO1FBQUU5TSxTQUFTQyxJQUFJO0tBQUMsRUFBRTtRQUFDZSxZQUFZdUYsS0FBSztRQUFFdkYsV0FBVyxDQUFDLGNBQWM7UUFBRUEsV0FBVyxDQUFDLGNBQWM7UUFBRUEsV0FBVyxDQUFDLGNBQWM7S0FBQztBQUNoSztBQUVBOzs7O0NBSUMsR0FDRCxTQUFTZ0UsTUFBTTBZLFlBQVk7SUFDekJBLGVBQWVDLG9CQUFvQkQ7SUFDbkMsTUFBTXhDLHFCQUFxQkQsZUFBZUMsa0JBQWtCLENBQUM3YixHQUFHLENBQUMsSUFBSTtJQUNyRSxNQUFNaWUsV0FBV00sa0JBQWtCLElBQUk7SUFDdkMsSUFBSSxJQUFJLENBQUNDLGlCQUFpQixFQUFFO1FBQzFCLHFHQUFxRztRQUNyRyxJQUFJLENBQUNILGFBQWFJLFdBQVcsRUFBRTtZQUM3QkMsc0JBQXNCLElBQUk7WUFDMUI3QyxtQkFBbUJ3QztRQUNyQjtJQUNGLE9BQU8sSUFBSUosVUFBVTtRQUNuQix1QkFBdUI7UUFDdkJwQyxtQkFBbUJ3QztJQUNyQjtBQUNGO0FBQ0EsTUFBTUUsb0JBQW9CalAsQ0FBQUE7SUFDeEIsTUFBTXBMLFFBQVFEO0lBQ2QsSUFBSSxDQUFDQyxPQUFPO1FBQ1YsT0FBTztJQUNUO0lBQ0EsTUFBTXlOLGNBQWNELGFBQWFDLFdBQVcsQ0FBQzNSLEdBQUcsQ0FBQ3NQO0lBQ2pELElBQUksQ0FBQ3FDLGVBQWUxSyxTQUFTL0MsT0FBT3lOLFlBQVlnTixTQUFTLENBQUN6YSxLQUFLLEdBQUc7UUFDaEUsT0FBTztJQUNUO0lBQ0FrRyxZQUFZbEcsT0FBT3lOLFlBQVk1SSxTQUFTLENBQUM3RSxLQUFLO0lBQzlDaUYsU0FBU2pGLE9BQU95TixZQUFZZ04sU0FBUyxDQUFDemEsS0FBSztJQUMzQyxNQUFNaU4sV0FBV3hOO0lBQ2pCeUcsWUFBWStHLFVBQVVRLFlBQVk1SSxTQUFTLENBQUNvSSxRQUFRO0lBQ3BEaEksU0FBU2dJLFVBQVVRLFlBQVlnTixTQUFTLENBQUN4TixRQUFRO0lBQ2pEeU4scUJBQXFCdFAsVUFBVXBMLE9BQU95TjtJQUN0QyxPQUFPO0FBQ1Q7QUFFQTs7Q0FFQyxHQUNELFNBQVNrTixjQUFjamMsS0FBSztJQUMxQixNQUFNaWMsZ0JBQWdCakQsZUFBZUUsaUJBQWlCLENBQUM5YixHQUFHLENBQUMsSUFBSTtJQUMvRDBlLHNCQUFzQixJQUFJO0lBQzFCLElBQUlHLGVBQWU7UUFDakIsc0JBQXNCO1FBQ3RCQSxjQUFjamM7SUFDaEI7QUFDRjtBQUVBOztDQUVDLEdBQ0QsTUFBTThiLHdCQUF3QnBQLENBQUFBO0lBQzVCLElBQUlBLFNBQVNrUCxpQkFBaUIsRUFBRTtRQUM5QixPQUFPbFAsU0FBU2tQLGlCQUFpQjtRQUNqQyxrSEFBa0g7UUFDbEgsSUFBSSxDQUFDOU0sYUFBYUMsV0FBVyxDQUFDM1IsR0FBRyxDQUFDc1AsV0FBVztZQUMzQ0EsU0FBU3dQLFFBQVE7UUFDbkI7SUFDRjtBQUNGO0FBRUE7OztDQUdDLEdBQ0QsTUFBTVIsc0JBQXNCRCxDQUFBQTtJQUMxQiwrQkFBK0I7SUFDL0IsSUFBSSxPQUFPQSxpQkFBaUIsYUFBYTtRQUN2QyxPQUFPO1lBQ0xVLGFBQWE7WUFDYkMsVUFBVTtZQUNWUCxhQUFhO1FBQ2Y7SUFDRjtJQUNBLE9BQU81VixPQUFPb1csTUFBTSxDQUFDO1FBQ25CRixhQUFhO1FBQ2JDLFVBQVU7UUFDVlAsYUFBYTtJQUNmLEdBQUdKO0FBQ0w7QUFFQTs7OztDQUlDLEdBQ0QsTUFBTU8sdUJBQXVCLENBQUN0UCxVQUFVcEwsT0FBT3lOO0lBQzdDLE1BQU05TixZQUFZRjtJQUNsQixxQ0FBcUM7SUFDckMsTUFBTXViLHVCQUF1QmpRLHFCQUFxQmpELGdCQUFnQjlIO0lBQ2xFLElBQUksT0FBT3lOLFlBQVl3TixTQUFTLEtBQUssWUFBWTtRQUMvQ3hOLFlBQVl3TixTQUFTLENBQUNqYjtJQUN4QjtJQUNBNUQsWUFBWW9ZLFlBQVksQ0FBQ0MsSUFBSSxDQUFDLGFBQWF6VTtJQUMzQyxJQUFJZ2Isc0JBQXNCO1FBQ3hCRSxhQUFhOVAsVUFBVXBMLE9BQU9MLFdBQVc4TixZQUFZN1EsV0FBVyxFQUFFNlEsWUFBWXNNLFFBQVE7SUFDeEYsT0FBTztRQUNMLGdDQUFnQztRQUNoQ0QseUJBQXlCMU8sVUFBVXpMLFdBQVc4TixZQUFZN1EsV0FBVyxFQUFFNlEsWUFBWXNNLFFBQVE7SUFDN0Y7QUFDRjtBQUVBOzs7Ozs7Q0FNQyxHQUNELE1BQU1tQixlQUFlLENBQUM5UCxVQUFVcEwsT0FBT0wsV0FBVy9DLGFBQWFtZDtJQUM3RCxJQUFJLENBQUNoUCxtQkFBbUI7UUFDdEI7SUFDRjtJQUNBM08sWUFBWStlLDhCQUE4QixHQUFHckIseUJBQXlCc0IsSUFBSSxDQUFDLE1BQU1oUSxVQUFVekwsV0FBVy9DLGFBQWFtZDtJQUNuSC9aLE1BQU04VixnQkFBZ0IsQ0FBQy9LLG1CQUFtQixTQUFVNVAsQ0FBQztRQUNuRCxJQUFJQSxFQUFFMEssTUFBTSxLQUFLN0YsT0FBTztZQUN0QjVELFlBQVkrZSw4QkFBOEI7WUFDMUMsT0FBTy9lLFlBQVkrZSw4QkFBOEI7UUFDbkQ7SUFDRjtBQUNGO0FBRUE7OztDQUdDLEdBQ0QsTUFBTW5CLDRCQUE0QixDQUFDNU8sVUFBVTJPO0lBQzNDMWMsV0FBVztRQUNULElBQUksT0FBTzBjLGFBQWEsWUFBWTtZQUNsQ0EsU0FBU3FCLElBQUksQ0FBQ2hRLFNBQVMxRyxNQUFNO1FBQy9CO1FBQ0F0SSxZQUFZb1ksWUFBWSxDQUFDQyxJQUFJLENBQUM7UUFDOUIsNkNBQTZDO1FBQzdDLElBQUlySixTQUFTd1AsUUFBUSxFQUFFO1lBQ3JCeFAsU0FBU3dQLFFBQVE7UUFDbkI7SUFDRjtBQUNGO0FBRUE7Ozs7O0NBS0MsR0FDRCxNQUFNUyxjQUFjQyxDQUFBQTtJQUNsQixJQUFJdGIsUUFBUUQ7SUFDWixJQUFJLENBQUNDLE9BQU87UUFDVixJQUFJdWI7SUFDTjtJQUNBdmIsUUFBUUQ7SUFDUixJQUFJLENBQUNDLE9BQU87UUFDVjtJQUNGO0lBQ0EsTUFBTW1CLFNBQVNEO0lBQ2YsSUFBSStCLFdBQVc7UUFDYjJELEtBQUszRztJQUNQLE9BQU87UUFDTHViLGNBQWN4YixPQUFPc2I7SUFDdkI7SUFDQTVVLEtBQUt2RjtJQUNMbkIsTUFBTWlLLFlBQVksQ0FBQyxnQkFBZ0I7SUFDbkNqSyxNQUFNaUssWUFBWSxDQUFDLGFBQWE7SUFDaENqSyxNQUFNeEQsS0FBSztBQUNiO0FBRUE7OztDQUdDLEdBQ0QsTUFBTWdmLGdCQUFnQixDQUFDeGIsT0FBT3NiO0lBQzVCLE1BQU0zYSxVQUFVUztJQUNoQixNQUFNRCxTQUFTRDtJQUNmLElBQUksQ0FBQ1AsV0FBVyxDQUFDUSxRQUFRO1FBQ3ZCO0lBQ0Y7SUFDQSxJQUFJLENBQUNtYSxtQkFBbUJ6WSxZQUFZbkMscUJBQXFCO1FBQ3ZENGEsa0JBQWtCNWE7SUFDcEI7SUFDQWdHLEtBQUsvRjtJQUNMLElBQUkyYSxpQkFBaUI7UUFDbkIxVSxLQUFLMFU7UUFDTG5hLE9BQU84SSxZQUFZLENBQUMsMEJBQTBCcVIsZ0JBQWdCMWQsU0FBUztRQUN2RStDLFFBQVFxTCxZQUFZLENBQUM3SyxRQUFRbWE7SUFDL0I7SUFDQXJXLFNBQVM7UUFBQ2pGO1FBQU9XO0tBQVEsRUFBRWxELFlBQVlnZSxPQUFPO0FBQ2hEO0FBRUE7OztDQUdDLEdBQ0QsTUFBTUMsNkJBQTZCLENBQUN0USxVQUFVMUc7SUFDNUMsSUFBSUEsT0FBT2EsS0FBSyxLQUFLLFlBQVliLE9BQU9hLEtBQUssS0FBSyxTQUFTO1FBQ3pEb1csbUJBQW1CdlEsVUFBVTFHO0lBQy9CLE9BQU8sSUFBSTtRQUFDO1FBQVE7UUFBUztRQUFVO1FBQU87S0FBVyxDQUFDa1gsSUFBSSxDQUFDclgsQ0FBQUEsSUFBS0EsTUFBTUcsT0FBT2EsS0FBSyxLQUFNbEcsQ0FBQUEsZUFBZXFGLE9BQU9nTCxVQUFVLEtBQUtsUSxVQUFVa0YsT0FBT2dMLFVBQVUsSUFBSTtRQUM5SjJMLFlBQVkzYTtRQUNabWIsaUJBQWlCelEsVUFBVTFHO0lBQzdCO0FBQ0Y7QUFFQTs7OztDQUlDLEdBQ0QsTUFBTW9YLGdCQUFnQixDQUFDMVEsVUFBVXFDO0lBQy9CLE1BQU1sSSxRQUFRNkYsU0FBUzJRLFFBQVE7SUFDL0IsSUFBSSxDQUFDeFcsT0FBTztRQUNWLE9BQU87SUFDVDtJQUNBLE9BQVFrSSxZQUFZbEksS0FBSztRQUN2QixLQUFLO1lBQ0gsT0FBT3lXLGlCQUFpQnpXO1FBQzFCLEtBQUs7WUFDSCxPQUFPMFcsY0FBYzFXO1FBQ3ZCLEtBQUs7WUFDSCxPQUFPMlcsYUFBYTNXO1FBQ3RCO1lBQ0UsT0FBT2tJLFlBQVkwTyxhQUFhLEdBQUc1VyxNQUFNSSxLQUFLLENBQUMrTSxJQUFJLEtBQUtuTixNQUFNSSxLQUFLO0lBQ3ZFO0FBQ0Y7QUFFQTs7O0NBR0MsR0FDRCxNQUFNcVcsbUJBQW1CelcsQ0FBQUEsUUFBU0EsTUFBTW1MLE9BQU8sR0FBRyxJQUFJO0FBRXREOzs7Q0FHQyxHQUNELE1BQU11TCxnQkFBZ0IxVyxDQUFBQSxRQUFTQSxNQUFNbUwsT0FBTyxHQUFHbkwsTUFBTUksS0FBSyxHQUFHO0FBRTdEOzs7Q0FHQyxHQUNELE1BQU11VyxlQUFlM1csQ0FBQUEsUUFBU0EsTUFBTTZXLEtBQUssSUFBSTdXLE1BQU02VyxLQUFLLENBQUM1Z0IsTUFBTSxHQUFHK0osTUFBTWxELFlBQVksQ0FBQyxnQkFBZ0IsT0FBT2tELE1BQU02VyxLQUFLLEdBQUc3VyxNQUFNNlcsS0FBSyxDQUFDLEVBQUUsR0FBRztBQUUzSTs7O0NBR0MsR0FDRCxNQUFNVCxxQkFBcUIsQ0FBQ3ZRLFVBQVUxRztJQUNwQyxNQUFNMUUsUUFBUUQ7SUFDZCxJQUFJLENBQUNDLE9BQU87UUFDVjtJQUNGO0lBQ0E7O0dBRUMsR0FDRCxNQUFNcWMsc0JBQXNCQyxDQUFBQTtRQUMxQixJQUFJNVgsT0FBT2EsS0FBSyxLQUFLLFVBQVU7WUFDN0JnWCxzQkFBc0J2YyxPQUFPd2MsbUJBQW1CRixlQUFlNVg7UUFDakUsT0FBTyxJQUFJQSxPQUFPYSxLQUFLLEtBQUssU0FBUztZQUNuQ2tYLHFCQUFxQnpjLE9BQU93YyxtQkFBbUJGLGVBQWU1WDtRQUNoRTtJQUNGO0lBQ0EsSUFBSXJGLGVBQWVxRixPQUFPNFgsWUFBWSxLQUFLOWMsVUFBVWtGLE9BQU80WCxZQUFZLEdBQUc7UUFDekVqQixZQUFZM2E7UUFDWm5CLFVBQVVtRixPQUFPNFgsWUFBWSxFQUFFckMsSUFBSSxDQUFDcUMsQ0FBQUE7WUFDbENsUixTQUFTc1IsV0FBVztZQUNwQkwsb0JBQW9CQztRQUN0QjtJQUNGLE9BQU8sSUFBSSxPQUFPNVgsT0FBTzRYLFlBQVksS0FBSyxVQUFVO1FBQ2xERCxvQkFBb0IzWCxPQUFPNFgsWUFBWTtJQUN6QyxPQUFPO1FBQ0w1ZCxNQUFNLENBQUMsc0VBQXNFLEVBQUUsT0FBT2dHLE9BQU80WCxZQUFZLENBQUMsQ0FBQztJQUM3RztBQUNGO0FBRUE7OztDQUdDLEdBQ0QsTUFBTVQsbUJBQW1CLENBQUN6USxVQUFVMUc7SUFDbEMsTUFBTWEsUUFBUTZGLFNBQVMyUSxRQUFRO0lBQy9CLElBQUksQ0FBQ3hXLE9BQU87UUFDVjtJQUNGO0lBQ0FxQixLQUFLckI7SUFDTGhHLFVBQVVtRixPQUFPZ0wsVUFBVSxFQUFFdUssSUFBSSxDQUFDdkssQ0FBQUE7UUFDaENuSyxNQUFNSSxLQUFLLEdBQUdqQixPQUFPYSxLQUFLLEtBQUssV0FBVyxDQUFDLEVBQUUwQyxXQUFXeUgsZUFBZSxFQUFFLENBQUMsR0FBRyxDQUFDLEVBQUVBLFdBQVcsQ0FBQztRQUM1RmhKLEtBQUtuQjtRQUNMQSxNQUFNL0ksS0FBSztRQUNYNE8sU0FBU3NSLFdBQVc7SUFDdEIsR0FBR0MsS0FBSyxDQUFDQyxDQUFBQTtRQUNQbGUsTUFBTSxDQUFDLDZCQUE2QixFQUFFa2UsSUFBSSxDQUFDO1FBQzNDclgsTUFBTUksS0FBSyxHQUFHO1FBQ2RlLEtBQUtuQjtRQUNMQSxNQUFNL0ksS0FBSztRQUNYNE8sU0FBU3NSLFdBQVc7SUFDdEI7QUFDRjtBQUVBOzs7O0NBSUMsR0FDRCxTQUFTSCxzQkFBc0J2YyxLQUFLLEVBQUVzYyxZQUFZLEVBQUU1WCxNQUFNO0lBQ3hELE1BQU11RSxTQUFTOUMsc0JBQXNCbkcsT0FBT3ZDLFlBQVl3TCxNQUFNO0lBQzlELElBQUksQ0FBQ0EsUUFBUTtRQUNYO0lBQ0Y7SUFDQTs7OztHQUlDLEdBQ0QsTUFBTTRULGVBQWUsQ0FBQ3hWLFFBQVF5VixhQUFhQztRQUN6QyxNQUFNQyxTQUFTdmdCLFNBQVMrTixhQUFhLENBQUM7UUFDdEN3UyxPQUFPclgsS0FBSyxHQUFHb1g7UUFDZjFaLGFBQWEyWixRQUFRRjtRQUNyQkUsT0FBT3hNLFFBQVEsR0FBR3lNLFdBQVdGLGFBQWFyWSxPQUFPZ0wsVUFBVTtRQUMzRHJJLE9BQU9wRCxXQUFXLENBQUMrWTtJQUNyQjtJQUNBVixhQUFhdlksT0FBTyxDQUFDbVosQ0FBQUE7UUFDbkIsTUFBTUgsY0FBY0csV0FBVyxDQUFDLEVBQUU7UUFDbEMsTUFBTUosY0FBY0ksV0FBVyxDQUFDLEVBQUU7UUFDbEMsbUJBQW1CO1FBQ25CLDJEQUEyRDtRQUMzRCxvSEFBb0g7UUFDcEgscUNBQXFDO1FBQ3JDLElBQUluYixNQUFNaUUsT0FBTyxDQUFDOFcsY0FBYztZQUM5Qiw4Q0FBOEM7WUFDOUMsTUFBTUssV0FBVzFnQixTQUFTK04sYUFBYSxDQUFDO1lBQ3hDMlMsU0FBU2pVLEtBQUssR0FBRzZUO1lBQ2pCSSxTQUFTNU0sUUFBUSxHQUFHLE9BQU8sMkJBQTJCO1lBQ3REdEgsT0FBT2hGLFdBQVcsQ0FBQ2taO1lBQ25CTCxZQUFZL1ksT0FBTyxDQUFDcVosQ0FBQUEsSUFBS1AsYUFBYU0sVUFBVUMsQ0FBQyxDQUFDLEVBQUUsRUFBRUEsQ0FBQyxDQUFDLEVBQUU7UUFDNUQsT0FBTztZQUNMLG1CQUFtQjtZQUNuQlAsYUFBYTVULFFBQVE2VCxhQUFhQztRQUNwQztJQUNGO0lBQ0E5VCxPQUFPek0sS0FBSztBQUNkO0FBRUE7Ozs7Q0FJQyxHQUNELFNBQVNpZ0IscUJBQXFCemMsS0FBSyxFQUFFc2MsWUFBWSxFQUFFNVgsTUFBTTtJQUN2RCxNQUFNVyxRQUFRYyxzQkFBc0JuRyxPQUFPdkMsWUFBWTRILEtBQUs7SUFDNUQsSUFBSSxDQUFDQSxPQUFPO1FBQ1Y7SUFDRjtJQUNBaVgsYUFBYXZZLE9BQU8sQ0FBQ21aLENBQUFBO1FBQ25CLE1BQU1HLGFBQWFILFdBQVcsQ0FBQyxFQUFFO1FBQ2pDLE1BQU1JLGFBQWFKLFdBQVcsQ0FBQyxFQUFFO1FBQ2pDLE1BQU1LLGFBQWE5Z0IsU0FBUytOLGFBQWEsQ0FBQztRQUMxQyxNQUFNZ1Qsb0JBQW9CL2dCLFNBQVMrTixhQUFhLENBQUM7UUFDakQrUyxXQUFXOVgsSUFBSSxHQUFHO1FBQ2xCOFgsV0FBVzVPLElBQUksR0FBR2xSLFlBQVk0SCxLQUFLO1FBQ25Da1ksV0FBVzVYLEtBQUssR0FBRzBYO1FBQ25CLElBQUlKLFdBQVdJLFlBQVkzWSxPQUFPZ0wsVUFBVSxHQUFHO1lBQzdDNk4sV0FBVzdNLE9BQU8sR0FBRztRQUN2QjtRQUNBLE1BQU14SCxRQUFRek0sU0FBUytOLGFBQWEsQ0FBQztRQUNyQ25ILGFBQWE2RixPQUFPb1U7UUFDcEJwVSxNQUFNdEwsU0FBUyxHQUFHSCxZQUFZeUwsS0FBSztRQUNuQ3NVLGtCQUFrQnZaLFdBQVcsQ0FBQ3NaO1FBQzlCQyxrQkFBa0J2WixXQUFXLENBQUNpRjtRQUM5QjdELE1BQU1wQixXQUFXLENBQUN1WjtJQUNwQjtJQUNBLE1BQU1DLFNBQVNwWSxNQUFNeEQsZ0JBQWdCLENBQUM7SUFDdEMsSUFBSTRiLE9BQU9qaUIsTUFBTSxFQUFFO1FBQ2pCaWlCLE1BQU0sQ0FBQyxFQUFFLENBQUNqaEIsS0FBSztJQUNqQjtBQUNGO0FBRUE7Ozs7OztDQU1DLEdBQ0QsTUFBTWdnQixxQkFBcUJGLENBQUFBO0lBQ3pCLG1DQUFtQyxHQUNuQyxNQUFNb0IsU0FBUyxFQUFFO0lBQ2pCLElBQUlwQix3QkFBd0JxQixLQUFLO1FBQy9CckIsYUFBYXZZLE9BQU8sQ0FBQyxDQUFDNEIsT0FBTytRO1lBQzNCLElBQUlrSCxpQkFBaUJqWTtZQUNyQixJQUFJLE9BQU9pWSxtQkFBbUIsVUFBVTtnQkFDdEMscUJBQXFCO2dCQUNyQkEsaUJBQWlCcEIsbUJBQW1Cb0I7WUFDdEM7WUFDQUYsT0FBTzVlLElBQUksQ0FBQztnQkFBQzRYO2dCQUFLa0g7YUFBZTtRQUNuQztJQUNGLE9BQU87UUFDTGpaLE9BQU8wSixJQUFJLENBQUNpTyxjQUFjdlksT0FBTyxDQUFDMlMsQ0FBQUE7WUFDaEMsSUFBSWtILGlCQUFpQnRCLFlBQVksQ0FBQzVGLElBQUk7WUFDdEMsSUFBSSxPQUFPa0gsbUJBQW1CLFVBQVU7Z0JBQ3RDLHFCQUFxQjtnQkFDckJBLGlCQUFpQnBCLG1CQUFtQm9CO1lBQ3RDO1lBQ0FGLE9BQU81ZSxJQUFJLENBQUM7Z0JBQUM0WDtnQkFBS2tIO2FBQWU7UUFDbkM7SUFDRjtJQUNBLE9BQU9GO0FBQ1Q7QUFFQTs7OztDQUlDLEdBQ0QsTUFBTVQsYUFBYSxDQUFDRixhQUFhck47SUFDL0IsT0FBTyxDQUFDLENBQUNBLGNBQWNBLFdBQVc1RSxRQUFRLE9BQU9pUyxZQUFZalMsUUFBUTtBQUN2RTtBQUVBOztDQUVDLEdBQ0QsTUFBTStTLDJCQUEyQnpTLENBQUFBO0lBQy9CLE1BQU1xQyxjQUFjRCxhQUFhQyxXQUFXLENBQUMzUixHQUFHLENBQUNzUDtJQUNqREEsU0FBUzBTLGNBQWM7SUFDdkIsSUFBSXJRLFlBQVlsSSxLQUFLLEVBQUU7UUFDckJ3WSw2QkFBNkIzUyxVQUFVO0lBQ3pDLE9BQU87UUFDTHhLLFFBQVF3SyxVQUFVO0lBQ3BCO0FBQ0Y7QUFFQTs7Q0FFQyxHQUNELE1BQU00Uyx3QkFBd0I1UyxDQUFBQTtJQUM1QixNQUFNcUMsY0FBY0QsYUFBYUMsV0FBVyxDQUFDM1IsR0FBRyxDQUFDc1A7SUFDakRBLFNBQVMwUyxjQUFjO0lBQ3ZCLElBQUlyUSxZQUFZd1Esc0JBQXNCLEVBQUU7UUFDdENGLDZCQUE2QjNTLFVBQVU7SUFDekMsT0FBTztRQUNMcEssS0FBS29LLFVBQVU7SUFDakI7QUFDRjtBQUVBOzs7Q0FHQyxHQUNELE1BQU04UywwQkFBMEIsQ0FBQzlTLFVBQVV5SztJQUN6Q3pLLFNBQVMwUyxjQUFjO0lBQ3ZCakksWUFBWVgsY0FBY3BVLE1BQU07QUFDbEM7QUFFQTs7O0NBR0MsR0FDRCxNQUFNaWQsK0JBQStCLENBQUMzUyxVQUFVM0Y7SUFDOUMsTUFBTWdJLGNBQWNELGFBQWFDLFdBQVcsQ0FBQzNSLEdBQUcsQ0FBQ3NQO0lBQ2pELElBQUksQ0FBQ3FDLFlBQVlsSSxLQUFLLEVBQUU7UUFDdEI3RyxNQUFNLENBQUMsdUVBQXVFLEVBQUVULHNCQUFzQndILE1BQU0sQ0FBQztRQUM3RztJQUNGO0lBQ0EsTUFBTUYsUUFBUTZGLFNBQVMyUSxRQUFRO0lBQy9CLE1BQU1yTSxhQUFhb00sY0FBYzFRLFVBQVVxQztJQUMzQyxJQUFJQSxZQUFZMFEsY0FBYyxFQUFFO1FBQzlCQyxxQkFBcUJoVCxVQUFVc0UsWUFBWWpLO0lBQzdDLE9BQU8sSUFBSUYsU0FBUyxDQUFDQSxNQUFNOFksYUFBYSxJQUFJO1FBQzFDalQsU0FBU2tULGFBQWE7UUFDdEJsVCxTQUFTbVQscUJBQXFCLENBQUM5USxZQUFZK1EsaUJBQWlCLElBQUlqWixNQUFNaVosaUJBQWlCO0lBQ3pGLE9BQU8sSUFBSS9ZLFNBQVMsUUFBUTtRQUMxQnpFLEtBQUtvSyxVQUFVc0U7SUFDakIsT0FBTztRQUNMOU8sUUFBUXdLLFVBQVVzRTtJQUNwQjtBQUNGO0FBRUE7Ozs7Q0FJQyxHQUNELE1BQU0wTyx1QkFBdUIsQ0FBQ2hULFVBQVVzRSxZQUFZaks7SUFDbEQsTUFBTWdJLGNBQWNELGFBQWFDLFdBQVcsQ0FBQzNSLEdBQUcsQ0FBQ3NQO0lBQ2pEQSxTQUFTcVQsWUFBWTtJQUNyQixNQUFNQyxvQkFBb0I3aEIsUUFBUUMsT0FBTyxHQUFHbWQsSUFBSSxDQUFDLElBQU0xYSxVQUFVa08sWUFBWTBRLGNBQWMsQ0FBQ3pPLFlBQVlqQyxZQUFZK1EsaUJBQWlCO0lBQ3JJRSxrQkFBa0J6RSxJQUFJLENBQUN1RSxDQUFBQTtRQUNyQnBULFNBQVNrVCxhQUFhO1FBQ3RCbFQsU0FBU3VULFdBQVc7UUFDcEIsSUFBSUgsbUJBQW1CO1lBQ3JCcFQsU0FBU21ULHFCQUFxQixDQUFDQztRQUNqQyxPQUFPLElBQUkvWSxTQUFTLFFBQVE7WUFDMUJ6RSxLQUFLb0ssVUFBVXNFO1FBQ2pCLE9BQU87WUFDTDlPLFFBQVF3SyxVQUFVc0U7UUFDcEI7SUFDRjtBQUNGO0FBRUE7OztDQUdDLEdBQ0QsTUFBTTFPLE9BQU8sQ0FBQ29LLFVBQVV6RjtJQUN0QixNQUFNOEgsY0FBY0QsYUFBYUMsV0FBVyxDQUFDM1IsR0FBRyxDQUFDc1AsWUFBWWxNO0lBQzdELElBQUl1TyxZQUFZbVIsZ0JBQWdCLEVBQUU7UUFDaEN2RCxZQUFZdGE7SUFDZDtJQUNBLElBQUkwTSxZQUFZb1IsT0FBTyxFQUFFO1FBQ3ZCelQsU0FBU2tQLGlCQUFpQixHQUFHLE1BQU0sMEtBQTBLO1FBQzdNLE1BQU13RSxpQkFBaUJqaUIsUUFBUUMsT0FBTyxHQUFHbWQsSUFBSSxDQUFDLElBQU0xYSxVQUFVa08sWUFBWW9SLE9BQU8sQ0FBQ2xaLE9BQU84SCxZQUFZK1EsaUJBQWlCO1FBQ3RITSxlQUFlN0UsSUFBSSxDQUFDOEUsQ0FBQUE7WUFDbEIsSUFBSUEsaUJBQWlCLE9BQU87Z0JBQzFCM1QsU0FBU3NSLFdBQVc7Z0JBQ3BCbEMsc0JBQXNCcFA7WUFDeEIsT0FBTztnQkFDTEEsU0FBUzNKLEtBQUssQ0FBQztvQkFDYnFaLFVBQVU7b0JBQ1ZuVixPQUFPLE9BQU9vWixpQkFBaUIsY0FBY3BaLFFBQVFvWjtnQkFDdkQ7WUFDRjtRQUNGLEdBQUdwQyxLQUFLLENBQUNqZSxDQUFBQSxRQUFTc2dCLFdBQVc1VCxZQUFZbE0sV0FBV1I7SUFDdEQsT0FBTztRQUNMME0sU0FBUzNKLEtBQUssQ0FBQztZQUNicVosVUFBVTtZQUNWblY7UUFDRjtJQUNGO0FBQ0Y7QUFFQTs7O0NBR0MsR0FDRCxNQUFNc1osY0FBYyxDQUFDN1QsVUFBVXpGO0lBQzdCeUYsU0FBUzNKLEtBQUssQ0FBQztRQUNib1osYUFBYTtRQUNibFY7SUFDRjtBQUNGO0FBRUE7Ozs7Q0FJQyxHQUNELE1BQU1xWixhQUFhLENBQUM1VCxVQUFVMU07SUFDNUIwTSxTQUFTdVAsYUFBYSxDQUFDamM7QUFDekI7QUFFQTs7OztDQUlDLEdBQ0QsTUFBTWtDLFVBQVUsQ0FBQ3dLLFVBQVV6RjtJQUN6QixNQUFNOEgsY0FBY0QsYUFBYUMsV0FBVyxDQUFDM1IsR0FBRyxDQUFDc1AsWUFBWWxNO0lBQzdELElBQUl1TyxZQUFZeVIsbUJBQW1CLEVBQUU7UUFDbkM3RDtJQUNGO0lBQ0EsSUFBSTVOLFlBQVkwUixVQUFVLEVBQUU7UUFDMUIvVCxTQUFTMUIsc0JBQXNCO1FBQy9CMEIsU0FBU2tQLGlCQUFpQixHQUFHLE1BQU0sNktBQTZLO1FBQ2hOLE1BQU04RSxvQkFBb0J2aUIsUUFBUUMsT0FBTyxHQUFHbWQsSUFBSSxDQUFDLElBQU0xYSxVQUFVa08sWUFBWTBSLFVBQVUsQ0FBQ3haLE9BQU84SCxZQUFZK1EsaUJBQWlCO1FBQzVIWSxrQkFBa0JuRixJQUFJLENBQUNvRixDQUFBQTtZQUNyQixJQUFJeGMsWUFBWXBDLDJCQUEyQjRlLG9CQUFvQixPQUFPO2dCQUNwRWpVLFNBQVNzUixXQUFXO2dCQUNwQmxDLHNCQUFzQnBQO1lBQ3hCLE9BQU87Z0JBQ0w2VCxZQUFZN1QsVUFBVSxPQUFPaVUsb0JBQW9CLGNBQWMxWixRQUFRMFo7WUFDekU7UUFDRixHQUFHMUMsS0FBSyxDQUFDamUsQ0FBQUEsUUFBU3NnQixXQUFXNVQsWUFBWWxNLFdBQVdSO0lBQ3RELE9BQU87UUFDTHVnQixZQUFZN1QsVUFBVXpGO0lBQ3hCO0FBQ0Y7QUFFQTs7Q0FFQyxHQUNELFNBQVMrVztJQUNQLGdDQUFnQztJQUNoQyxNQUFNalAsY0FBY0QsYUFBYUMsV0FBVyxDQUFDM1IsR0FBRyxDQUFDLElBQUk7SUFDckQsSUFBSSxDQUFDMlIsYUFBYTtRQUNoQjtJQUNGO0lBQ0EsTUFBTUUsV0FBV0gsYUFBYUcsUUFBUSxDQUFDN1IsR0FBRyxDQUFDLElBQUk7SUFDL0M4SyxLQUFLK0csU0FBU3hNLE1BQU07SUFDcEIsSUFBSThCLFdBQVc7UUFDYixJQUFJd0ssWUFBWTFQLElBQUksRUFBRTtZQUNwQjJJLEtBQUt6RztRQUNQO0lBQ0YsT0FBTztRQUNMcWYsa0JBQWtCM1I7SUFDcEI7SUFDQXpILFlBQVk7UUFBQ3lILFNBQVMzTixLQUFLO1FBQUUyTixTQUFTaE4sT0FBTztLQUFDLEVBQUVsRCxZQUFZZ2UsT0FBTztJQUNuRTlOLFNBQVMzTixLQUFLLENBQUM0TyxlQUFlLENBQUM7SUFDL0JqQixTQUFTM04sS0FBSyxDQUFDNE8sZUFBZSxDQUFDO0lBQy9CakIsU0FBU2pDLGFBQWEsQ0FBQzZFLFFBQVEsR0FBRztJQUNsQzVDLFNBQVNoQyxVQUFVLENBQUM0RSxRQUFRLEdBQUc7SUFDL0I1QyxTQUFTL0IsWUFBWSxDQUFDMkUsUUFBUSxHQUFHO0FBQ25DO0FBQ0EsTUFBTStPLG9CQUFvQjNSLENBQUFBO0lBQ3hCLE1BQU0yTixrQkFBa0IzTixTQUFTM04sS0FBSyxDQUFDdWYsc0JBQXNCLENBQUM1UixTQUFTeE0sTUFBTSxDQUFDa0IsWUFBWSxDQUFDO0lBQzNGLElBQUlpWixnQkFBZ0I5ZixNQUFNLEVBQUU7UUFDMUJrTCxLQUFLNFUsZUFBZSxDQUFDLEVBQUUsRUFBRTtJQUMzQixPQUFPLElBQUk1VCx1QkFBdUI7UUFDaENkLEtBQUsrRyxTQUFTaE4sT0FBTztJQUN2QjtBQUNGO0FBRUE7Ozs7Q0FJQyxHQUNELFNBQVNvYjtJQUNQLE1BQU10TyxjQUFjRCxhQUFhQyxXQUFXLENBQUMzUixHQUFHLENBQUMsSUFBSTtJQUNyRCxNQUFNNlIsV0FBV0gsYUFBYUcsUUFBUSxDQUFDN1IsR0FBRyxDQUFDLElBQUk7SUFDL0MsSUFBSSxDQUFDNlIsVUFBVTtRQUNiLE9BQU87SUFDVDtJQUNBLE9BQU96SSxXQUFXeUksU0FBUzNOLEtBQUssRUFBRXlOLFlBQVlsSSxLQUFLO0FBQ3JEO0FBRUE7Ozs7Q0FJQyxHQUNELFNBQVNpYSxtQkFBbUJwVSxRQUFRLEVBQUVnTSxPQUFPLEVBQUU3RyxRQUFRO0lBQ3JELE1BQU01QyxXQUFXSCxhQUFhRyxRQUFRLENBQUM3UixHQUFHLENBQUNzUDtJQUMzQ2dNLFFBQVFyVCxPQUFPLENBQUN3SSxDQUFBQTtRQUNkb0IsUUFBUSxDQUFDcEIsT0FBTyxDQUFDZ0UsUUFBUSxHQUFHQTtJQUM5QjtBQUNGO0FBRUE7OztDQUdDLEdBQ0QsU0FBU2tQLGlCQUFpQmxhLEtBQUssRUFBRWdMLFFBQVE7SUFDdkMsTUFBTXZRLFFBQVFEO0lBQ2QsSUFBSSxDQUFDQyxTQUFTLENBQUN1RixPQUFPO1FBQ3BCO0lBQ0Y7SUFDQSxJQUFJQSxNQUFNRSxJQUFJLEtBQUssU0FBUztRQUMxQix5Q0FBeUMsR0FDekMsTUFBTWdZLFNBQVN6ZCxNQUFNNkIsZ0JBQWdCLENBQUMsQ0FBQyxPQUFPLEVBQUVwRSxZQUFZNEgsS0FBSyxDQUFDLEVBQUUsQ0FBQztRQUNyRSxJQUFLLElBQUlkLElBQUksR0FBR0EsSUFBSWtaLE9BQU9qaUIsTUFBTSxFQUFFK0ksSUFBSztZQUN0Q2taLE1BQU0sQ0FBQ2xaLEVBQUUsQ0FBQ2dNLFFBQVEsR0FBR0E7UUFDdkI7SUFDRixPQUFPO1FBQ0xoTCxNQUFNZ0wsUUFBUSxHQUFHQTtJQUNuQjtBQUNGO0FBRUE7OztDQUdDLEdBQ0QsU0FBUytOO0lBQ1BrQixtQkFBbUIsSUFBSSxFQUFFO1FBQUM7UUFBaUI7UUFBYztLQUFlLEVBQUU7QUFDNUU7QUFFQTs7O0NBR0MsR0FDRCxTQUFTMUI7SUFDUDBCLG1CQUFtQixJQUFJLEVBQUU7UUFBQztRQUFpQjtRQUFjO0tBQWUsRUFBRTtBQUM1RTtBQUVBOzs7Q0FHQyxHQUNELFNBQVNiO0lBQ1BjLGlCQUFpQixJQUFJLENBQUMxRCxRQUFRLElBQUk7QUFDcEM7QUFFQTs7O0NBR0MsR0FDRCxTQUFTMEM7SUFDUGdCLGlCQUFpQixJQUFJLENBQUMxRCxRQUFRLElBQUk7QUFDcEM7QUFFQTs7Ozs7Q0FLQyxHQUNELFNBQVN3QyxzQkFBc0I3ZixLQUFLO0lBQ2xDLE1BQU1pUCxXQUFXSCxhQUFhRyxRQUFRLENBQUM3UixHQUFHLENBQUMsSUFBSTtJQUMvQyxNQUFNNEksU0FBUzhJLGFBQWFDLFdBQVcsQ0FBQzNSLEdBQUcsQ0FBQyxJQUFJO0lBQ2hEdUgsYUFBYXNLLFNBQVM2USxpQkFBaUIsRUFBRTlmO0lBQ3pDaVAsU0FBUzZRLGlCQUFpQixDQUFDNWdCLFNBQVMsR0FBR0gsV0FBVyxDQUFDLHFCQUFxQjtJQUN4RSxJQUFJaUgsT0FBT00sV0FBVyxJQUFJTixPQUFPTSxXQUFXLENBQUN3WixpQkFBaUIsRUFBRTtRQUM5RHZaLFNBQVMwSSxTQUFTNlEsaUJBQWlCLEVBQUU5WixPQUFPTSxXQUFXLENBQUN3WixpQkFBaUI7SUFDM0U7SUFDQTlYLEtBQUtpSCxTQUFTNlEsaUJBQWlCO0lBQy9CLE1BQU1qWixRQUFRLElBQUksQ0FBQ3dXLFFBQVE7SUFDM0IsSUFBSXhXLE9BQU87UUFDVEEsTUFBTTBFLFlBQVksQ0FBQyxnQkFBZ0I7UUFDbkMxRSxNQUFNMEUsWUFBWSxDQUFDLG9CQUFvQnhNLFdBQVcsQ0FBQyxxQkFBcUI7UUFDeEUrSCxXQUFXRDtRQUNYTixTQUFTTSxPQUFPOUgsWUFBWWlpQixVQUFVO0lBQ3hDO0FBQ0Y7QUFFQTs7OztDQUlDLEdBQ0QsU0FBU2hXO0lBQ1AsTUFBTWlFLFdBQVdILGFBQWFHLFFBQVEsQ0FBQzdSLEdBQUcsQ0FBQyxJQUFJO0lBQy9DLElBQUk2UixTQUFTNlEsaUJBQWlCLEVBQUU7UUFDOUI1WCxLQUFLK0csU0FBUzZRLGlCQUFpQjtJQUNqQztJQUNBLE1BQU1qWixRQUFRLElBQUksQ0FBQ3dXLFFBQVE7SUFDM0IsSUFBSXhXLE9BQU87UUFDVEEsTUFBTXFKLGVBQWUsQ0FBQztRQUN0QnJKLE1BQU1xSixlQUFlLENBQUM7UUFDdEIxSSxZQUFZWCxPQUFPOUgsWUFBWWlpQixVQUFVO0lBQzNDO0FBQ0Y7QUFFQSxNQUFNQyxnQkFBZ0I7SUFDcEJ2ZixPQUFPO0lBQ1BpVSxXQUFXO0lBQ1gxRSxNQUFNO0lBQ05wTSxNQUFNO0lBQ05qQyxRQUFRO0lBQ1J2RCxNQUFNbUI7SUFDTnlULFdBQVd6VDtJQUNYc1MsVUFBVXRTO0lBQ1YwZ0IsVUFBVTFnQjtJQUNWZ0UsT0FBTztJQUNQZ0ksV0FBVztJQUNYckcsV0FBVztRQUNUN0UsT0FBTztRQUNQaU4sVUFBVTtRQUNWbFAsTUFBTTtJQUNSO0lBQ0EwYyxXQUFXO1FBQ1R6YSxPQUFPO1FBQ1BpTixVQUFVO1FBQ1ZsUCxNQUFNO0lBQ1I7SUFDQWlILGFBQWEsQ0FBQztJQUNkYSxRQUFRO0lBQ1IrTSxPQUFPMVQ7SUFDUCtOLFVBQVU7SUFDVjRTLFlBQVk7SUFDWkMsbUJBQW1CO0lBQ25CckksZ0JBQWdCO0lBQ2hCVixlQUFlO0lBQ2ZQLHdCQUF3QjtJQUN4QmIsd0JBQXdCO0lBQ3hCdEssbUJBQW1CO0lBQ25CQyxnQkFBZ0I7SUFDaEJDLGtCQUFrQjtJQUNsQjRULFlBQVlqZ0I7SUFDWjJmLFNBQVMzZjtJQUNUNmdCLG1CQUFtQjtJQUNuQkMsd0JBQXdCO0lBQ3hCN1Qsb0JBQW9Cak47SUFDcEIrZ0IsZ0JBQWdCO0lBQ2hCQyxxQkFBcUI7SUFDckI3VCxpQkFBaUJuTjtJQUNqQmloQixrQkFBa0I7SUFDbEJDLHVCQUF1QjtJQUN2QjlULG1CQUFtQnBOO0lBQ25CK00sZ0JBQWdCO0lBQ2hCRixnQkFBZ0I7SUFDaEJzVSxjQUFjO0lBQ2RDLFdBQVc7SUFDWEMsYUFBYTtJQUNiM2pCLGFBQWE7SUFDYmlRLGlCQUFpQjtJQUNqQkQsaUJBQWlCO0lBQ2pCRSxzQkFBc0I7SUFDdEJyQixZQUFZO0lBQ1p5VCxxQkFBcUI7SUFDckJOLGtCQUFrQjtJQUNsQjNMLFVBQVUvVDtJQUNWaVUsWUFBWWpVO0lBQ1prVSxhQUFhbFU7SUFDYmdVLFVBQVU7SUFDVjdLLE9BQU9uSjtJQUNQcUosa0JBQWtCO0lBQ2xCRSxPQUFPdko7SUFDUG9VLFNBQVNwVTtJQUNUb08sWUFBWXBPO0lBQ1pxRyxPQUFPckc7SUFDUDhQLGtCQUFrQjtJQUNsQkcsWUFBWTtJQUNaTyxZQUFZO0lBQ1o0TSxjQUFjLENBQUM7SUFDZi9OLGdCQUFnQjtJQUNoQjROLGVBQWU7SUFDZmxPLGlCQUFpQixDQUFDO0lBQ2xCa1EsZ0JBQWdCamY7SUFDaEIrZSx3QkFBd0I7SUFDeEJPLG1CQUFtQnRmO0lBQ25CbU8sTUFBTTtJQUNORixVQUFVO0lBQ1Z3RyxlQUFlLEVBQUU7SUFDakJDLHFCQUFxQjFVO0lBQ3JCaVYsdUJBQXVCalY7SUFDdkJzaEIsVUFBVXRoQjtJQUNWdWhCLFNBQVN2aEI7SUFDVHFWLFdBQVdyVjtJQUNYK2IsV0FBVy9iO0lBQ1g2YSxVQUFVN2E7SUFDVndoQixZQUFZeGhCO0lBQ1p5aEIsa0JBQWtCO0FBQ3BCO0FBQ0EsTUFBTUMsa0JBQWtCO0lBQUM7SUFBa0I7SUFBcUI7SUFBYztJQUFrQjtJQUF5QjtJQUFxQjtJQUFvQjtJQUF3QjtJQUFtQjtJQUFTO0lBQTBCO0lBQXNCO0lBQXFCO0lBQXVCO0lBQWU7SUFBdUI7SUFBbUI7SUFBa0I7SUFBWTtJQUFjO0lBQVU7SUFBYTtJQUFRO0lBQVE7SUFBYTtJQUFZO0lBQVk7SUFBZTtJQUFZO0lBQWM7SUFBYztJQUFXO0lBQWlCO0lBQWU7SUFBa0I7SUFBb0I7SUFBbUI7SUFBcUI7SUFBa0I7SUFBUTtJQUFTO0lBQWE7Q0FBWTtBQUUvc0IsK0NBQStDLEdBQy9DLE1BQU1DLG1CQUFtQjtJQUN2QjlKLGVBQWU3WDtBQUNqQjtBQUNBLE1BQU00aEIsMEJBQTBCO0lBQUM7SUFBcUI7SUFBaUI7SUFBWTtJQUFnQjtJQUFhO0lBQWU7SUFBZTtJQUFjO0NBQXlCO0FBRXJMOzs7OztDQUtDLEdBQ0QsTUFBTUMsbUJBQW1CQyxDQUFBQTtJQUN2QixPQUFPcmMsT0FBT3NjLFNBQVMsQ0FBQ0MsY0FBYyxDQUFDQyxJQUFJLENBQUN4QixlQUFlcUI7QUFDN0Q7QUFFQTs7Ozs7Q0FLQyxHQUNELE1BQU1JLHVCQUF1QkosQ0FBQUE7SUFDM0IsT0FBT0osZ0JBQWdCblAsT0FBTyxDQUFDdVAsZUFBZSxDQUFDO0FBQ2pEO0FBRUE7Ozs7O0NBS0MsR0FDRCxNQUFNSyx3QkFBd0JMLENBQUFBO0lBQzVCLE9BQU9ILGdCQUFnQixDQUFDRyxVQUFVO0FBQ3BDO0FBRUE7O0NBRUMsR0FDRCxNQUFNTSxzQkFBc0I1VyxDQUFBQTtJQUMxQixJQUFJLENBQUNxVyxpQkFBaUJyVyxRQUFRO1FBQzVCcE0sS0FBSyxDQUFDLG1CQUFtQixFQUFFb00sTUFBTSxDQUFDLENBQUM7SUFDckM7QUFDRjtBQUVBOztDQUVDLEdBQ0QsTUFBTTZXLDJCQUEyQjdXLENBQUFBO0lBQy9CLElBQUlvVyx3QkFBd0JqaUIsUUFBUSxDQUFDNkwsUUFBUTtRQUMzQ3BNLEtBQUssQ0FBQyxlQUFlLEVBQUVvTSxNQUFNLDZCQUE2QixDQUFDO0lBQzdEO0FBQ0Y7QUFFQTs7Q0FFQyxHQUNELE1BQU04VywyQkFBMkI5VyxDQUFBQTtJQUMvQixNQUFNK1csZUFBZUosc0JBQXNCM1c7SUFDM0MsSUFBSStXLGNBQWM7UUFDaEIxaUIscUJBQXFCMkwsT0FBTytXO0lBQzlCO0FBQ0Y7QUFFQTs7OztDQUlDLEdBQ0QsTUFBTUMsd0JBQXdCaGQsQ0FBQUE7SUFDNUIsSUFBSUEsT0FBT3VJLFFBQVEsS0FBSyxTQUFTdkksT0FBT29iLGlCQUFpQixFQUFFO1FBQ3pEeGhCLEtBQUs7SUFDUDtJQUNBLElBQUssTUFBTW9NLFNBQVNoRyxPQUFRO1FBQzFCNGMsb0JBQW9CNVc7UUFDcEIsSUFBSWhHLE9BQU94QixLQUFLLEVBQUU7WUFDaEJxZSx5QkFBeUI3VztRQUMzQjtRQUNBOFcseUJBQXlCOVc7SUFDM0I7QUFDRjtBQUVBOzs7O0NBSUMsR0FDRCxTQUFTaVgsT0FBT2pkLE1BQU07SUFDcEIsTUFBTTFFLFFBQVFEO0lBQ2QsTUFBTTBOLGNBQWNELGFBQWFDLFdBQVcsQ0FBQzNSLEdBQUcsQ0FBQyxJQUFJO0lBQ3JELElBQUksQ0FBQ2tFLFNBQVMrQyxTQUFTL0MsT0FBT3lOLFlBQVlnTixTQUFTLENBQUN6YSxLQUFLLEdBQUc7UUFDMUQxQixLQUFLLENBQUMsMElBQTBJLENBQUM7UUFDako7SUFDRjtJQUNBLE1BQU1zakIsdUJBQXVCQyxrQkFBa0JuZDtJQUMvQyxNQUFNb2QsZ0JBQWdCbmQsT0FBT29XLE1BQU0sQ0FBQyxDQUFDLEdBQUd0TixhQUFhbVU7SUFDckR0TixPQUFPLElBQUksRUFBRXdOO0lBQ2J0VSxhQUFhQyxXQUFXLENBQUN6UixHQUFHLENBQUMsSUFBSSxFQUFFOGxCO0lBQ25DbmQsT0FBT29kLGdCQUFnQixDQUFDLElBQUksRUFBRTtRQUM1QnJkLFFBQVE7WUFDTmlCLE9BQU9oQixPQUFPb1csTUFBTSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUNyVyxNQUFNLEVBQUVBO1lBQ3RDc2QsVUFBVTtZQUNWQyxZQUFZO1FBQ2Q7SUFDRjtBQUNGO0FBRUE7OztDQUdDLEdBQ0QsTUFBTUosb0JBQW9CbmQsQ0FBQUE7SUFDeEIsTUFBTWtkLHVCQUF1QixDQUFDO0lBQzlCamQsT0FBTzBKLElBQUksQ0FBQzNKLFFBQVFYLE9BQU8sQ0FBQzJHLENBQUFBO1FBQzFCLElBQUkwVyxxQkFBcUIxVyxRQUFRO1lBQy9Ca1gsb0JBQW9CLENBQUNsWCxNQUFNLEdBQUdoRyxNQUFNLENBQUNnRyxNQUFNO1FBQzdDLE9BQU87WUFDTHBNLEtBQUssQ0FBQyw2QkFBNkIsRUFBRW9NLE1BQU0sQ0FBQztRQUM5QztJQUNGO0lBQ0EsT0FBT2tYO0FBQ1Q7QUFFQTs7Q0FFQyxHQUNELFNBQVNoSDtJQUNQLE1BQU1qTixXQUFXSCxhQUFhRyxRQUFRLENBQUM3UixHQUFHLENBQUMsSUFBSTtJQUMvQyxNQUFNMlIsY0FBY0QsYUFBYUMsV0FBVyxDQUFDM1IsR0FBRyxDQUFDLElBQUk7SUFDckQsSUFBSSxDQUFDMlIsYUFBYTtRQUNoQnlVLGdCQUFnQixJQUFJLEdBQUcsMkdBQTJHO1FBQ2xJLFFBQVEsMkNBQTJDO0lBQ3JEO0lBRUEseUNBQXlDO0lBQ3pDLElBQUl2VSxTQUFTM04sS0FBSyxJQUFJNUQsWUFBWStlLDhCQUE4QixFQUFFO1FBQ2hFL2UsWUFBWStlLDhCQUE4QjtRQUMxQyxPQUFPL2UsWUFBWStlLDhCQUE4QjtJQUNuRDtJQUNBLElBQUksT0FBTzFOLFlBQVlpVCxVQUFVLEtBQUssWUFBWTtRQUNoRGpULFlBQVlpVCxVQUFVO0lBQ3hCO0lBQ0F0a0IsWUFBWW9ZLFlBQVksQ0FBQ0MsSUFBSSxDQUFDO0lBQzlCME4sWUFBWSxJQUFJO0FBQ2xCO0FBRUE7O0NBRUMsR0FDRCxNQUFNQSxjQUFjL1csQ0FBQUE7SUFDbEI4VyxnQkFBZ0I5VztJQUNoQixrREFBa0Q7SUFDbEQsT0FBT0EsU0FBUzFHLE1BQU07SUFDdEIsaUVBQWlFO0lBQ2pFLE9BQU90SSxZQUFZcVosY0FBYztJQUNqQyxPQUFPclosWUFBWWtaLGFBQWE7SUFDaEMsd0JBQXdCO0lBQ3hCLE9BQU9sWixZQUFZcU4sZUFBZTtBQUNwQztBQUVBOztDQUVDLEdBQ0QsTUFBTXlZLGtCQUFrQjlXLENBQUFBO0lBQ3RCLDJJQUEySTtJQUMzSSxJQUFJQSxTQUFTa1AsaUJBQWlCLEVBQUU7UUFDOUI4SCxjQUFjNVUsY0FBY3BDO1FBQzVCQSxTQUFTa1AsaUJBQWlCLEdBQUc7SUFDL0IsT0FBTztRQUNMOEgsY0FBYzFLLGdCQUFnQnRNO1FBQzlCZ1gsY0FBYzVVLGNBQWNwQztRQUM1QixPQUFPQSxTQUFTa1AsaUJBQWlCO1FBQ2pDLHlCQUF5QjtRQUN6QixPQUFPbFAsU0FBUzBTLGNBQWM7UUFDOUIsT0FBTzFTLFNBQVNrVCxhQUFhO1FBQzdCLE9BQU9sVCxTQUFTMlEsUUFBUTtRQUN4QixPQUFPM1EsU0FBU3FULFlBQVk7UUFDNUIsT0FBT3JULFNBQVN1VCxXQUFXO1FBQzNCLE9BQU92VCxTQUFTc1IsV0FBVztRQUMzQixPQUFPdFIsU0FBU2lYLGNBQWM7UUFDOUIsT0FBT2pYLFNBQVNtVCxxQkFBcUI7UUFDckMsT0FBT25ULFNBQVMxQixzQkFBc0I7UUFDdEMsT0FBTzBCLFNBQVMzSixLQUFLO1FBQ3JCLE9BQU8ySixTQUFTa1gsVUFBVTtRQUMxQixPQUFPbFgsU0FBU21YLFVBQVU7UUFDMUIsT0FBT25YLFNBQVNvWCxVQUFVO1FBQzFCLE9BQU9wWCxTQUFTdVAsYUFBYTtRQUM3QixPQUFPdlAsU0FBU3VXLE1BQU07UUFDdEIsT0FBT3ZXLFNBQVN3UCxRQUFRO0lBQzFCO0FBQ0Y7QUFFQTs7O0NBR0MsR0FDRCxNQUFNd0gsZ0JBQWdCLENBQUNLLEtBQUtyWDtJQUMxQixJQUFLLE1BQU03RyxLQUFLa2UsSUFBSztRQUNuQkEsR0FBRyxDQUFDbGUsRUFBRSxDQUFDbWUsTUFBTSxDQUFDdFg7SUFDaEI7QUFDRjtBQUVBLElBQUl1WCxrQkFBa0IsV0FBVyxHQUFFaGUsT0FBT3dRLE1BQU0sQ0FBQztJQUMvQ3lOLFdBQVc7SUFDWGhJLFVBQVVBO0lBQ1ZuWixPQUFPQTtJQUNQOGdCLFlBQVk5Z0I7SUFDWjZnQixZQUFZN2dCO0lBQ1orZ0IsWUFBWS9nQjtJQUNacWMsZ0JBQWdCQTtJQUNoQlcsY0FBY0E7SUFDZDRELGdCQUFnQjNGO0lBQ2hCNEIsZUFBZUE7SUFDZkssYUFBYUE7SUFDYjVDLFVBQVVBO0lBQ1Z2Qix1QkFBdUJBO0lBQ3ZCa0MsYUFBYUE7SUFDYi9CLGVBQWVBO0lBQ2ZqUix3QkFBd0JBO0lBQ3hCNlUsdUJBQXVCQTtJQUN2Qm9ELFFBQVFBO0FBQ1Y7QUFFQTs7OztDQUlDLEdBQ0QsTUFBTWtCLG1CQUFtQixDQUFDcFYsYUFBYUUsVUFBVWtJO0lBQy9DLElBQUlwSSxZQUFZdkssS0FBSyxFQUFFO1FBQ3JCNGYsaUJBQWlCclYsYUFBYUUsVUFBVWtJO0lBQzFDLE9BQU87UUFDTCxtRkFBbUY7UUFDbkYsK0NBQStDO1FBQy9Da04scUJBQXFCcFY7UUFFckIsbUZBQW1GO1FBQ25GcVYseUJBQXlCclY7UUFDekJzVixpQkFBaUJ4VixhQUFhRSxVQUFVa0k7SUFDMUM7QUFDRjtBQUVBOzs7O0NBSUMsR0FDRCxNQUFNaU4sbUJBQW1CLENBQUNyVixhQUFhRSxVQUFVa0k7SUFDL0Msa0NBQWtDO0lBQ2xDbEksU0FBUzNOLEtBQUssQ0FBQ2tqQixPQUFPLEdBQUc7UUFDdkIsSUFBSXpWLGVBQWdCMFYsQ0FBQUEsaUJBQWlCMVYsZ0JBQWdCQSxZQUFZcEYsS0FBSyxJQUFJb0YsWUFBWWxJLEtBQUssR0FBRztZQUM1RjtRQUNGO1FBQ0FzUSxZQUFZWCxjQUFjelQsS0FBSztJQUNqQztBQUNGO0FBRUE7OztDQUdDLEdBQ0QsTUFBTTBoQixtQkFBbUIxVixDQUFBQTtJQUN2QixPQUFPLENBQUMsQ0FBRUEsQ0FBQUEsWUFBWXBDLGlCQUFpQixJQUFJb0MsWUFBWW5DLGNBQWMsSUFBSW1DLFlBQVlsQyxnQkFBZ0IsSUFBSWtDLFlBQVlaLGVBQWU7QUFDdEk7QUFDQSxJQUFJdVcscUJBQXFCO0FBRXpCOztDQUVDLEdBQ0QsTUFBTUwsdUJBQXVCcFYsQ0FBQUE7SUFDM0JBLFNBQVMzTixLQUFLLENBQUNxakIsV0FBVyxHQUFHO1FBQzNCMVYsU0FBU2hPLFNBQVMsQ0FBQzJqQixTQUFTLEdBQUcsU0FBVW5vQixDQUFDO1lBQ3hDd1MsU0FBU2hPLFNBQVMsQ0FBQzJqQixTQUFTLEdBQUcsS0FBTztZQUN0QyxrRkFBa0Y7WUFDbEYsb0RBQW9EO1lBQ3BELElBQUlub0IsRUFBRTBLLE1BQU0sS0FBSzhILFNBQVNoTyxTQUFTLEVBQUU7Z0JBQ25DeWpCLHFCQUFxQjtZQUN2QjtRQUNGO0lBQ0Y7QUFDRjtBQUVBOztDQUVDLEdBQ0QsTUFBTUosMkJBQTJCclYsQ0FBQUE7SUFDL0JBLFNBQVNoTyxTQUFTLENBQUMwakIsV0FBVyxHQUFHbG9CLENBQUFBO1FBQy9CLHlHQUF5RztRQUN6RyxJQUFJQSxFQUFFMEssTUFBTSxLQUFLOEgsU0FBU2hPLFNBQVMsRUFBRTtZQUNuQ3hFLEVBQUU4YixjQUFjO1FBQ2xCO1FBQ0F0SixTQUFTM04sS0FBSyxDQUFDc2pCLFNBQVMsR0FBRyxTQUFVbm9CLENBQUM7WUFDcEN3UyxTQUFTM04sS0FBSyxDQUFDc2pCLFNBQVMsR0FBRyxLQUFPO1lBQ2xDLHNFQUFzRTtZQUN0RSxJQUFJbm9CLEVBQUUwSyxNQUFNLEtBQUs4SCxTQUFTM04sS0FBSyxJQUFJN0UsRUFBRTBLLE1BQU0sWUFBWXRKLGVBQWVvUixTQUFTM04sS0FBSyxDQUFDd0UsUUFBUSxDQUFDckosRUFBRTBLLE1BQU0sR0FBRztnQkFDdkd1ZCxxQkFBcUI7WUFDdkI7UUFDRjtJQUNGO0FBQ0Y7QUFFQTs7OztDQUlDLEdBQ0QsTUFBTUgsbUJBQW1CLENBQUN4VixhQUFhRSxVQUFVa0k7SUFDL0NsSSxTQUFTaE8sU0FBUyxDQUFDdWpCLE9BQU8sR0FBRy9uQixDQUFBQTtRQUMzQixJQUFJaW9CLG9CQUFvQjtZQUN0QkEscUJBQXFCO1lBQ3JCO1FBQ0Y7UUFDQSxJQUFJam9CLEVBQUUwSyxNQUFNLEtBQUs4SCxTQUFTaE8sU0FBUyxJQUFJUixlQUFlc08sWUFBWXFTLGlCQUFpQixHQUFHO1lBQ3BGakssWUFBWVgsY0FBY2pJLFFBQVE7UUFDcEM7SUFDRjtBQUNGO0FBRUEsTUFBTXNXLGtCQUFrQmpnQixDQUFBQSxPQUFRLE9BQU9BLFNBQVMsWUFBWUEsS0FBS3NILE1BQU07QUFDdkUsTUFBTTRZLFlBQVlsZ0IsQ0FBQUEsT0FBUUEsZ0JBQWdCbWdCLFdBQVdGLGdCQUFnQmpnQjtBQUNyRSxNQUFNb2dCLGVBQWVDLENBQUFBO0lBQ25CLE1BQU1qZixTQUFTLENBQUM7SUFDaEIsSUFBSSxPQUFPaWYsSUFBSSxDQUFDLEVBQUUsS0FBSyxZQUFZLENBQUNILFVBQVVHLElBQUksQ0FBQyxFQUFFLEdBQUc7UUFDdERoZixPQUFPb1csTUFBTSxDQUFDclcsUUFBUWlmLElBQUksQ0FBQyxFQUFFO0lBQy9CLE9BQU87UUFDTDtZQUFDO1lBQVM7WUFBUTtTQUFPLENBQUM1ZixPQUFPLENBQUMsQ0FBQzRLLE1BQU1tRjtZQUN2QyxNQUFNMVUsTUFBTXVrQixJQUFJLENBQUM3UCxNQUFNO1lBQ3ZCLElBQUksT0FBTzFVLFFBQVEsWUFBWW9rQixVQUFVcGtCLE1BQU07Z0JBQzdDc0YsTUFBTSxDQUFDaUssS0FBSyxHQUFHdlA7WUFDakIsT0FBTyxJQUFJQSxRQUFRRixXQUFXO2dCQUM1QlIsTUFBTSxDQUFDLG1CQUFtQixFQUFFaVEsS0FBSyxzQ0FBc0MsRUFBRSxPQUFPdlAsSUFBSSxDQUFDO1lBQ3ZGO1FBQ0Y7SUFDRjtJQUNBLE9BQU9zRjtBQUNUO0FBRUE7Ozs7O0NBS0MsR0FDRCxTQUFTa2Y7SUFDUCxJQUFLLElBQUlDLE9BQU90b0IsVUFBVUMsTUFBTSxFQUFFbW9CLE9BQU8sSUFBSTVoQixNQUFNOGhCLE9BQU9DLE9BQU8sR0FBR0EsT0FBT0QsTUFBTUMsT0FBUTtRQUN2RkgsSUFBSSxDQUFDRyxLQUFLLEdBQUd2b0IsU0FBUyxDQUFDdW9CLEtBQUs7SUFDOUI7SUFDQSxPQUFPLElBQUksSUFBSSxJQUFJSDtBQUNyQjtBQUVBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FrQkMsR0FDRCxTQUFTSSxNQUFNQyxXQUFXO0lBQ3hCLE1BQU1DLGtCQUFrQixJQUFJO1FBQzFCQyxNQUFNeGYsTUFBTSxFQUFFeWYsbUJBQW1CLEVBQUU7WUFDakMsT0FBTyxLQUFLLENBQUNELE1BQU14ZixRQUFRQyxPQUFPb1csTUFBTSxDQUFDLENBQUMsR0FBR2lKLGFBQWFHO1FBQzVEO0lBQ0Y7SUFDQSxhQUFhO0lBQ2IsT0FBT0Y7QUFDVDtBQUVBOzs7OztDQUtDLEdBQ0QsTUFBTUcsZUFBZTtJQUNuQixPQUFPaG9CLFlBQVlpb0IsT0FBTyxJQUFJam9CLFlBQVlpb0IsT0FBTyxDQUFDRCxZQUFZO0FBQ2hFO0FBRUE7Ozs7O0NBS0MsR0FDRCxNQUFNRSxZQUFZO0lBQ2hCLElBQUlsb0IsWUFBWWlvQixPQUFPLEVBQUU7UUFDdkIzYjtRQUNBLE9BQU90TSxZQUFZaW9CLE9BQU8sQ0FBQ0UsSUFBSTtJQUNqQztBQUNGO0FBRUE7Ozs7O0NBS0MsR0FDRCxNQUFNQyxjQUFjO0lBQ2xCLElBQUlwb0IsWUFBWWlvQixPQUFPLEVBQUU7UUFDdkIsTUFBTUksWUFBWXJvQixZQUFZaW9CLE9BQU8sQ0FBQ0ssS0FBSztRQUMzQ3RjLHdCQUF3QnFjO1FBQ3hCLE9BQU9BO0lBQ1Q7QUFDRjtBQUVBOzs7OztDQUtDLEdBQ0QsTUFBTUUsY0FBYztJQUNsQixNQUFNdGMsUUFBUWpNLFlBQVlpb0IsT0FBTztJQUNqQyxPQUFPaGMsU0FBVUEsQ0FBQUEsTUFBTXVjLE9BQU8sR0FBR04sY0FBY0UsYUFBWTtBQUM3RDtBQUVBOzs7Ozs7Q0FNQyxHQUNELE1BQU1LLGdCQUFnQkMsQ0FBQUE7SUFDcEIsSUFBSTFvQixZQUFZaW9CLE9BQU8sRUFBRTtRQUN2QixNQUFNSSxZQUFZcm9CLFlBQVlpb0IsT0FBTyxDQUFDVSxRQUFRLENBQUNEO1FBQy9DMWMsd0JBQXdCcWMsV0FBVztRQUNuQyxPQUFPQTtJQUNUO0FBQ0Y7QUFFQTs7Ozs7O0NBTUMsR0FDRCxNQUFNTyxpQkFBaUI7SUFDckIsT0FBTyxDQUFDLENBQUU1b0IsQ0FBQUEsWUFBWWlvQixPQUFPLElBQUlqb0IsWUFBWWlvQixPQUFPLENBQUNZLFNBQVMsRUFBQztBQUNqRTtBQUVBLElBQUlDLHlCQUF5QjtBQUM3QixNQUFNQyxnQkFBZ0IsQ0FBQztBQUV2Qjs7Q0FFQyxHQUNELFNBQVNDO0lBQ1AsSUFBSXZXLE9BQU90VCxVQUFVQyxNQUFNLEdBQUcsS0FBS0QsU0FBUyxDQUFDLEVBQUUsS0FBSzJELFlBQVkzRCxTQUFTLENBQUMsRUFBRSxHQUFHO0lBQy9FNHBCLGFBQWEsQ0FBQ3RXLEtBQUssR0FBRyxJQUFJO0lBQzFCLElBQUksQ0FBQ3FXLHdCQUF3QjtRQUMzQnpvQixTQUFTQyxJQUFJLENBQUNvWixnQkFBZ0IsQ0FBQyxTQUFTdVA7UUFDeENILHlCQUF5QjtJQUMzQjtBQUNGO0FBQ0EsTUFBTUcsb0JBQW9CaFAsQ0FBQUE7SUFDeEIsSUFBSyxJQUFJM1QsS0FBSzJULE1BQU14USxNQUFNLEVBQUVuRCxNQUFNQSxPQUFPakcsVUFBVWlHLEtBQUtBLEdBQUc0aUIsVUFBVSxDQUFFO1FBQ3JFLElBQUssTUFBTXpXLFFBQVFzVyxjQUFlO1lBQ2hDLE1BQU12RixXQUFXbGQsR0FBR0wsWUFBWSxDQUFDd007WUFDakMsSUFBSStRLFVBQVU7Z0JBQ1p1RixhQUFhLENBQUN0VyxLQUFLLENBQUMrVSxJQUFJLENBQUM7b0JBQ3ZCaEU7Z0JBQ0Y7Z0JBQ0E7WUFDRjtRQUNGO0lBQ0Y7QUFDRjtBQUVBLGlHQUFpRztBQUVqRyxNQUFNMkY7SUFDSkMsYUFBYztRQUNaLG1CQUFtQixHQUNuQixJQUFJLENBQUNDLE1BQU0sR0FBRyxDQUFDO0lBQ2pCO0lBRUE7OztHQUdDLEdBQ0RDLHdCQUF3QkMsU0FBUyxFQUFFO1FBQ2pDLElBQUksT0FBTyxJQUFJLENBQUNGLE1BQU0sQ0FBQ0UsVUFBVSxLQUFLLGFBQWE7WUFDakQsaURBQWlEO1lBQ2pELDhFQUE4RTtZQUM5RSxJQUFJLENBQUNGLE1BQU0sQ0FBQ0UsVUFBVSxHQUFHLEVBQUU7UUFDN0I7UUFDQSxPQUFPLElBQUksQ0FBQ0YsTUFBTSxDQUFDRSxVQUFVO0lBQy9CO0lBRUE7OztHQUdDLEdBQ0RDLEdBQUdELFNBQVMsRUFBRUUsWUFBWSxFQUFFO1FBQzFCLE1BQU1DLGtCQUFrQixJQUFJLENBQUNKLHVCQUF1QixDQUFDQztRQUNyRCxJQUFJLENBQUNHLGdCQUFnQmpuQixRQUFRLENBQUNnbkIsZUFBZTtZQUMzQ0MsZ0JBQWdCaG5CLElBQUksQ0FBQyttQjtRQUN2QjtJQUNGO0lBRUE7OztHQUdDLEdBQ0RFLEtBQUtKLFNBQVMsRUFBRUUsWUFBWSxFQUFFO1FBQzVCLElBQUlHLFFBQVEsSUFBSTtRQUNoQjs7S0FFQyxHQUNELE1BQU1DLFNBQVM7WUFDYkQsTUFBTUUsY0FBYyxDQUFDUCxXQUFXTTtZQUNoQyxJQUFLLElBQUlwQyxPQUFPdG9CLFVBQVVDLE1BQU0sRUFBRW1vQixPQUFPLElBQUk1aEIsTUFBTThoQixPQUFPQyxPQUFPLEdBQUdBLE9BQU9ELE1BQU1DLE9BQVE7Z0JBQ3ZGSCxJQUFJLENBQUNHLEtBQUssR0FBR3ZvQixTQUFTLENBQUN1b0IsS0FBSztZQUM5QjtZQUNBK0IsYUFBYU0sS0FBSyxDQUFDSCxPQUFPckM7UUFDNUI7UUFDQSxJQUFJLENBQUNpQyxFQUFFLENBQUNELFdBQVdNO0lBQ3JCO0lBRUE7OztHQUdDLEdBQ0R4UixLQUFLa1IsU0FBUyxFQUFFO1FBQ2QsSUFBSyxJQUFJUyxRQUFRN3FCLFVBQVVDLE1BQU0sRUFBRW1vQixPQUFPLElBQUk1aEIsTUFBTXFrQixRQUFRLElBQUlBLFFBQVEsSUFBSSxJQUFJQyxRQUFRLEdBQUdBLFFBQVFELE9BQU9DLFFBQVM7WUFDakgxQyxJQUFJLENBQUMwQyxRQUFRLEVBQUUsR0FBRzlxQixTQUFTLENBQUM4cUIsTUFBTTtRQUNwQztRQUNBLElBQUksQ0FBQ1gsdUJBQXVCLENBQUNDLFdBQVc1aEIsT0FBTyxDQUMvQzs7S0FFQyxHQUNEOGhCLENBQUFBO1lBQ0UsSUFBSTtnQkFDRkEsYUFBYU0sS0FBSyxDQUFDLElBQUksRUFBRXhDO1lBQzNCLEVBQUUsT0FBT2psQixPQUFPO2dCQUNkRixRQUFRRSxLQUFLLENBQUNBO1lBQ2hCO1FBQ0Y7SUFDRjtJQUVBOzs7R0FHQyxHQUNEd25CLGVBQWVQLFNBQVMsRUFBRUUsWUFBWSxFQUFFO1FBQ3RDLE1BQU1DLGtCQUFrQixJQUFJLENBQUNKLHVCQUF1QixDQUFDQztRQUNyRCxNQUFNN1IsUUFBUWdTLGdCQUFnQnJVLE9BQU8sQ0FBQ29VO1FBQ3RDLElBQUkvUixRQUFRLENBQUMsR0FBRztZQUNkZ1MsZ0JBQWdCUSxNQUFNLENBQUN4UyxPQUFPO1FBQ2hDO0lBQ0Y7SUFFQTs7R0FFQyxHQUNEeVMsbUJBQW1CWixTQUFTLEVBQUU7UUFDNUIsSUFBSSxJQUFJLENBQUNGLE1BQU0sQ0FBQ0UsVUFBVSxLQUFLem1CLFdBQVc7WUFDeEMsOEVBQThFO1lBQzlFLElBQUksQ0FBQ3VtQixNQUFNLENBQUNFLFVBQVUsQ0FBQ25xQixNQUFNLEdBQUc7UUFDbEM7SUFDRjtJQUNBOE0sUUFBUTtRQUNOLElBQUksQ0FBQ21kLE1BQU0sR0FBRyxDQUFDO0lBQ2pCO0FBQ0Y7QUFFQXJwQixZQUFZb1ksWUFBWSxHQUFHLElBQUkrUTtBQUUvQjs7O0NBR0MsR0FDRCxNQUFNSyxLQUFLLENBQUNELFdBQVdFO0lBQ3JCenBCLFlBQVlvWSxZQUFZLENBQUNvUixFQUFFLENBQUNELFdBQVdFO0FBQ3pDO0FBRUE7OztDQUdDLEdBQ0QsTUFBTUUsT0FBTyxDQUFDSixXQUFXRTtJQUN2QnpwQixZQUFZb1ksWUFBWSxDQUFDdVIsSUFBSSxDQUFDSixXQUFXRTtBQUMzQztBQUVBOzs7Q0FHQyxHQUNELE1BQU1XLE1BQU0sQ0FBQ2IsV0FBV0U7SUFDdEIscUNBQXFDO0lBQ3JDLElBQUksQ0FBQ0YsV0FBVztRQUNkdnBCLFlBQVlvWSxZQUFZLENBQUNsTSxLQUFLO1FBQzlCO0lBQ0Y7SUFDQSxJQUFJdWQsY0FBYztRQUNoQiw0QkFBNEI7UUFDNUJ6cEIsWUFBWW9ZLFlBQVksQ0FBQzBSLGNBQWMsQ0FBQ1AsV0FBV0U7SUFDckQsT0FBTztRQUNMLDJDQUEyQztRQUMzQ3pwQixZQUFZb1ksWUFBWSxDQUFDK1Isa0JBQWtCLENBQUNaO0lBQzlDO0FBQ0Y7QUFFQSxJQUFJYyxnQkFBZ0IsV0FBVyxHQUFFOWhCLE9BQU93USxNQUFNLENBQUM7SUFDN0N5TixXQUFXO0lBQ1hjLGNBQWNBO0lBQ2QwQixrQkFBa0JBO0lBQ2xCcFEsYUFBYUE7SUFDYkwsY0FBY0E7SUFDZEcsV0FBV0E7SUFDWDRSLGVBQWVyTDtJQUNmdUksTUFBTUE7SUFDTnhpQixZQUFZQTtJQUNaUCxpQkFBaUJBO0lBQ2pCVyxnQkFBZ0JBO0lBQ2hCZCxrQkFBa0JBO0lBQ2xCakIsY0FBY0E7SUFDZHNCLGVBQWVBO0lBQ2ZZLHNCQUFzQkE7SUFDdEJOLFdBQVdBO0lBQ1hoQixrQkFBa0JBO0lBQ2xCSixTQUFTQTtJQUNUQyxnQkFBZ0JBO0lBQ2hCSSxVQUFVQTtJQUNWVyxlQUFlQTtJQUNmQyxXQUFXQTtJQUNYbkIsVUFBVUE7SUFDVlMsa0JBQWtCQTtJQUNsQjRqQixjQUFjQTtJQUNkN2lCLHFCQUFxQkE7SUFDckJwQixVQUFVQTtJQUNWTSxzQkFBc0JBO0lBQ3RCb2tCLGVBQWVBO0lBQ2Z4RCx1QkFBdUJBO0lBQ3ZCbGUsV0FBV0E7SUFDWDZoQixnQkFBZ0JBO0lBQ2hCNUQsc0JBQXNCQTtJQUN0Qkwsa0JBQWtCQTtJQUNsQnJNLFdBQVdBO0lBQ1hxUCxPQUFPQTtJQUNQeUMsS0FBS0E7SUFDTFosSUFBSUE7SUFDSkcsTUFBTUE7SUFDTnZCLGFBQWFBO0lBQ2JuSixhQUFhQTtJQUNiaUosV0FBV0E7SUFDWEssYUFBYUE7QUFDZjtBQUVBLE1BQU1nQztJQUNKOzs7R0FHQyxHQUNEbkIsWUFBWW9CLFFBQVEsRUFBRUMsS0FBSyxDQUFFO1FBQzNCLElBQUksQ0FBQ0QsUUFBUSxHQUFHQTtRQUNoQixJQUFJLENBQUNuQyxTQUFTLEdBQUdvQztRQUNqQixJQUFJLENBQUNqQyxPQUFPLEdBQUc7UUFDZixJQUFJLENBQUNGLEtBQUs7SUFDWjtJQUVBOztHQUVDLEdBQ0RBLFFBQVE7UUFDTixJQUFJLENBQUMsSUFBSSxDQUFDRSxPQUFPLEVBQUU7WUFDakIsSUFBSSxDQUFDQSxPQUFPLEdBQUc7WUFDZixJQUFJLENBQUNrQyxPQUFPLEdBQUcsSUFBSUM7WUFDbkIsSUFBSSxDQUFDMVgsRUFBRSxHQUFHaFMsV0FBVyxJQUFJLENBQUN1cEIsUUFBUSxFQUFFLElBQUksQ0FBQ25DLFNBQVM7UUFDcEQ7UUFDQSxPQUFPLElBQUksQ0FBQ0EsU0FBUztJQUN2QjtJQUVBOztHQUVDLEdBQ0RGLE9BQU87UUFDTCxJQUFJLElBQUksQ0FBQ3VDLE9BQU8sSUFBSSxJQUFJLENBQUNsQyxPQUFPLEVBQUU7WUFDaEMsSUFBSSxDQUFDQSxPQUFPLEdBQUc7WUFDZm9DLGFBQWEsSUFBSSxDQUFDM1gsRUFBRTtZQUNwQixJQUFJLENBQUNvVixTQUFTLElBQUksSUFBSXNDLE9BQU9FLE9BQU8sS0FBSyxJQUFJLENBQUNILE9BQU8sQ0FBQ0csT0FBTztRQUMvRDtRQUNBLE9BQU8sSUFBSSxDQUFDeEMsU0FBUztJQUN2QjtJQUVBOzs7R0FHQyxHQUNETSxTQUFTMXBCLENBQUMsRUFBRTtRQUNWLE1BQU11cEIsVUFBVSxJQUFJLENBQUNBLE9BQU87UUFDNUIsSUFBSUEsU0FBUztZQUNYLElBQUksQ0FBQ0wsSUFBSTtRQUNYO1FBQ0EsSUFBSSxDQUFDRSxTQUFTLElBQUlwcEI7UUFDbEIsSUFBSXVwQixTQUFTO1lBQ1gsSUFBSSxDQUFDRixLQUFLO1FBQ1o7UUFDQSxPQUFPLElBQUksQ0FBQ0QsU0FBUztJQUN2QjtJQUVBOztHQUVDLEdBQ0RMLGVBQWU7UUFDYixJQUFJLElBQUksQ0FBQ1EsT0FBTyxFQUFFO1lBQ2hCLElBQUksQ0FBQ0wsSUFBSTtZQUNULElBQUksQ0FBQ0csS0FBSztRQUNaO1FBQ0EsT0FBTyxJQUFJLENBQUNELFNBQVM7SUFDdkI7SUFFQTs7R0FFQyxHQUNEUSxZQUFZO1FBQ1YsT0FBTyxJQUFJLENBQUNMLE9BQU87SUFDckI7QUFDRjtBQUVBLE1BQU1zQyxtQkFBbUI7SUFBQztJQUFjO0lBQWE7Q0FBYztBQUVuRTs7O0NBR0MsR0FDRCxNQUFNQyxvQkFBb0J6aUIsQ0FBQUE7SUFDeEIsTUFBTWtiLFdBQVcsT0FBT2xiLE9BQU9rYixRQUFRLEtBQUssV0FBWSxnQ0FBZ0MsR0FBRW5qQixTQUFTaUQsYUFBYSxDQUFDZ0YsT0FBT2tiLFFBQVEsSUFBS2xiLE9BQU9rYixRQUFRO0lBQ3BKLElBQUksQ0FBQ0EsVUFBVTtRQUNiLE9BQU8sQ0FBQztJQUNWO0lBQ0EsNkJBQTZCLEdBQzdCLE1BQU13SCxrQkFBa0J4SCxTQUFTN00sT0FBTztJQUN4Q3NVLHdCQUF3QkQ7SUFDeEIsTUFBTTFKLFNBQVMvWSxPQUFPb1csTUFBTSxDQUFDdU0sY0FBY0Ysa0JBQWtCRyxzQkFBc0JILGtCQUFrQkksZUFBZUosa0JBQWtCSyxhQUFhTCxrQkFBa0JNLFlBQVlOLGtCQUFrQk8sYUFBYVAsa0JBQWtCUSxvQkFBb0JSLGlCQUFpQkY7SUFDdlEsT0FBT3hKO0FBQ1Q7QUFFQTs7O0NBR0MsR0FDRCxNQUFNNEosZ0JBQWdCRixDQUFBQTtJQUNwQixnQ0FBZ0MsR0FDaEMsTUFBTTFKLFNBQVMsQ0FBQztJQUNoQiwwQkFBMEIsR0FDMUIsTUFBTW1LLGFBQWE5bEIsTUFBTUMsSUFBSSxDQUFDb2xCLGdCQUFnQnZsQixnQkFBZ0IsQ0FBQztJQUMvRGdtQixXQUFXOWpCLE9BQU8sQ0FBQzJHLENBQUFBO1FBQ2pCb2QsMEJBQTBCcGQsT0FBTztZQUFDO1lBQVE7U0FBUTtRQUNsRCxNQUFNc1csWUFBWSxvQ0FBb0MsR0FBRXRXLE1BQU1ySSxZQUFZLENBQUM7UUFDM0UsTUFBTXNELFFBQVErRSxNQUFNckksWUFBWSxDQUFDO1FBQ2pDLElBQUksQ0FBQzJlLGFBQWEsQ0FBQ3JiLE9BQU87WUFDeEI7UUFDRjtRQUNBLElBQUksT0FBT2dhLGFBQWEsQ0FBQ3FCLFVBQVUsS0FBSyxXQUFXO1lBQ2pEdEQsTUFBTSxDQUFDc0QsVUFBVSxHQUFHcmIsVUFBVTtRQUNoQyxPQUFPLElBQUksT0FBT2dhLGFBQWEsQ0FBQ3FCLFVBQVUsS0FBSyxVQUFVO1lBQ3ZEdEQsTUFBTSxDQUFDc0QsVUFBVSxHQUFHK0csS0FBS0MsS0FBSyxDQUFDcmlCO1FBQ2pDLE9BQU87WUFDTCtYLE1BQU0sQ0FBQ3NELFVBQVUsR0FBR3JiO1FBQ3RCO0lBQ0Y7SUFDQSxPQUFPK1g7QUFDVDtBQUVBOzs7Q0FHQyxHQUNELE1BQU02Six3QkFBd0JILENBQUFBO0lBQzVCLGdDQUFnQyxHQUNoQyxNQUFNMUosU0FBUyxDQUFDO0lBQ2hCLDBCQUEwQixHQUMxQixNQUFNdUssZ0JBQWdCbG1CLE1BQU1DLElBQUksQ0FBQ29sQixnQkFBZ0J2bEIsZ0JBQWdCLENBQUM7SUFDbEVvbUIsY0FBY2xrQixPQUFPLENBQUMyRyxDQUFBQTtRQUNwQixNQUFNc1csWUFBWSxvQ0FBb0MsR0FBRXRXLE1BQU1ySSxZQUFZLENBQUM7UUFDM0UsTUFBTXNELFFBQVErRSxNQUFNckksWUFBWSxDQUFDO1FBQ2pDLElBQUksQ0FBQzJlLGFBQWEsQ0FBQ3JiLE9BQU87WUFDeEI7UUFDRjtRQUNBK1gsTUFBTSxDQUFDc0QsVUFBVSxHQUFHLElBQUlrSCxTQUFTLENBQUMsT0FBTyxFQUFFdmlCLE1BQU0sQ0FBQztJQUNwRDtJQUNBLE9BQU8rWDtBQUNUO0FBRUE7OztDQUdDLEdBQ0QsTUFBTThKLGlCQUFpQkosQ0FBQUE7SUFDckIsZ0NBQWdDLEdBQ2hDLE1BQU0xSixTQUFTLENBQUM7SUFDaEIsMEJBQTBCLEdBQzFCLE1BQU15SyxjQUFjcG1CLE1BQU1DLElBQUksQ0FBQ29sQixnQkFBZ0J2bEIsZ0JBQWdCLENBQUM7SUFDaEVzbUIsWUFBWXBrQixPQUFPLENBQUN3SSxDQUFBQTtRQUNsQnViLDBCQUEwQnZiLFFBQVE7WUFBQztZQUFRO1lBQVM7U0FBYTtRQUNqRSxNQUFNOUcsT0FBTzhHLE9BQU9sSyxZQUFZLENBQUM7UUFDakMsSUFBSSxDQUFDb0QsUUFBUSxDQUFDO1lBQUM7WUFBVztZQUFVO1NBQU8sQ0FBQzVHLFFBQVEsQ0FBQzRHLE9BQU87WUFDMUQ7UUFDRjtRQUNBaVksTUFBTSxDQUFDLENBQUMsRUFBRWpZLEtBQUssVUFBVSxDQUFDLENBQUMsR0FBRzhHLE9BQU92RixTQUFTO1FBQzlDMFcsTUFBTSxDQUFDLENBQUMsSUFBSSxFQUFFemYsc0JBQXNCd0gsTUFBTSxNQUFNLENBQUMsQ0FBQyxHQUFHO1FBQ3JELElBQUk4RyxPQUFPbkosWUFBWSxDQUFDLFVBQVU7WUFDaENzYSxNQUFNLENBQUMsQ0FBQyxFQUFFalksS0FBSyxXQUFXLENBQUMsQ0FBQyxHQUFHOEcsT0FBT2xLLFlBQVksQ0FBQztRQUNyRDtRQUNBLElBQUlrSyxPQUFPbkosWUFBWSxDQUFDLGVBQWU7WUFDckNzYSxNQUFNLENBQUMsQ0FBQyxFQUFFalksS0FBSyxlQUFlLENBQUMsQ0FBQyxHQUFHOEcsT0FBT2xLLFlBQVksQ0FBQztRQUN6RDtJQUNGO0lBQ0EsT0FBT3FiO0FBQ1Q7QUFFQTs7O0NBR0MsR0FDRCxNQUFNK0osZUFBZUwsQ0FBQUE7SUFDbkIsTUFBTTFKLFNBQVMsQ0FBQztJQUNoQiwrQkFBK0IsR0FDL0IsTUFBTW5kLFFBQVE2bUIsZ0JBQWdCMW5CLGFBQWEsQ0FBQztJQUM1QyxJQUFJYSxPQUFPO1FBQ1R1bkIsMEJBQTBCdm5CLE9BQU87WUFBQztZQUFPO1lBQVM7WUFBVTtTQUFNO1FBQ2xFLElBQUlBLE1BQU02QyxZQUFZLENBQUMsUUFBUTtZQUM3QnNhLE9BQU96SyxRQUFRLEdBQUcxUyxNQUFNOEIsWUFBWSxDQUFDLFVBQVVuRDtRQUNqRDtRQUNBLElBQUlxQixNQUFNNkMsWUFBWSxDQUFDLFVBQVU7WUFDL0JzYSxPQUFPdkssVUFBVSxHQUFHNVMsTUFBTThCLFlBQVksQ0FBQyxZQUFZbkQ7UUFDckQ7UUFDQSxJQUFJcUIsTUFBTTZDLFlBQVksQ0FBQyxXQUFXO1lBQ2hDc2EsT0FBT3RLLFdBQVcsR0FBRzdTLE1BQU04QixZQUFZLENBQUMsYUFBYW5EO1FBQ3ZEO1FBQ0EsSUFBSXFCLE1BQU02QyxZQUFZLENBQUMsUUFBUTtZQUM3QnNhLE9BQU94SyxRQUFRLEdBQUczUyxNQUFNOEIsWUFBWSxDQUFDLFVBQVVuRDtRQUNqRDtJQUNGO0lBQ0EsT0FBT3dlO0FBQ1Q7QUFFQTs7O0NBR0MsR0FDRCxNQUFNZ0ssY0FBY04sQ0FBQUE7SUFDbEIsTUFBTTFKLFNBQVMsQ0FBQztJQUNoQiwrQkFBK0IsR0FDL0IsTUFBTTNmLE9BQU9xcEIsZ0JBQWdCMW5CLGFBQWEsQ0FBQztJQUMzQyxJQUFJM0IsTUFBTTtRQUNSK3BCLDBCQUEwQi9wQixNQUFNO1lBQUM7WUFBUTtTQUFRO1FBQ2pELElBQUlBLEtBQUtxRixZQUFZLENBQUMsU0FBUztZQUM3QnNhLE9BQU8zZixJQUFJLEdBQUdBLEtBQUtzRSxZQUFZLENBQUM7UUFDbEM7UUFDQSxJQUFJdEUsS0FBS3FGLFlBQVksQ0FBQyxVQUFVO1lBQzlCc2EsT0FBTy9LLFNBQVMsR0FBRzVVLEtBQUtzRSxZQUFZLENBQUM7UUFDdkM7UUFDQXFiLE9BQU9sTSxRQUFRLEdBQUd6VCxLQUFLaUosU0FBUztJQUNsQztJQUNBLE9BQU8wVztBQUNUO0FBRUE7OztDQUdDLEdBQ0QsTUFBTWlLLGVBQWVQLENBQUFBO0lBQ25CLGdDQUFnQyxHQUNoQyxNQUFNMUosU0FBUyxDQUFDO0lBQ2hCLCtCQUErQixHQUMvQixNQUFNblksUUFBUTZoQixnQkFBZ0IxbkIsYUFBYSxDQUFDO0lBQzVDLElBQUk2RixPQUFPO1FBQ1R1aUIsMEJBQTBCdmlCLE9BQU87WUFBQztZQUFRO1lBQVM7WUFBZTtTQUFRO1FBQzFFbVksT0FBT25ZLEtBQUssR0FBR0EsTUFBTWxELFlBQVksQ0FBQyxXQUFXO1FBQzdDLElBQUlrRCxNQUFNbkMsWUFBWSxDQUFDLFVBQVU7WUFDL0JzYSxPQUFPdk8sVUFBVSxHQUFHNUosTUFBTWxELFlBQVksQ0FBQztRQUN6QztRQUNBLElBQUlrRCxNQUFNbkMsWUFBWSxDQUFDLGdCQUFnQjtZQUNyQ3NhLE9BQU8xTyxnQkFBZ0IsR0FBR3pKLE1BQU1sRCxZQUFZLENBQUM7UUFDL0M7UUFDQSxJQUFJa0QsTUFBTW5DLFlBQVksQ0FBQyxVQUFVO1lBQy9Cc2EsT0FBT2hPLFVBQVUsR0FBR25LLE1BQU1sRCxZQUFZLENBQUM7UUFDekM7SUFDRjtJQUNBLDBCQUEwQixHQUMxQixNQUFNaWEsZUFBZXZhLE1BQU1DLElBQUksQ0FBQ29sQixnQkFBZ0J2bEIsZ0JBQWdCLENBQUM7SUFDakUsSUFBSXlhLGFBQWE5Z0IsTUFBTSxFQUFFO1FBQ3ZCa2lCLE9BQU9wQixZQUFZLEdBQUcsQ0FBQztRQUN2QkEsYUFBYXZZLE9BQU8sQ0FBQ2laLENBQUFBO1lBQ25COEssMEJBQTBCOUssUUFBUTtnQkFBQzthQUFRO1lBQzNDLE1BQU1ELGNBQWNDLE9BQU8zYSxZQUFZLENBQUM7WUFDeEMsSUFBSSxDQUFDMGEsYUFBYTtnQkFDaEI7WUFDRjtZQUNBLE1BQU1xTCxhQUFhcEwsT0FBT2hXLFNBQVM7WUFDbkMwVyxPQUFPcEIsWUFBWSxDQUFDUyxZQUFZLEdBQUdxTDtRQUNyQztJQUNGO0lBQ0EsT0FBTzFLO0FBQ1Q7QUFFQTs7OztDQUlDLEdBQ0QsTUFBTWtLLHNCQUFzQixDQUFDUixpQkFBaUJpQjtJQUM1QyxnQ0FBZ0MsR0FDaEMsTUFBTTNLLFNBQVMsQ0FBQztJQUNoQixJQUFLLE1BQU1uWixLQUFLOGpCLFdBQVk7UUFDMUIsTUFBTXJILFlBQVlxSCxVQUFVLENBQUM5akIsRUFBRTtRQUMvQiwrQkFBK0IsR0FDL0IsTUFBTStqQixNQUFNbEIsZ0JBQWdCMW5CLGFBQWEsQ0FBQ3NoQjtRQUMxQyxJQUFJc0gsS0FBSztZQUNQUiwwQkFBMEJRLEtBQUssRUFBRTtZQUNqQzVLLE1BQU0sQ0FBQ3NELFVBQVU1WCxPQUFPLENBQUMsVUFBVSxJQUFJLEdBQUdrZixJQUFJdGhCLFNBQVMsQ0FBQzBMLElBQUk7UUFDOUQ7SUFDRjtJQUNBLE9BQU9nTDtBQUNUO0FBRUE7O0NBRUMsR0FDRCxNQUFNMkosMEJBQTBCRCxDQUFBQTtJQUM5QixNQUFNbUIsa0JBQWtCckIsaUJBQWlCdGtCLE1BQU0sQ0FBQztRQUFDO1FBQWM7UUFBdUI7UUFBZTtRQUFjO1FBQWE7UUFBYztLQUFvQjtJQUNsS2IsTUFBTUMsSUFBSSxDQUFDb2xCLGdCQUFnQmhoQixRQUFRLEVBQUVyQyxPQUFPLENBQUNyQixDQUFBQTtRQUMzQyxNQUFNb1csVUFBVXBXLEdBQUdvVyxPQUFPLENBQUMwUCxXQUFXO1FBQ3RDLElBQUksQ0FBQ0QsZ0JBQWdCMXBCLFFBQVEsQ0FBQ2lhLFVBQVU7WUFDdEN4YSxLQUFLLENBQUMsc0JBQXNCLEVBQUV3YSxRQUFRLENBQUMsQ0FBQztRQUMxQztJQUNGO0FBQ0Y7QUFFQTs7O0NBR0MsR0FDRCxNQUFNZ1AsNEJBQTRCLENBQUNwbEIsSUFBSStsQjtJQUNyQzFtQixNQUFNQyxJQUFJLENBQUNVLEdBQUcrTCxVQUFVLEVBQUUxSyxPQUFPLENBQUMya0IsQ0FBQUE7UUFDaEMsSUFBSUQsa0JBQWtCaFgsT0FBTyxDQUFDaVgsVUFBVS9aLElBQUksTUFBTSxDQUFDLEdBQUc7WUFDcERyUSxLQUFLO2dCQUFDLENBQUMsd0JBQXdCLEVBQUVvcUIsVUFBVS9aLElBQUksQ0FBQyxNQUFNLEVBQUVqTSxHQUFHb1csT0FBTyxDQUFDMFAsV0FBVyxHQUFHLEVBQUUsQ0FBQztnQkFBRSxDQUFDLEVBQUVDLGtCQUFrQmp0QixNQUFNLEdBQUcsQ0FBQyx3QkFBd0IsRUFBRWl0QixrQkFBa0JocUIsSUFBSSxDQUFDLE1BQU0sQ0FBQyxHQUFHLGlEQUFpRCxDQUFDO2FBQUM7UUFDck87SUFDRjtBQUNGO0FBRUEsTUFBTWtxQixxQkFBcUI7QUFFM0I7Ozs7Q0FJQyxHQUNELE1BQU1DLFlBQVlsa0IsQ0FBQUE7SUFDaEIsTUFBTS9FLFlBQVlGO0lBQ2xCLE1BQU1PLFFBQVFEO0lBQ2QsSUFBSSxPQUFPMkUsT0FBTzhiLFFBQVEsS0FBSyxZQUFZO1FBQ3pDOWIsT0FBTzhiLFFBQVEsQ0FBQ3hnQjtJQUNsQjtJQUNBNUQsWUFBWW9ZLFlBQVksQ0FBQ0MsSUFBSSxDQUFDLFlBQVl6VTtJQUMxQyxNQUFNNm9CLGFBQWE3ckIsT0FBTytLLGdCQUFnQixDQUFDdEwsU0FBU0MsSUFBSTtJQUN4RCxNQUFNZ2Qsc0JBQXNCbVAsV0FBV0MsU0FBUztJQUNoREMsV0FBV3BwQixXQUFXSyxPQUFPMEU7SUFFN0IsbUVBQW1FO0lBQ25FckgsV0FBVztRQUNUMnJCLHVCQUF1QnJwQixXQUFXSztJQUNwQyxHQUFHMm9CO0lBQ0gsSUFBSTdsQixXQUFXO1FBQ2JtbUIsbUJBQW1CdHBCLFdBQVcrRSxPQUFPaWMsZ0JBQWdCLEVBQUVqSDtRQUN2RDdCO0lBQ0Y7SUFDQSxJQUFJLENBQUM1VSxhQUFhLENBQUM3RyxZQUFZRSxxQkFBcUIsRUFBRTtRQUNwREYsWUFBWUUscUJBQXFCLEdBQUdHLFNBQVM0YSxhQUFhO0lBQzVEO0lBQ0EsSUFBSSxPQUFPM1MsT0FBTytiLE9BQU8sS0FBSyxZQUFZO1FBQ3hDcGpCLFdBQVcsSUFBTXFILE9BQU8rYixPQUFPLENBQUN6Z0I7SUFDbEM7SUFDQTVELFlBQVlvWSxZQUFZLENBQUNDLElBQUksQ0FBQyxXQUFXelU7SUFDekNrRyxZQUFZdkcsV0FBV2xDLFdBQVcsQ0FBQyxnQkFBZ0I7QUFDckQ7QUFFQTs7Q0FFQyxHQUNELE1BQU15ckIsNEJBQTRCN1MsQ0FBQUE7SUFDaEMsTUFBTXJXLFFBQVFEO0lBQ2QsSUFBSXNXLE1BQU14USxNQUFNLEtBQUs3RixTQUFTLENBQUMrSyxtQkFBbUI7UUFDaEQ7SUFDRjtJQUNBLE1BQU1wTCxZQUFZRjtJQUNsQk8sTUFBTXdWLG1CQUFtQixDQUFDekssbUJBQW1CbWU7SUFDN0N2cEIsVUFBVTRHLEtBQUssQ0FBQ3VpQixTQUFTLEdBQUc7QUFDOUI7QUFFQTs7O0NBR0MsR0FDRCxNQUFNRSx5QkFBeUIsQ0FBQ3JwQixXQUFXSztJQUN6QyxJQUFJK0sscUJBQXFCakQsZ0JBQWdCOUgsUUFBUTtRQUMvQ0wsVUFBVTRHLEtBQUssQ0FBQ3VpQixTQUFTLEdBQUc7UUFDNUI5b0IsTUFBTThWLGdCQUFnQixDQUFDL0ssbUJBQW1CbWU7SUFDNUMsT0FBTztRQUNMdnBCLFVBQVU0RyxLQUFLLENBQUN1aUIsU0FBUyxHQUFHO0lBQzlCO0FBQ0Y7QUFFQTs7OztDQUlDLEdBQ0QsTUFBTUcscUJBQXFCLENBQUN0cEIsV0FBV2doQixrQkFBa0JqSDtJQUN2RHhCO0lBQ0EsSUFBSXlJLG9CQUFvQmpILHdCQUF3QixVQUFVO1FBQ3hERCw0QkFBNEJDO0lBQzlCO0lBRUEsMEJBQTBCO0lBQzFCcmMsV0FBVztRQUNUc0MsVUFBVTBZLFNBQVMsR0FBRztJQUN4QjtBQUNGO0FBRUE7Ozs7Q0FJQyxHQUNELE1BQU0wUSxhQUFhLENBQUNwcEIsV0FBV0ssT0FBTzBFO0lBQ3BDTyxTQUFTdEYsV0FBVytFLE9BQU9HLFNBQVMsQ0FBQ29JLFFBQVE7SUFDN0MsSUFBSXZJLE9BQU93RyxTQUFTLEVBQUU7UUFDcEIsb0dBQW9HO1FBQ3BHbEwsTUFBTXVHLEtBQUssQ0FBQ0MsV0FBVyxDQUFDLFdBQVcsS0FBSztRQUN4Q0UsS0FBSzFHLE9BQU87UUFDWjNDLFdBQVc7WUFDVCx1Q0FBdUM7WUFDdkM0SCxTQUFTakYsT0FBTzBFLE9BQU9HLFNBQVMsQ0FBQzdFLEtBQUs7WUFDdEMsb0NBQW9DO1lBQ3BDQSxNQUFNdUcsS0FBSyxDQUFDRSxjQUFjLENBQUM7UUFDN0IsR0FBR2tpQixxQkFBcUIsNkJBQTZCO0lBQ3ZELE9BQU87UUFDTGppQixLQUFLMUcsT0FBTztJQUNkO0lBQ0FpRixTQUFTO1FBQUN4SSxTQUFTOE0sZUFBZTtRQUFFOU0sU0FBU0MsSUFBSTtLQUFDLEVBQUVlLFlBQVl1RixLQUFLO0lBQ3JFLElBQUkwQixPQUFPbWIsVUFBVSxJQUFJbmIsT0FBT3VJLFFBQVEsSUFBSSxDQUFDdkksT0FBT3hCLEtBQUssRUFBRTtRQUN6RCtCLFNBQVM7WUFBQ3hJLFNBQVM4TSxlQUFlO1lBQUU5TSxTQUFTQyxJQUFJO1NBQUMsRUFBRWUsV0FBVyxDQUFDLGNBQWM7SUFDaEY7QUFDRjtBQUVBLElBQUkwckIseUJBQXlCO0lBQzNCOzs7O0dBSUMsR0FDRHZaLE9BQU8sQ0FBQ3daLFFBQVE1SztRQUNkLE9BQU8sb0RBQW9ENkssSUFBSSxDQUFDRCxVQUFVdnNCLFFBQVFDLE9BQU8sS0FBS0QsUUFBUUMsT0FBTyxDQUFDMGhCLHFCQUFxQjtJQUNySTtJQUNBOzs7O0dBSUMsR0FDRHhPLEtBQUssQ0FBQ29aLFFBQVE1SztRQUNaLDBGQUEwRjtRQUMxRixPQUFPLDhGQUE4RjZLLElBQUksQ0FBQ0QsVUFBVXZzQixRQUFRQyxPQUFPLEtBQUtELFFBQVFDLE9BQU8sQ0FBQzBoQixxQkFBcUI7SUFDL0s7QUFDRjtBQUVBOztDQUVDLEdBQ0QsU0FBUzhLLDBCQUEwQjVrQixNQUFNO0lBQ3ZDLHlFQUF5RTtJQUN6RSxJQUFJQSxPQUFPeVosY0FBYyxFQUFFO1FBQ3pCO0lBQ0Y7SUFDQSxJQUFJelosT0FBT2EsS0FBSyxLQUFLLFNBQVM7UUFDNUJiLE9BQU95WixjQUFjLEdBQUdnTCxzQkFBc0IsQ0FBQyxRQUFRO0lBQ3pEO0lBQ0EsSUFBSXprQixPQUFPYSxLQUFLLEtBQUssT0FBTztRQUMxQmIsT0FBT3laLGNBQWMsR0FBR2dMLHNCQUFzQixDQUFDLE1BQU07SUFDdkQ7QUFDRjtBQUVBOztDQUVDLEdBQ0QsU0FBU0ksNEJBQTRCN2tCLE1BQU07SUFDekMsa0RBQWtEO0lBQ2xELElBQUksQ0FBQ0EsT0FBT21CLE1BQU0sSUFBSSxPQUFPbkIsT0FBT21CLE1BQU0sS0FBSyxZQUFZLENBQUNwSixTQUFTaUQsYUFBYSxDQUFDZ0YsT0FBT21CLE1BQU0sS0FBSyxPQUFPbkIsT0FBT21CLE1BQU0sS0FBSyxZQUFZLENBQUNuQixPQUFPbUIsTUFBTSxDQUFDNUIsV0FBVyxFQUFFO1FBQ3BLM0YsS0FBSztRQUNMb0csT0FBT21CLE1BQU0sR0FBRztJQUNsQjtBQUNGO0FBRUE7Ozs7Q0FJQyxHQUNELFNBQVMyakIsY0FBYzlrQixNQUFNO0lBQzNCNGtCLDBCQUEwQjVrQjtJQUUxQixvQ0FBb0M7SUFDcEMsSUFBSUEsT0FBT3dhLG1CQUFtQixJQUFJLENBQUN4YSxPQUFPeWEsVUFBVSxFQUFFO1FBQ3BEN2dCLEtBQUsseUVBQXlFLHNGQUFzRjtJQUN0SztJQUNBaXJCLDRCQUE0QjdrQjtJQUU1QixzQ0FBc0M7SUFDdEMsSUFBSSxPQUFPQSxPQUFPdEUsS0FBSyxLQUFLLFVBQVU7UUFDcENzRSxPQUFPdEUsS0FBSyxHQUFHc0UsT0FBT3RFLEtBQUssQ0FBQ2tFLEtBQUssQ0FBQyxNQUFNN0YsSUFBSSxDQUFDO0lBQy9DO0lBQ0E2TCxLQUFLNUY7QUFDUDtBQUVBLHVCQUF1QixHQUN2QixJQUFJK0U7QUFDSixJQUFJZ2dCLFdBQVcsV0FBVyxHQUFFLElBQUkvYjtBQUNoQyxNQUFNZ2M7SUFDSjs7O0dBR0MsR0FDRGxFLGFBQWM7UUFDWjs7S0FFQyxHQUNEenBCLDJCQUEyQixJQUFJLEVBQUUwdEIsVUFBVSxLQUFLO1FBQ2hELDBCQUEwQjtRQUMxQixJQUFJLElBQWtCLEVBQWE7WUFDakM7UUFDRjtRQUNBaGdCLGtCQUFrQixJQUFJO1FBRXRCLGFBQWE7UUFDYixJQUFLLElBQUlvYSxPQUFPdG9CLFVBQVVDLE1BQU0sRUFBRW1vQixPQUFPLElBQUk1aEIsTUFBTThoQixPQUFPQyxPQUFPLEdBQUdBLE9BQU9ELE1BQU1DLE9BQVE7WUFDdkZILElBQUksQ0FBQ0csS0FBSyxHQUFHdm9CLFNBQVMsQ0FBQ3VvQixLQUFLO1FBQzlCO1FBQ0EsTUFBTTZGLGNBQWNobEIsT0FBT3dRLE1BQU0sQ0FBQyxJQUFJLENBQUNxUSxXQUFXLENBQUM5QixZQUFZLENBQUNDO1FBRWhFLHdDQUF3QyxHQUN4QyxJQUFJLENBQUNqZixNQUFNLEdBQUdpbEI7UUFFZCxvQkFBb0IsR0FDcEIsSUFBSSxDQUFDclAsaUJBQWlCLEdBQUc7UUFDekJyZSx1QkFBdUJ3dEIsVUFBVSxJQUFJLEVBQUUsSUFBSSxDQUFDdkYsS0FBSyxDQUFDemEsZ0JBQWdCL0UsTUFBTTtJQUMxRTtJQUNBd2YsTUFBTTBGLFVBQVUsRUFBRTtRQUNoQixJQUFJNUYsY0FBY3pvQixVQUFVQyxNQUFNLEdBQUcsS0FBS0QsU0FBUyxDQUFDLEVBQUUsS0FBSzJELFlBQVkzRCxTQUFTLENBQUMsRUFBRSxHQUFHLENBQUM7UUFDdkZtbUIsc0JBQXNCL2MsT0FBT29XLE1BQU0sQ0FBQyxDQUFDLEdBQUdpSixhQUFhNEY7UUFDckQsSUFBSXh0QixZQUFZcU4sZUFBZSxFQUFFO1lBQy9CLE1BQU1rTyxxQkFBcUJELGVBQWVDLGtCQUFrQixDQUFDN2IsR0FBRyxDQUFDTSxZQUFZcU4sZUFBZTtZQUM1RixNQUFNLEVBQ0o2USxpQkFBaUIsRUFDbEIsR0FBR2xlLFlBQVlxTixlQUFlO1lBQy9Cck4sWUFBWXFOLGVBQWUsQ0FBQ21SLFFBQVE7WUFDcEMsSUFBSSxDQUFDTixtQkFBbUI7Z0JBQ3RCM0MsbUJBQW1CO29CQUNqQjRDLGFBQWE7Z0JBQ2Y7WUFDRjtZQUNBLElBQUl6WCxXQUFXO2dCQUNiaVY7WUFDRjtRQUNGO1FBQ0EzYixZQUFZcU4sZUFBZSxHQUFHQTtRQUM5QixNQUFNZ0UsY0FBY29jLGNBQWNELFlBQVk1RjtRQUM5Q3dGLGNBQWMvYjtRQUNkOUksT0FBT3dRLE1BQU0sQ0FBQzFIO1FBRWQsMkJBQTJCO1FBQzNCLElBQUlyUixZQUFZaW9CLE9BQU8sRUFBRTtZQUN2QmpvQixZQUFZaW9CLE9BQU8sQ0FBQ0UsSUFBSTtZQUN4QixPQUFPbm9CLFlBQVlpb0IsT0FBTztRQUM1QjtRQUVBLGtDQUFrQztRQUNsQzJDLGFBQWE1cUIsWUFBWWdCLG1CQUFtQjtRQUM1QyxNQUFNdVEsV0FBV21jLGlCQUFpQnJnQjtRQUNsQzZLLE9BQU83SyxpQkFBaUJnRTtRQUN4QkQsYUFBYUMsV0FBVyxDQUFDelIsR0FBRyxDQUFDeU4saUJBQWlCZ0U7UUFDOUMsT0FBT3NjLFlBQVl0Z0IsaUJBQWlCa0UsVUFBVUY7SUFDaEQ7SUFFQSxnR0FBZ0c7SUFDaEd3TSxLQUFLK1AsV0FBVyxFQUFFO1FBQ2hCLE9BQU9ydUIsdUJBQXVCOHRCLFVBQVUsSUFBSSxFQUFFeFAsSUFBSSxDQUFDK1A7SUFDckQ7SUFDQUMsUUFBUUMsU0FBUyxFQUFFO1FBQ2pCLE9BQU92dUIsdUJBQXVCOHRCLFVBQVUsSUFBSSxFQUFFUSxPQUFPLENBQUNDO0lBQ3hEO0FBQ0Y7QUFFQTs7Ozs7Q0FLQyxHQUNELE1BQU1ILGNBQWMsQ0FBQzNlLFVBQVV1QyxVQUFVRjtJQUN2QyxPQUFPLElBQUk1USxRQUFRLENBQUNDLFNBQVNxdEI7UUFDM0IsOENBQThDO1FBQzlDOztLQUVDLEdBQ0QsTUFBTXRVLGNBQWN1VSxDQUFBQTtZQUNsQmhmLFNBQVMzSixLQUFLLENBQUM7Z0JBQ2I4WSxhQUFhO2dCQUNiNlA7WUFDRjtRQUNGO1FBQ0ExUyxlQUFlQyxrQkFBa0IsQ0FBQzNiLEdBQUcsQ0FBQ29QLFVBQVV0TztRQUNoRDRhLGVBQWVFLGlCQUFpQixDQUFDNWIsR0FBRyxDQUFDb1AsVUFBVStlO1FBQy9DeGMsU0FBU2pDLGFBQWEsQ0FBQ3dYLE9BQU8sR0FBRztZQUMvQnJGLHlCQUF5QnpTO1FBQzNCO1FBQ0F1QyxTQUFTaEMsVUFBVSxDQUFDdVgsT0FBTyxHQUFHO1lBQzVCbEYsc0JBQXNCNVM7UUFDeEI7UUFDQXVDLFNBQVMvQixZQUFZLENBQUNzWCxPQUFPLEdBQUc7WUFDOUJoRix3QkFBd0I5UyxVQUFVeUs7UUFDcEM7UUFDQWxJLFNBQVNoQixXQUFXLENBQUN1VyxPQUFPLEdBQUc7WUFDN0JyTixZQUFZWCxjQUFjelQsS0FBSztRQUNqQztRQUNBb2hCLGlCQUFpQnBWLGFBQWFFLFVBQVVrSTtRQUN4Q0Qsa0JBQWtCeFosYUFBYXFSLGFBQWFvSTtRQUM1QzZGLDJCQUEyQnRRLFVBQVVxQztRQUNyQ21iLFVBQVVuYjtRQUNWNGMsV0FBV2p1QixhQUFhcVIsYUFBYW9JO1FBQ3JDeVUsVUFBVTNjLFVBQVVGO1FBRXBCLGlEQUFpRDtRQUNqRHBRLFdBQVc7WUFDVHNRLFNBQVNoTyxTQUFTLENBQUMwWSxTQUFTLEdBQUc7UUFDakM7SUFDRjtBQUNGO0FBRUE7Ozs7Q0FJQyxHQUNELE1BQU13UixnQkFBZ0IsQ0FBQ0QsWUFBWTVGO0lBQ2pDLE1BQU11RyxpQkFBaUJwRCxrQkFBa0J5QztJQUN6QyxNQUFNbGxCLFNBQVNDLE9BQU9vVyxNQUFNLENBQUMsQ0FBQyxHQUFHNEUsZUFBZXFFLGFBQWF1RyxnQkFBZ0JYLGFBQWEsbUNBQW1DO0lBQzdIbGxCLE9BQU9HLFNBQVMsR0FBR0YsT0FBT29XLE1BQU0sQ0FBQyxDQUFDLEdBQUc0RSxjQUFjOWEsU0FBUyxFQUFFSCxPQUFPRyxTQUFTO0lBQzlFSCxPQUFPK1YsU0FBUyxHQUFHOVYsT0FBT29XLE1BQU0sQ0FBQyxDQUFDLEdBQUc0RSxjQUFjbEYsU0FBUyxFQUFFL1YsT0FBTytWLFNBQVM7SUFDOUUsSUFBSS9WLE9BQU93RyxTQUFTLEtBQUssT0FBTztRQUM5QnhHLE9BQU9HLFNBQVMsR0FBRztZQUNqQm9JLFVBQVU7UUFDWjtRQUNBdkksT0FBTytWLFNBQVMsR0FBRyxDQUFDO0lBQ3RCO0lBQ0EsT0FBTy9WO0FBQ1Q7QUFFQTs7O0NBR0MsR0FDRCxNQUFNb2xCLG1CQUFtQjFlLENBQUFBO0lBQ3ZCLE1BQU11QyxXQUFXO1FBQ2YzTixPQUFPRDtRQUNQSixXQUFXRjtRQUNYa0IsU0FBU1M7UUFDVHNLLGVBQWVoTDtRQUNmaUwsWUFBWTVLO1FBQ1o2SyxjQUFjL0s7UUFDZE0sUUFBUUQ7UUFDUnlMLGFBQWFuTDtRQUNiZ2QsbUJBQW1CL2Q7UUFDbkJrVCxlQUFlblQ7SUFDakI7SUFDQWdOLGFBQWFHLFFBQVEsQ0FBQzNSLEdBQUcsQ0FBQ29QLFVBQVV1QztJQUNwQyxPQUFPQTtBQUNUO0FBRUE7Ozs7Q0FJQyxHQUNELE1BQU0wYyxhQUFhLENBQUNqdUIsYUFBYXFSLGFBQWFvSTtJQUM1QyxNQUFNdE4sbUJBQW1CaEg7SUFDekJxRixLQUFLMkI7SUFDTCxJQUFJa0YsWUFBWXBGLEtBQUssRUFBRTtRQUNyQmpNLFlBQVlpb0IsT0FBTyxHQUFHLElBQUlzQyxNQUFNO1lBQzlCOVEsWUFBWTtZQUNaLE9BQU96WixZQUFZaW9CLE9BQU87UUFDNUIsR0FBRzVXLFlBQVlwRixLQUFLO1FBQ3BCLElBQUlvRixZQUFZbEYsZ0JBQWdCLEVBQUU7WUFDaEM3QixLQUFLNkI7WUFDTHhELGlCQUFpQndELGtCQUFrQmtGLGFBQWE7WUFDaERwUSxXQUFXO2dCQUNULElBQUlqQixZQUFZaW9CLE9BQU8sSUFBSWpvQixZQUFZaW9CLE9BQU8sQ0FBQ08sT0FBTyxFQUFFO29CQUN0RCxzREFBc0Q7b0JBQ3REeGMsd0JBQXdCcUYsWUFBWXBGLEtBQUs7Z0JBQzNDO1lBQ0Y7UUFDRjtJQUNGO0FBQ0Y7QUFFQTs7Ozs7Ozs7Ozs7O0NBWUMsR0FDRCxNQUFNaWlCLFlBQVksQ0FBQzNjLFVBQVVGO0lBQzNCLElBQUlBLFlBQVl2SyxLQUFLLEVBQUU7UUFDckI7SUFDRjtJQUNBLDZFQUE2RTtJQUM3RSxJQUFJLENBQUMvRCxlQUFlc08sWUFBWXNKLGFBQWEsR0FBRztRQUM5Q2hZLHFCQUFxQjtRQUNyQnlyQjtRQUNBO0lBQ0Y7SUFDQSxJQUFJQyxlQUFlOWMsV0FBVztRQUM1QjtJQUNGO0lBQ0EsSUFBSStjLFlBQVkvYyxVQUFVRixjQUFjO1FBQ3RDO0lBQ0Y7SUFDQXNJLFNBQVMsQ0FBQyxHQUFHO0FBQ2Y7QUFFQTs7O0NBR0MsR0FDRCxNQUFNMFUsaUJBQWlCOWMsQ0FBQUE7SUFDckIsTUFBTWdkLG9CQUFvQmhkLFNBQVMzTixLQUFLLENBQUM2QixnQkFBZ0IsQ0FBQztJQUMxRCxLQUFLLE1BQU0rb0Isb0JBQW9CRCxrQkFBbUI7UUFDaEQsSUFBSUMsNEJBQTRCcnVCLGVBQWVzRyxZQUFZK25CLG1CQUFtQjtZQUM1RUEsaUJBQWlCcHVCLEtBQUs7WUFDdEIsT0FBTztRQUNUO0lBQ0Y7SUFDQSxPQUFPO0FBQ1Q7QUFFQTs7OztDQUlDLEdBQ0QsTUFBTWt1QixjQUFjLENBQUMvYyxVQUFVRjtJQUM3QixJQUFJQSxZQUFZNlMsU0FBUyxJQUFJemQsWUFBWThLLFNBQVNoQyxVQUFVLEdBQUc7UUFDN0RnQyxTQUFTaEMsVUFBVSxDQUFDblAsS0FBSztRQUN6QixPQUFPO0lBQ1Q7SUFDQSxJQUFJaVIsWUFBWThTLFdBQVcsSUFBSTFkLFlBQVk4SyxTQUFTL0IsWUFBWSxHQUFHO1FBQ2pFK0IsU0FBUy9CLFlBQVksQ0FBQ3BQLEtBQUs7UUFDM0IsT0FBTztJQUNUO0lBQ0EsSUFBSWlSLFlBQVk0UyxZQUFZLElBQUl4ZCxZQUFZOEssU0FBU2pDLGFBQWEsR0FBRztRQUNuRWlDLFNBQVNqQyxhQUFhLENBQUNsUCxLQUFLO1FBQzVCLE9BQU87SUFDVDtJQUNBLE9BQU87QUFDVDtBQUNBLE1BQU1ndUIsb0JBQW9CO0lBQ3hCLElBQUkvdEIsU0FBUzRhLGFBQWEsWUFBWTlhLGVBQWUsT0FBT0UsU0FBUzRhLGFBQWEsQ0FBQ3dULElBQUksS0FBSyxZQUFZO1FBQ3RHcHVCLFNBQVM0YSxhQUFhLENBQUN3VCxJQUFJO0lBQzdCO0FBQ0Y7QUFFQSw2REFBNkQ7QUFDN0QsSUFBSSxLQUFrSCxFQUFFLEVBbUJ2SDtBQUVELHFFQUFxRTtBQUNyRW5CLFdBQVd6SSxTQUFTLENBQUNuRCxjQUFjLEdBQUdBO0FBQ3RDNEwsV0FBV3pJLFNBQVMsQ0FBQzNDLGFBQWEsR0FBR0E7QUFDckNvTCxXQUFXekksU0FBUyxDQUFDbEYsUUFBUSxHQUFHQTtBQUNoQzJOLFdBQVd6SSxTQUFTLENBQUN4QyxZQUFZLEdBQUdBO0FBQ3BDaUwsV0FBV3pJLFNBQVMsQ0FBQ3RDLFdBQVcsR0FBR0E7QUFDbkMrSyxXQUFXekksU0FBUyxDQUFDdkUsV0FBVyxHQUFHQTtBQUNuQ2dOLFdBQVd6SSxTQUFTLENBQUNvQixjQUFjLEdBQUczRjtBQUN0Q2dOLFdBQVd6SSxTQUFTLENBQUMxQyxxQkFBcUIsR0FBR0E7QUFDN0NtTCxXQUFXekksU0FBUyxDQUFDdlgsc0JBQXNCLEdBQUdBO0FBQzlDZ2dCLFdBQVd6SSxTQUFTLENBQUN4ZixLQUFLLEdBQUdBO0FBQzdCaW9CLFdBQVd6SSxTQUFTLENBQUNxQixVQUFVLEdBQUc3Z0I7QUFDbENpb0IsV0FBV3pJLFNBQVMsQ0FBQ3NCLFVBQVUsR0FBRzlnQjtBQUNsQ2lvQixXQUFXekksU0FBUyxDQUFDdUIsVUFBVSxHQUFHL2dCO0FBQ2xDaW9CLFdBQVd6SSxTQUFTLENBQUN0RyxhQUFhLEdBQUdBO0FBQ3JDK08sV0FBV3pJLFNBQVMsQ0FBQ1UsTUFBTSxHQUFHQTtBQUM5QitILFdBQVd6SSxTQUFTLENBQUNyRyxRQUFRLEdBQUdBO0FBRWhDLG1FQUFtRTtBQUNuRWpXLE9BQU9vVyxNQUFNLENBQUMyTyxZQUFZakQ7QUFFMUIsaUZBQWlGO0FBQ2pGOWhCLE9BQU8wSixJQUFJLENBQUNzVSxpQkFBaUI1ZSxPQUFPLENBQUMyUyxDQUFBQTtJQUNuQzs7O0dBR0MsR0FDRGdULFVBQVUsQ0FBQ2hULElBQUksR0FBRztRQUNoQixJQUFJak4sbUJBQW1CQSxlQUFlLENBQUNpTixJQUFJLEVBQUU7WUFDM0MsT0FBT2pOLGVBQWUsQ0FBQ2lOLElBQUksSUFBSW5iO1FBQ2pDO1FBQ0EsT0FBTztJQUNUO0FBQ0Y7QUFDQW11QixXQUFXeFUsYUFBYSxHQUFHQTtBQUMzQndVLFdBQVdtQyxPQUFPLEdBQUc7QUFFckIsTUFBTXRRLE9BQU9tTztBQUNiLGFBQWE7QUFDYm5PLEtBQUt1USxPQUFPLEdBQUd2UTtBQUVZO0FBQzNCLGVBQWEsT0FBTzllLFlBQVUsU0FBU3RCLENBQUMsRUFBQ0MsQ0FBQztJQUFFLElBQUlDLElBQUVGLEVBQUVxUCxhQUFhLENBQUM7SUFBUyxJQUFHclAsRUFBRTR3QixvQkFBb0IsQ0FBQyxPQUFPLENBQUMsRUFBRSxDQUFDOW5CLFdBQVcsQ0FBQzVJLElBQUdBLEVBQUUyd0IsVUFBVSxFQUFDM3dCLEVBQUUyd0IsVUFBVSxDQUFDemIsUUFBUSxJQUFHbFYsQ0FBQUEsRUFBRTJ3QixVQUFVLENBQUNDLE9BQU8sR0FBQzd3QixDQUFBQTtTQUFRLElBQUc7UUFBQ0MsRUFBRTJMLFNBQVMsR0FBQzVMO0lBQUMsRUFBQyxPQUFNRCxHQUFFO1FBQUNFLEVBQUVpVSxTQUFTLEdBQUNsVTtJQUFDO0FBQUMsRUFBRXFCLFVBQVMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zYWZyYS1hcHAvLi9ub2RlX21vZHVsZXMvc3dlZXRhbGVydDIvZGlzdC9zd2VldGFsZXJ0Mi5lc20uYWxsLmpzPzYxMTgiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4qIHN3ZWV0YWxlcnQyIHYxMS4xNC4wXG4qIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiovXG5mdW5jdGlvbiBfYXNzZXJ0Q2xhc3NCcmFuZChlLCB0LCBuKSB7XG4gIGlmIChcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIGUgPyBlID09PSB0IDogZS5oYXModCkpIHJldHVybiBhcmd1bWVudHMubGVuZ3RoIDwgMyA/IHQgOiBuO1xuICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBlbGVtZW50IGlzIG5vdCBwcmVzZW50IG9uIHRoaXMgb2JqZWN0XCIpO1xufVxuZnVuY3Rpb24gX2NoZWNrUHJpdmF0ZVJlZGVjbGFyYXRpb24oZSwgdCkge1xuICBpZiAodC5oYXMoZSkpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgaW5pdGlhbGl6ZSB0aGUgc2FtZSBwcml2YXRlIGVsZW1lbnRzIHR3aWNlIG9uIGFuIG9iamVjdFwiKTtcbn1cbmZ1bmN0aW9uIF9jbGFzc1ByaXZhdGVGaWVsZEdldDIocywgYSkge1xuICByZXR1cm4gcy5nZXQoX2Fzc2VydENsYXNzQnJhbmQocywgYSkpO1xufVxuZnVuY3Rpb24gX2NsYXNzUHJpdmF0ZUZpZWxkSW5pdFNwZWMoZSwgdCwgYSkge1xuICBfY2hlY2tQcml2YXRlUmVkZWNsYXJhdGlvbihlLCB0KSwgdC5zZXQoZSwgYSk7XG59XG5mdW5jdGlvbiBfY2xhc3NQcml2YXRlRmllbGRTZXQyKHMsIGEsIHIpIHtcbiAgcmV0dXJuIHMuc2V0KF9hc3NlcnRDbGFzc0JyYW5kKHMsIGEpLCByKSwgcjtcbn1cblxuY29uc3QgUkVTVE9SRV9GT0NVU19USU1FT1VUID0gMTAwO1xuXG4vKiogQHR5cGUge0dsb2JhbFN0YXRlfSAqL1xuY29uc3QgZ2xvYmFsU3RhdGUgPSB7fTtcbmNvbnN0IGZvY3VzUHJldmlvdXNBY3RpdmVFbGVtZW50ID0gKCkgPT4ge1xuICBpZiAoZ2xvYmFsU3RhdGUucHJldmlvdXNBY3RpdmVFbGVtZW50IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpIHtcbiAgICBnbG9iYWxTdGF0ZS5wcmV2aW91c0FjdGl2ZUVsZW1lbnQuZm9jdXMoKTtcbiAgICBnbG9iYWxTdGF0ZS5wcmV2aW91c0FjdGl2ZUVsZW1lbnQgPSBudWxsO1xuICB9IGVsc2UgaWYgKGRvY3VtZW50LmJvZHkpIHtcbiAgICBkb2N1bWVudC5ib2R5LmZvY3VzKCk7XG4gIH1cbn07XG5cbi8qKlxuICogUmVzdG9yZSBwcmV2aW91cyBhY3RpdmUgKGZvY3VzZWQpIGVsZW1lbnRcbiAqXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHJldHVybkZvY3VzXG4gKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cbiAqL1xuY29uc3QgcmVzdG9yZUFjdGl2ZUVsZW1lbnQgPSByZXR1cm5Gb2N1cyA9PiB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICBpZiAoIXJldHVybkZvY3VzKSB7XG4gICAgICByZXR1cm4gcmVzb2x2ZSgpO1xuICAgIH1cbiAgICBjb25zdCB4ID0gd2luZG93LnNjcm9sbFg7XG4gICAgY29uc3QgeSA9IHdpbmRvdy5zY3JvbGxZO1xuICAgIGdsb2JhbFN0YXRlLnJlc3RvcmVGb2N1c1RpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGZvY3VzUHJldmlvdXNBY3RpdmVFbGVtZW50KCk7XG4gICAgICByZXNvbHZlKCk7XG4gICAgfSwgUkVTVE9SRV9GT0NVU19USU1FT1VUKTsgLy8gaXNzdWVzLzkwMFxuXG4gICAgd2luZG93LnNjcm9sbFRvKHgsIHkpO1xuICB9KTtcbn07XG5cbmNvbnN0IHN3YWxQcmVmaXggPSAnc3dhbDItJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7UmVjb3JkPFN3YWxDbGFzcywgc3RyaW5nPn0gU3dhbENsYXNzZXNcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHsnc3VjY2VzcycgfCAnd2FybmluZycgfCAnaW5mbycgfCAncXVlc3Rpb24nIHwgJ2Vycm9yJ30gU3dhbEljb25cbiAqIEB0eXBlZGVmIHtSZWNvcmQ8U3dhbEljb24sIHN0cmluZz59IFN3YWxJY29uc1xuICovXG5cbi8qKiBAdHlwZSB7U3dhbENsYXNzW119ICovXG5jb25zdCBjbGFzc05hbWVzID0gWydjb250YWluZXInLCAnc2hvd24nLCAnaGVpZ2h0LWF1dG8nLCAnaW9zZml4JywgJ3BvcHVwJywgJ21vZGFsJywgJ25vLWJhY2tkcm9wJywgJ25vLXRyYW5zaXRpb24nLCAndG9hc3QnLCAndG9hc3Qtc2hvd24nLCAnc2hvdycsICdoaWRlJywgJ2Nsb3NlJywgJ3RpdGxlJywgJ2h0bWwtY29udGFpbmVyJywgJ2FjdGlvbnMnLCAnY29uZmlybScsICdkZW55JywgJ2NhbmNlbCcsICdkZWZhdWx0LW91dGxpbmUnLCAnZm9vdGVyJywgJ2ljb24nLCAnaWNvbi1jb250ZW50JywgJ2ltYWdlJywgJ2lucHV0JywgJ2ZpbGUnLCAncmFuZ2UnLCAnc2VsZWN0JywgJ3JhZGlvJywgJ2NoZWNrYm94JywgJ2xhYmVsJywgJ3RleHRhcmVhJywgJ2lucHV0ZXJyb3InLCAnaW5wdXQtbGFiZWwnLCAndmFsaWRhdGlvbi1tZXNzYWdlJywgJ3Byb2dyZXNzLXN0ZXBzJywgJ2FjdGl2ZS1wcm9ncmVzcy1zdGVwJywgJ3Byb2dyZXNzLXN0ZXAnLCAncHJvZ3Jlc3Mtc3RlcC1saW5lJywgJ2xvYWRlcicsICdsb2FkaW5nJywgJ3N0eWxlZCcsICd0b3AnLCAndG9wLXN0YXJ0JywgJ3RvcC1lbmQnLCAndG9wLWxlZnQnLCAndG9wLXJpZ2h0JywgJ2NlbnRlcicsICdjZW50ZXItc3RhcnQnLCAnY2VudGVyLWVuZCcsICdjZW50ZXItbGVmdCcsICdjZW50ZXItcmlnaHQnLCAnYm90dG9tJywgJ2JvdHRvbS1zdGFydCcsICdib3R0b20tZW5kJywgJ2JvdHRvbS1sZWZ0JywgJ2JvdHRvbS1yaWdodCcsICdncm93LXJvdycsICdncm93LWNvbHVtbicsICdncm93LWZ1bGxzY3JlZW4nLCAncnRsJywgJ3RpbWVyLXByb2dyZXNzLWJhcicsICd0aW1lci1wcm9ncmVzcy1iYXItY29udGFpbmVyJywgJ3Njcm9sbGJhci1tZWFzdXJlJywgJ2ljb24tc3VjY2VzcycsICdpY29uLXdhcm5pbmcnLCAnaWNvbi1pbmZvJywgJ2ljb24tcXVlc3Rpb24nLCAnaWNvbi1lcnJvciddO1xuY29uc3Qgc3dhbENsYXNzZXMgPSBjbGFzc05hbWVzLnJlZHVjZSgoYWNjLCBjbGFzc05hbWUpID0+IHtcbiAgYWNjW2NsYXNzTmFtZV0gPSBzd2FsUHJlZml4ICsgY2xhc3NOYW1lO1xuICByZXR1cm4gYWNjO1xufSwgLyoqIEB0eXBlIHtTd2FsQ2xhc3Nlc30gKi97fSk7XG5cbi8qKiBAdHlwZSB7U3dhbEljb25bXX0gKi9cbmNvbnN0IGljb25zID0gWydzdWNjZXNzJywgJ3dhcm5pbmcnLCAnaW5mbycsICdxdWVzdGlvbicsICdlcnJvciddO1xuY29uc3QgaWNvblR5cGVzID0gaWNvbnMucmVkdWNlKChhY2MsIGljb24pID0+IHtcbiAgYWNjW2ljb25dID0gc3dhbFByZWZpeCArIGljb247XG4gIHJldHVybiBhY2M7XG59LCAvKiogQHR5cGUge1N3YWxJY29uc30gKi97fSk7XG5cbmNvbnN0IGNvbnNvbGVQcmVmaXggPSAnU3dlZXRBbGVydDI6JztcblxuLyoqXG4gKiBDYXBpdGFsaXplIHRoZSBmaXJzdCBsZXR0ZXIgb2YgYSBzdHJpbmdcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5jb25zdCBjYXBpdGFsaXplRmlyc3RMZXR0ZXIgPSBzdHIgPT4gc3RyLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3RyLnNsaWNlKDEpO1xuXG4vKipcbiAqIFN0YW5kYXJkaXplIGNvbnNvbGUgd2FybmluZ3NcbiAqXG4gKiBAcGFyYW0ge3N0cmluZyB8IHN0cmluZ1tdfSBtZXNzYWdlXG4gKi9cbmNvbnN0IHdhcm4gPSBtZXNzYWdlID0+IHtcbiAgY29uc29sZS53YXJuKGAke2NvbnNvbGVQcmVmaXh9ICR7dHlwZW9mIG1lc3NhZ2UgPT09ICdvYmplY3QnID8gbWVzc2FnZS5qb2luKCcgJykgOiBtZXNzYWdlfWApO1xufTtcblxuLyoqXG4gKiBTdGFuZGFyZGl6ZSBjb25zb2xlIGVycm9yc1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlXG4gKi9cbmNvbnN0IGVycm9yID0gbWVzc2FnZSA9PiB7XG4gIGNvbnNvbGUuZXJyb3IoYCR7Y29uc29sZVByZWZpeH0gJHttZXNzYWdlfWApO1xufTtcblxuLyoqXG4gKiBQcml2YXRlIGdsb2JhbCBzdGF0ZSBmb3IgYHdhcm5PbmNlYFxuICpcbiAqIEB0eXBlIHtzdHJpbmdbXX1cbiAqIEBwcml2YXRlXG4gKi9cbmNvbnN0IHByZXZpb3VzV2Fybk9uY2VNZXNzYWdlcyA9IFtdO1xuXG4vKipcbiAqIFNob3cgYSBjb25zb2xlIHdhcm5pbmcsIGJ1dCBvbmx5IGlmIGl0IGhhc24ndCBhbHJlYWR5IGJlZW4gc2hvd25cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbWVzc2FnZVxuICovXG5jb25zdCB3YXJuT25jZSA9IG1lc3NhZ2UgPT4ge1xuICBpZiAoIXByZXZpb3VzV2Fybk9uY2VNZXNzYWdlcy5pbmNsdWRlcyhtZXNzYWdlKSkge1xuICAgIHByZXZpb3VzV2Fybk9uY2VNZXNzYWdlcy5wdXNoKG1lc3NhZ2UpO1xuICAgIHdhcm4obWVzc2FnZSk7XG4gIH1cbn07XG5cbi8qKlxuICogU2hvdyBhIG9uZS10aW1lIGNvbnNvbGUgd2FybmluZyBhYm91dCBkZXByZWNhdGVkIHBhcmFtcy9tZXRob2RzXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGRlcHJlY2F0ZWRQYXJhbVxuICogQHBhcmFtIHtzdHJpbmc/fSB1c2VJbnN0ZWFkXG4gKi9cbmNvbnN0IHdhcm5BYm91dERlcHJlY2F0aW9uID0gZnVuY3Rpb24gKGRlcHJlY2F0ZWRQYXJhbSkge1xuICBsZXQgdXNlSW5zdGVhZCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogbnVsbDtcbiAgd2Fybk9uY2UoYFwiJHtkZXByZWNhdGVkUGFyYW19XCIgaXMgZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHJlbGVhc2UuJHt1c2VJbnN0ZWFkID8gYCBVc2UgXCIke3VzZUluc3RlYWR9XCIgaW5zdGVhZC5gIDogJyd9YCk7XG59O1xuXG4vKipcbiAqIElmIGBhcmdgIGlzIGEgZnVuY3Rpb24sIGNhbGwgaXQgKHdpdGggbm8gYXJndW1lbnRzIG9yIGNvbnRleHQpIGFuZCByZXR1cm4gdGhlIHJlc3VsdC5cbiAqIE90aGVyd2lzZSwganVzdCBwYXNzIHRoZSB2YWx1ZSB0aHJvdWdoXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbiB8IGFueX0gYXJnXG4gKiBAcmV0dXJucyB7YW55fVxuICovXG5jb25zdCBjYWxsSWZGdW5jdGlvbiA9IGFyZyA9PiB0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nID8gYXJnKCkgOiBhcmc7XG5cbi8qKlxuICogQHBhcmFtIHthbnl9IGFyZ1xuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmNvbnN0IGhhc1RvUHJvbWlzZUZuID0gYXJnID0+IGFyZyAmJiB0eXBlb2YgYXJnLnRvUHJvbWlzZSA9PT0gJ2Z1bmN0aW9uJztcblxuLyoqXG4gKiBAcGFyYW0ge2FueX0gYXJnXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxhbnk+fVxuICovXG5jb25zdCBhc1Byb21pc2UgPSBhcmcgPT4gaGFzVG9Qcm9taXNlRm4oYXJnKSA/IGFyZy50b1Byb21pc2UoKSA6IFByb21pc2UucmVzb2x2ZShhcmcpO1xuXG4vKipcbiAqIEBwYXJhbSB7YW55fSBhcmdcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5jb25zdCBpc1Byb21pc2UgPSBhcmcgPT4gYXJnICYmIFByb21pc2UucmVzb2x2ZShhcmcpID09PSBhcmc7XG5cbi8qKlxuICogR2V0cyB0aGUgcG9wdXAgY29udGFpbmVyIHdoaWNoIGNvbnRhaW5zIHRoZSBiYWNrZHJvcCBhbmQgdGhlIHBvcHVwIGl0c2VsZi5cbiAqXG4gKiBAcmV0dXJucyB7SFRNTEVsZW1lbnQgfCBudWxsfVxuICovXG5jb25zdCBnZXRDb250YWluZXIgPSAoKSA9PiBkb2N1bWVudC5ib2R5LnF1ZXJ5U2VsZWN0b3IoYC4ke3N3YWxDbGFzc2VzLmNvbnRhaW5lcn1gKTtcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gc2VsZWN0b3JTdHJpbmdcbiAqIEByZXR1cm5zIHtIVE1MRWxlbWVudCB8IG51bGx9XG4gKi9cbmNvbnN0IGVsZW1lbnRCeVNlbGVjdG9yID0gc2VsZWN0b3JTdHJpbmcgPT4ge1xuICBjb25zdCBjb250YWluZXIgPSBnZXRDb250YWluZXIoKTtcbiAgcmV0dXJuIGNvbnRhaW5lciA/IGNvbnRhaW5lci5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yU3RyaW5nKSA6IG51bGw7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWVcbiAqIEByZXR1cm5zIHtIVE1MRWxlbWVudCB8IG51bGx9XG4gKi9cbmNvbnN0IGVsZW1lbnRCeUNsYXNzID0gY2xhc3NOYW1lID0+IHtcbiAgcmV0dXJuIGVsZW1lbnRCeVNlbGVjdG9yKGAuJHtjbGFzc05hbWV9YCk7XG59O1xuXG4vKipcbiAqIEByZXR1cm5zIHtIVE1MRWxlbWVudCB8IG51bGx9XG4gKi9cbmNvbnN0IGdldFBvcHVwID0gKCkgPT4gZWxlbWVudEJ5Q2xhc3Moc3dhbENsYXNzZXMucG9wdXApO1xuXG4vKipcbiAqIEByZXR1cm5zIHtIVE1MRWxlbWVudCB8IG51bGx9XG4gKi9cbmNvbnN0IGdldEljb24gPSAoKSA9PiBlbGVtZW50QnlDbGFzcyhzd2FsQ2xhc3Nlcy5pY29uKTtcblxuLyoqXG4gKiBAcmV0dXJucyB7SFRNTEVsZW1lbnQgfCBudWxsfVxuICovXG5jb25zdCBnZXRJY29uQ29udGVudCA9ICgpID0+IGVsZW1lbnRCeUNsYXNzKHN3YWxDbGFzc2VzWydpY29uLWNvbnRlbnQnXSk7XG5cbi8qKlxuICogQHJldHVybnMge0hUTUxFbGVtZW50IHwgbnVsbH1cbiAqL1xuY29uc3QgZ2V0VGl0bGUgPSAoKSA9PiBlbGVtZW50QnlDbGFzcyhzd2FsQ2xhc3Nlcy50aXRsZSk7XG5cbi8qKlxuICogQHJldHVybnMge0hUTUxFbGVtZW50IHwgbnVsbH1cbiAqL1xuY29uc3QgZ2V0SHRtbENvbnRhaW5lciA9ICgpID0+IGVsZW1lbnRCeUNsYXNzKHN3YWxDbGFzc2VzWydodG1sLWNvbnRhaW5lciddKTtcblxuLyoqXG4gKiBAcmV0dXJucyB7SFRNTEVsZW1lbnQgfCBudWxsfVxuICovXG5jb25zdCBnZXRJbWFnZSA9ICgpID0+IGVsZW1lbnRCeUNsYXNzKHN3YWxDbGFzc2VzLmltYWdlKTtcblxuLyoqXG4gKiBAcmV0dXJucyB7SFRNTEVsZW1lbnQgfCBudWxsfVxuICovXG5jb25zdCBnZXRQcm9ncmVzc1N0ZXBzID0gKCkgPT4gZWxlbWVudEJ5Q2xhc3Moc3dhbENsYXNzZXNbJ3Byb2dyZXNzLXN0ZXBzJ10pO1xuXG4vKipcbiAqIEByZXR1cm5zIHtIVE1MRWxlbWVudCB8IG51bGx9XG4gKi9cbmNvbnN0IGdldFZhbGlkYXRpb25NZXNzYWdlID0gKCkgPT4gZWxlbWVudEJ5Q2xhc3Moc3dhbENsYXNzZXNbJ3ZhbGlkYXRpb24tbWVzc2FnZSddKTtcblxuLyoqXG4gKiBAcmV0dXJucyB7SFRNTEJ1dHRvbkVsZW1lbnQgfCBudWxsfVxuICovXG5jb25zdCBnZXRDb25maXJtQnV0dG9uID0gKCkgPT4gKC8qKiBAdHlwZSB7SFRNTEJ1dHRvbkVsZW1lbnR9ICovZWxlbWVudEJ5U2VsZWN0b3IoYC4ke3N3YWxDbGFzc2VzLmFjdGlvbnN9IC4ke3N3YWxDbGFzc2VzLmNvbmZpcm19YCkpO1xuXG4vKipcbiAqIEByZXR1cm5zIHtIVE1MQnV0dG9uRWxlbWVudCB8IG51bGx9XG4gKi9cbmNvbnN0IGdldENhbmNlbEJ1dHRvbiA9ICgpID0+ICgvKiogQHR5cGUge0hUTUxCdXR0b25FbGVtZW50fSAqL2VsZW1lbnRCeVNlbGVjdG9yKGAuJHtzd2FsQ2xhc3Nlcy5hY3Rpb25zfSAuJHtzd2FsQ2xhc3Nlcy5jYW5jZWx9YCkpO1xuXG4vKipcbiAqIEByZXR1cm5zIHtIVE1MQnV0dG9uRWxlbWVudCB8IG51bGx9XG4gKi9cbmNvbnN0IGdldERlbnlCdXR0b24gPSAoKSA9PiAoLyoqIEB0eXBlIHtIVE1MQnV0dG9uRWxlbWVudH0gKi9lbGVtZW50QnlTZWxlY3RvcihgLiR7c3dhbENsYXNzZXMuYWN0aW9uc30gLiR7c3dhbENsYXNzZXMuZGVueX1gKSk7XG5cbi8qKlxuICogQHJldHVybnMge0hUTUxFbGVtZW50IHwgbnVsbH1cbiAqL1xuY29uc3QgZ2V0SW5wdXRMYWJlbCA9ICgpID0+IGVsZW1lbnRCeUNsYXNzKHN3YWxDbGFzc2VzWydpbnB1dC1sYWJlbCddKTtcblxuLyoqXG4gKiBAcmV0dXJucyB7SFRNTEVsZW1lbnQgfCBudWxsfVxuICovXG5jb25zdCBnZXRMb2FkZXIgPSAoKSA9PiBlbGVtZW50QnlTZWxlY3RvcihgLiR7c3dhbENsYXNzZXMubG9hZGVyfWApO1xuXG4vKipcbiAqIEByZXR1cm5zIHtIVE1MRWxlbWVudCB8IG51bGx9XG4gKi9cbmNvbnN0IGdldEFjdGlvbnMgPSAoKSA9PiBlbGVtZW50QnlDbGFzcyhzd2FsQ2xhc3Nlcy5hY3Rpb25zKTtcblxuLyoqXG4gKiBAcmV0dXJucyB7SFRNTEVsZW1lbnQgfCBudWxsfVxuICovXG5jb25zdCBnZXRGb290ZXIgPSAoKSA9PiBlbGVtZW50QnlDbGFzcyhzd2FsQ2xhc3Nlcy5mb290ZXIpO1xuXG4vKipcbiAqIEByZXR1cm5zIHtIVE1MRWxlbWVudCB8IG51bGx9XG4gKi9cbmNvbnN0IGdldFRpbWVyUHJvZ3Jlc3NCYXIgPSAoKSA9PiBlbGVtZW50QnlDbGFzcyhzd2FsQ2xhc3Nlc1sndGltZXItcHJvZ3Jlc3MtYmFyJ10pO1xuXG4vKipcbiAqIEByZXR1cm5zIHtIVE1MRWxlbWVudCB8IG51bGx9XG4gKi9cbmNvbnN0IGdldENsb3NlQnV0dG9uID0gKCkgPT4gZWxlbWVudEJ5Q2xhc3Moc3dhbENsYXNzZXMuY2xvc2UpO1xuXG4vLyBodHRwczovL2dpdGh1Yi5jb20vamt1cC9mb2N1c2FibGUvYmxvYi9tYXN0ZXIvaW5kZXguanNcbmNvbnN0IGZvY3VzYWJsZSA9IGBcbiAgYVtocmVmXSxcbiAgYXJlYVtocmVmXSxcbiAgaW5wdXQ6bm90KFtkaXNhYmxlZF0pLFxuICBzZWxlY3Q6bm90KFtkaXNhYmxlZF0pLFxuICB0ZXh0YXJlYTpub3QoW2Rpc2FibGVkXSksXG4gIGJ1dHRvbjpub3QoW2Rpc2FibGVkXSksXG4gIGlmcmFtZSxcbiAgb2JqZWN0LFxuICBlbWJlZCxcbiAgW3RhYmluZGV4PVwiMFwiXSxcbiAgW2NvbnRlbnRlZGl0YWJsZV0sXG4gIGF1ZGlvW2NvbnRyb2xzXSxcbiAgdmlkZW9bY29udHJvbHNdLFxuICBzdW1tYXJ5XG5gO1xuLyoqXG4gKiBAcmV0dXJucyB7SFRNTEVsZW1lbnRbXX1cbiAqL1xuY29uc3QgZ2V0Rm9jdXNhYmxlRWxlbWVudHMgPSAoKSA9PiB7XG4gIGNvbnN0IHBvcHVwID0gZ2V0UG9wdXAoKTtcbiAgaWYgKCFwb3B1cCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICAvKiogQHR5cGUge05vZGVMaXN0T2Y8SFRNTEVsZW1lbnQ+fSAqL1xuICBjb25zdCBmb2N1c2FibGVFbGVtZW50c1dpdGhUYWJpbmRleCA9IHBvcHVwLnF1ZXJ5U2VsZWN0b3JBbGwoJ1t0YWJpbmRleF06bm90KFt0YWJpbmRleD1cIi0xXCJdKTpub3QoW3RhYmluZGV4PVwiMFwiXSknKTtcbiAgY29uc3QgZm9jdXNhYmxlRWxlbWVudHNXaXRoVGFiaW5kZXhTb3J0ZWQgPSBBcnJheS5mcm9tKGZvY3VzYWJsZUVsZW1lbnRzV2l0aFRhYmluZGV4KVxuICAvLyBzb3J0IGFjY29yZGluZyB0byB0YWJpbmRleFxuICAuc29ydCgoYSwgYikgPT4ge1xuICAgIGNvbnN0IHRhYmluZGV4QSA9IHBhcnNlSW50KGEuZ2V0QXR0cmlidXRlKCd0YWJpbmRleCcpIHx8ICcwJyk7XG4gICAgY29uc3QgdGFiaW5kZXhCID0gcGFyc2VJbnQoYi5nZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JykgfHwgJzAnKTtcbiAgICBpZiAodGFiaW5kZXhBID4gdGFiaW5kZXhCKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9IGVsc2UgaWYgKHRhYmluZGV4QSA8IHRhYmluZGV4Qikge1xuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfSk7XG5cbiAgLyoqIEB0eXBlIHtOb2RlTGlzdE9mPEhUTUxFbGVtZW50Pn0gKi9cbiAgY29uc3Qgb3RoZXJGb2N1c2FibGVFbGVtZW50cyA9IHBvcHVwLnF1ZXJ5U2VsZWN0b3JBbGwoZm9jdXNhYmxlKTtcbiAgY29uc3Qgb3RoZXJGb2N1c2FibGVFbGVtZW50c0ZpbHRlcmVkID0gQXJyYXkuZnJvbShvdGhlckZvY3VzYWJsZUVsZW1lbnRzKS5maWx0ZXIoZWwgPT4gZWwuZ2V0QXR0cmlidXRlKCd0YWJpbmRleCcpICE9PSAnLTEnKTtcbiAgcmV0dXJuIFsuLi5uZXcgU2V0KGZvY3VzYWJsZUVsZW1lbnRzV2l0aFRhYmluZGV4U29ydGVkLmNvbmNhdChvdGhlckZvY3VzYWJsZUVsZW1lbnRzRmlsdGVyZWQpKV0uZmlsdGVyKGVsID0+IGlzVmlzaWJsZSQxKGVsKSk7XG59O1xuXG4vKipcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5jb25zdCBpc01vZGFsID0gKCkgPT4ge1xuICByZXR1cm4gaGFzQ2xhc3MoZG9jdW1lbnQuYm9keSwgc3dhbENsYXNzZXMuc2hvd24pICYmICFoYXNDbGFzcyhkb2N1bWVudC5ib2R5LCBzd2FsQ2xhc3Nlc1sndG9hc3Qtc2hvd24nXSkgJiYgIWhhc0NsYXNzKGRvY3VtZW50LmJvZHksIHN3YWxDbGFzc2VzWyduby1iYWNrZHJvcCddKTtcbn07XG5cbi8qKlxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmNvbnN0IGlzVG9hc3QgPSAoKSA9PiB7XG4gIGNvbnN0IHBvcHVwID0gZ2V0UG9wdXAoKTtcbiAgaWYgKCFwb3B1cCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gaGFzQ2xhc3MocG9wdXAsIHN3YWxDbGFzc2VzLnRvYXN0KTtcbn07XG5cbi8qKlxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmNvbnN0IGlzTG9hZGluZyA9ICgpID0+IHtcbiAgY29uc3QgcG9wdXAgPSBnZXRQb3B1cCgpO1xuICBpZiAoIXBvcHVwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBwb3B1cC5oYXNBdHRyaWJ1dGUoJ2RhdGEtbG9hZGluZycpO1xufTtcblxuLyoqXG4gKiBTZWN1cmVseSBzZXQgaW5uZXJIVE1MIG9mIGFuIGVsZW1lbnRcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9zd2VldGFsZXJ0Mi9zd2VldGFsZXJ0Mi9pc3N1ZXMvMTkyNlxuICpcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1cbiAqIEBwYXJhbSB7c3RyaW5nfSBodG1sXG4gKi9cbmNvbnN0IHNldElubmVySHRtbCA9IChlbGVtLCBodG1sKSA9PiB7XG4gIGVsZW0udGV4dENvbnRlbnQgPSAnJztcbiAgaWYgKGh0bWwpIHtcbiAgICBjb25zdCBwYXJzZXIgPSBuZXcgRE9NUGFyc2VyKCk7XG4gICAgY29uc3QgcGFyc2VkID0gcGFyc2VyLnBhcnNlRnJvbVN0cmluZyhodG1sLCBgdGV4dC9odG1sYCk7XG4gICAgY29uc3QgaGVhZCA9IHBhcnNlZC5xdWVyeVNlbGVjdG9yKCdoZWFkJyk7XG4gICAgaWYgKGhlYWQpIHtcbiAgICAgIEFycmF5LmZyb20oaGVhZC5jaGlsZE5vZGVzKS5mb3JFYWNoKGNoaWxkID0+IHtcbiAgICAgICAgZWxlbS5hcHBlbmRDaGlsZChjaGlsZCk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgY29uc3QgYm9keSA9IHBhcnNlZC5xdWVyeVNlbGVjdG9yKCdib2R5Jyk7XG4gICAgaWYgKGJvZHkpIHtcbiAgICAgIEFycmF5LmZyb20oYm9keS5jaGlsZE5vZGVzKS5mb3JFYWNoKGNoaWxkID0+IHtcbiAgICAgICAgaWYgKGNoaWxkIGluc3RhbmNlb2YgSFRNTFZpZGVvRWxlbWVudCB8fCBjaGlsZCBpbnN0YW5jZW9mIEhUTUxBdWRpb0VsZW1lbnQpIHtcbiAgICAgICAgICBlbGVtLmFwcGVuZENoaWxkKGNoaWxkLmNsb25lTm9kZSh0cnVlKSk7IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9zd2VldGFsZXJ0Mi9zd2VldGFsZXJ0Mi9pc3N1ZXMvMjUwN1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVsZW0uYXBwZW5kQ2hpbGQoY2hpbGQpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbVxuICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZVxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmNvbnN0IGhhc0NsYXNzID0gKGVsZW0sIGNsYXNzTmFtZSkgPT4ge1xuICBpZiAoIWNsYXNzTmFtZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBjbGFzc0xpc3QgPSBjbGFzc05hbWUuc3BsaXQoL1xccysvKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBjbGFzc0xpc3QubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoIWVsZW0uY2xhc3NMaXN0LmNvbnRhaW5zKGNsYXNzTGlzdFtpXSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1cbiAqIEBwYXJhbSB7U3dlZXRBbGVydE9wdGlvbnN9IHBhcmFtc1xuICovXG5jb25zdCByZW1vdmVDdXN0b21DbGFzc2VzID0gKGVsZW0sIHBhcmFtcykgPT4ge1xuICBBcnJheS5mcm9tKGVsZW0uY2xhc3NMaXN0KS5mb3JFYWNoKGNsYXNzTmFtZSA9PiB7XG4gICAgaWYgKCFPYmplY3QudmFsdWVzKHN3YWxDbGFzc2VzKS5pbmNsdWRlcyhjbGFzc05hbWUpICYmICFPYmplY3QudmFsdWVzKGljb25UeXBlcykuaW5jbHVkZXMoY2xhc3NOYW1lKSAmJiAhT2JqZWN0LnZhbHVlcyhwYXJhbXMuc2hvd0NsYXNzIHx8IHt9KS5pbmNsdWRlcyhjbGFzc05hbWUpKSB7XG4gICAgICBlbGVtLmNsYXNzTGlzdC5yZW1vdmUoY2xhc3NOYW1lKTtcbiAgICB9XG4gIH0pO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtXG4gKiBAcGFyYW0ge1N3ZWV0QWxlcnRPcHRpb25zfSBwYXJhbXNcbiAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWVcbiAqL1xuY29uc3QgYXBwbHlDdXN0b21DbGFzcyA9IChlbGVtLCBwYXJhbXMsIGNsYXNzTmFtZSkgPT4ge1xuICByZW1vdmVDdXN0b21DbGFzc2VzKGVsZW0sIHBhcmFtcyk7XG4gIGlmICghcGFyYW1zLmN1c3RvbUNsYXNzKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGN1c3RvbUNsYXNzID0gcGFyYW1zLmN1c3RvbUNsYXNzWygvKiogQHR5cGUge2tleW9mIFN3ZWV0QWxlcnRDdXN0b21DbGFzc30gKi9jbGFzc05hbWUpXTtcbiAgaWYgKCFjdXN0b21DbGFzcykge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAodHlwZW9mIGN1c3RvbUNsYXNzICE9PSAnc3RyaW5nJyAmJiAhY3VzdG9tQ2xhc3MuZm9yRWFjaCkge1xuICAgIHdhcm4oYEludmFsaWQgdHlwZSBvZiBjdXN0b21DbGFzcy4ke2NsYXNzTmFtZX0hIEV4cGVjdGVkIHN0cmluZyBvciBpdGVyYWJsZSBvYmplY3QsIGdvdCBcIiR7dHlwZW9mIGN1c3RvbUNsYXNzfVwiYCk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGFkZENsYXNzKGVsZW0sIGN1c3RvbUNsYXNzKTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gcG9wdXBcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL3JlbmRlcmVycy9yZW5kZXJJbnB1dCcpLklucHV0Q2xhc3MgfCBTd2VldEFsZXJ0SW5wdXR9IGlucHV0Q2xhc3NcbiAqIEByZXR1cm5zIHtIVE1MSW5wdXRFbGVtZW50IHwgbnVsbH1cbiAqL1xuY29uc3QgZ2V0SW5wdXQkMSA9IChwb3B1cCwgaW5wdXRDbGFzcykgPT4ge1xuICBpZiAoIWlucHV0Q2xhc3MpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBzd2l0Y2ggKGlucHV0Q2xhc3MpIHtcbiAgICBjYXNlICdzZWxlY3QnOlxuICAgIGNhc2UgJ3RleHRhcmVhJzpcbiAgICBjYXNlICdmaWxlJzpcbiAgICAgIHJldHVybiBwb3B1cC5xdWVyeVNlbGVjdG9yKGAuJHtzd2FsQ2xhc3Nlcy5wb3B1cH0gPiAuJHtzd2FsQ2xhc3Nlc1tpbnB1dENsYXNzXX1gKTtcbiAgICBjYXNlICdjaGVja2JveCc6XG4gICAgICByZXR1cm4gcG9wdXAucXVlcnlTZWxlY3RvcihgLiR7c3dhbENsYXNzZXMucG9wdXB9ID4gLiR7c3dhbENsYXNzZXMuY2hlY2tib3h9IGlucHV0YCk7XG4gICAgY2FzZSAncmFkaW8nOlxuICAgICAgcmV0dXJuIHBvcHVwLnF1ZXJ5U2VsZWN0b3IoYC4ke3N3YWxDbGFzc2VzLnBvcHVwfSA+IC4ke3N3YWxDbGFzc2VzLnJhZGlvfSBpbnB1dDpjaGVja2VkYCkgfHwgcG9wdXAucXVlcnlTZWxlY3RvcihgLiR7c3dhbENsYXNzZXMucG9wdXB9ID4gLiR7c3dhbENsYXNzZXMucmFkaW99IGlucHV0OmZpcnN0LWNoaWxkYCk7XG4gICAgY2FzZSAncmFuZ2UnOlxuICAgICAgcmV0dXJuIHBvcHVwLnF1ZXJ5U2VsZWN0b3IoYC4ke3N3YWxDbGFzc2VzLnBvcHVwfSA+IC4ke3N3YWxDbGFzc2VzLnJhbmdlfSBpbnB1dGApO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gcG9wdXAucXVlcnlTZWxlY3RvcihgLiR7c3dhbENsYXNzZXMucG9wdXB9ID4gLiR7c3dhbENsYXNzZXMuaW5wdXR9YCk7XG4gIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtIVE1MSW5wdXRFbGVtZW50IHwgSFRNTFRleHRBcmVhRWxlbWVudCB8IEhUTUxTZWxlY3RFbGVtZW50fSBpbnB1dFxuICovXG5jb25zdCBmb2N1c0lucHV0ID0gaW5wdXQgPT4ge1xuICBpbnB1dC5mb2N1cygpO1xuXG4gIC8vIHBsYWNlIGN1cnNvciBhdCBlbmQgb2YgdGV4dCBpbiB0ZXh0IGlucHV0XG4gIGlmIChpbnB1dC50eXBlICE9PSAnZmlsZScpIHtcbiAgICAvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yMzQ1OTE1XG4gICAgY29uc3QgdmFsID0gaW5wdXQudmFsdWU7XG4gICAgaW5wdXQudmFsdWUgPSAnJztcbiAgICBpbnB1dC52YWx1ZSA9IHZhbDtcbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50IHwgSFRNTEVsZW1lbnRbXSB8IG51bGx9IHRhcmdldFxuICogQHBhcmFtIHtzdHJpbmcgfCBzdHJpbmdbXSB8IHJlYWRvbmx5IHN0cmluZ1tdIHwgdW5kZWZpbmVkfSBjbGFzc0xpc3RcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gY29uZGl0aW9uXG4gKi9cbmNvbnN0IHRvZ2dsZUNsYXNzID0gKHRhcmdldCwgY2xhc3NMaXN0LCBjb25kaXRpb24pID0+IHtcbiAgaWYgKCF0YXJnZXQgfHwgIWNsYXNzTGlzdCkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAodHlwZW9mIGNsYXNzTGlzdCA9PT0gJ3N0cmluZycpIHtcbiAgICBjbGFzc0xpc3QgPSBjbGFzc0xpc3Quc3BsaXQoL1xccysvKS5maWx0ZXIoQm9vbGVhbik7XG4gIH1cbiAgY2xhc3NMaXN0LmZvckVhY2goY2xhc3NOYW1lID0+IHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh0YXJnZXQpKSB7XG4gICAgICB0YXJnZXQuZm9yRWFjaChlbGVtID0+IHtcbiAgICAgICAgaWYgKGNvbmRpdGlvbikge1xuICAgICAgICAgIGVsZW0uY2xhc3NMaXN0LmFkZChjbGFzc05hbWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVsZW0uY2xhc3NMaXN0LnJlbW92ZShjbGFzc05hbWUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGNvbmRpdGlvbikge1xuICAgICAgICB0YXJnZXQuY2xhc3NMaXN0LmFkZChjbGFzc05hbWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGFyZ2V0LmNsYXNzTGlzdC5yZW1vdmUoY2xhc3NOYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50IHwgSFRNTEVsZW1lbnRbXSB8IG51bGx9IHRhcmdldFxuICogQHBhcmFtIHtzdHJpbmcgfCBzdHJpbmdbXSB8IHJlYWRvbmx5IHN0cmluZ1tdIHwgdW5kZWZpbmVkfSBjbGFzc0xpc3RcbiAqL1xuY29uc3QgYWRkQ2xhc3MgPSAodGFyZ2V0LCBjbGFzc0xpc3QpID0+IHtcbiAgdG9nZ2xlQ2xhc3ModGFyZ2V0LCBjbGFzc0xpc3QsIHRydWUpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50IHwgSFRNTEVsZW1lbnRbXSB8IG51bGx9IHRhcmdldFxuICogQHBhcmFtIHtzdHJpbmcgfCBzdHJpbmdbXSB8IHJlYWRvbmx5IHN0cmluZ1tdIHwgdW5kZWZpbmVkfSBjbGFzc0xpc3RcbiAqL1xuY29uc3QgcmVtb3ZlQ2xhc3MgPSAodGFyZ2V0LCBjbGFzc0xpc3QpID0+IHtcbiAgdG9nZ2xlQ2xhc3ModGFyZ2V0LCBjbGFzc0xpc3QsIGZhbHNlKTtcbn07XG5cbi8qKlxuICogR2V0IGRpcmVjdCBjaGlsZCBvZiBhbiBlbGVtZW50IGJ5IGNsYXNzIG5hbWVcbiAqXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtXG4gKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lXG4gKiBAcmV0dXJucyB7SFRNTEVsZW1lbnQgfCB1bmRlZmluZWR9XG4gKi9cbmNvbnN0IGdldERpcmVjdENoaWxkQnlDbGFzcyA9IChlbGVtLCBjbGFzc05hbWUpID0+IHtcbiAgY29uc3QgY2hpbGRyZW4gPSBBcnJheS5mcm9tKGVsZW0uY2hpbGRyZW4pO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICBpZiAoY2hpbGQgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCAmJiBoYXNDbGFzcyhjaGlsZCwgY2xhc3NOYW1lKSkge1xuICAgICAgcmV0dXJuIGNoaWxkO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtXG4gKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHlcbiAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAqL1xuY29uc3QgYXBwbHlOdW1lcmljYWxTdHlsZSA9IChlbGVtLCBwcm9wZXJ0eSwgdmFsdWUpID0+IHtcbiAgaWYgKHZhbHVlID09PSBgJHtwYXJzZUludCh2YWx1ZSl9YCkge1xuICAgIHZhbHVlID0gcGFyc2VJbnQodmFsdWUpO1xuICB9XG4gIGlmICh2YWx1ZSB8fCBwYXJzZUludCh2YWx1ZSkgPT09IDApIHtcbiAgICBlbGVtLnN0eWxlLnNldFByb3BlcnR5KHByb3BlcnR5LCB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInID8gYCR7dmFsdWV9cHhgIDogdmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIGVsZW0uc3R5bGUucmVtb3ZlUHJvcGVydHkocHJvcGVydHkpO1xuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnQgfCBudWxsfSBlbGVtXG4gKiBAcGFyYW0ge3N0cmluZ30gZGlzcGxheVxuICovXG5jb25zdCBzaG93ID0gZnVuY3Rpb24gKGVsZW0pIHtcbiAgbGV0IGRpc3BsYXkgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6ICdmbGV4JztcbiAgaWYgKCFlbGVtKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGVsZW0uc3R5bGUuZGlzcGxheSA9IGRpc3BsYXk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnQgfCBudWxsfSBlbGVtXG4gKi9cbmNvbnN0IGhpZGUgPSBlbGVtID0+IHtcbiAgaWYgKCFlbGVtKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGVsZW0uc3R5bGUuZGlzcGxheSA9ICdub25lJztcbn07XG5cbi8qKlxuICogQHBhcmFtIHtIVE1MRWxlbWVudCB8IG51bGx9IGVsZW1cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXNwbGF5XG4gKi9cbmNvbnN0IHNob3dXaGVuSW5uZXJIdG1sUHJlc2VudCA9IGZ1bmN0aW9uIChlbGVtKSB7XG4gIGxldCBkaXNwbGF5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAnYmxvY2snO1xuICBpZiAoIWVsZW0pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgbmV3IE11dGF0aW9uT2JzZXJ2ZXIoKCkgPT4ge1xuICAgIHRvZ2dsZShlbGVtLCBlbGVtLmlubmVySFRNTCwgZGlzcGxheSk7XG4gIH0pLm9ic2VydmUoZWxlbSwge1xuICAgIGNoaWxkTGlzdDogdHJ1ZSxcbiAgICBzdWJ0cmVlOiB0cnVlXG4gIH0pO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBwYXJlbnRcbiAqIEBwYXJhbSB7c3RyaW5nfSBzZWxlY3RvclxuICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5XG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAqL1xuY29uc3Qgc2V0U3R5bGUgPSAocGFyZW50LCBzZWxlY3RvciwgcHJvcGVydHksIHZhbHVlKSA9PiB7XG4gIC8qKiBAdHlwZSB7SFRNTEVsZW1lbnQgfCBudWxsfSAqL1xuICBjb25zdCBlbCA9IHBhcmVudC5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKTtcbiAgaWYgKGVsKSB7XG4gICAgZWwuc3R5bGUuc2V0UHJvcGVydHkocHJvcGVydHksIHZhbHVlKTtcbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtXG4gKiBAcGFyYW0ge2FueX0gY29uZGl0aW9uXG4gKiBAcGFyYW0ge3N0cmluZ30gZGlzcGxheVxuICovXG5jb25zdCB0b2dnbGUgPSBmdW5jdGlvbiAoZWxlbSwgY29uZGl0aW9uKSB7XG4gIGxldCBkaXNwbGF5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiAnZmxleCc7XG4gIGlmIChjb25kaXRpb24pIHtcbiAgICBzaG93KGVsZW0sIGRpc3BsYXkpO1xuICB9IGVsc2Uge1xuICAgIGhpZGUoZWxlbSk7XG4gIH1cbn07XG5cbi8qKlxuICogYm9ycm93ZWQgZnJvbSBqcXVlcnkgJChlbGVtKS5pcygnOnZpc2libGUnKSBpbXBsZW1lbnRhdGlvblxuICpcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnQgfCBudWxsfSBlbGVtXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuY29uc3QgaXNWaXNpYmxlJDEgPSBlbGVtID0+ICEhKGVsZW0gJiYgKGVsZW0ub2Zmc2V0V2lkdGggfHwgZWxlbS5vZmZzZXRIZWlnaHQgfHwgZWxlbS5nZXRDbGllbnRSZWN0cygpLmxlbmd0aCkpO1xuXG4vKipcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5jb25zdCBhbGxCdXR0b25zQXJlSGlkZGVuID0gKCkgPT4gIWlzVmlzaWJsZSQxKGdldENvbmZpcm1CdXR0b24oKSkgJiYgIWlzVmlzaWJsZSQxKGdldERlbnlCdXR0b24oKSkgJiYgIWlzVmlzaWJsZSQxKGdldENhbmNlbEJ1dHRvbigpKTtcblxuLyoqXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuY29uc3QgaXNTY3JvbGxhYmxlID0gZWxlbSA9PiAhIShlbGVtLnNjcm9sbEhlaWdodCA+IGVsZW0uY2xpZW50SGVpZ2h0KTtcblxuLyoqXG4gKiBib3Jyb3dlZCBmcm9tIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS80NjM1MjExOVxuICpcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1cbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5jb25zdCBoYXNDc3NBbmltYXRpb24gPSBlbGVtID0+IHtcbiAgY29uc3Qgc3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtKTtcbiAgY29uc3QgYW5pbUR1cmF0aW9uID0gcGFyc2VGbG9hdChzdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKCdhbmltYXRpb24tZHVyYXRpb24nKSB8fCAnMCcpO1xuICBjb25zdCB0cmFuc0R1cmF0aW9uID0gcGFyc2VGbG9hdChzdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKCd0cmFuc2l0aW9uLWR1cmF0aW9uJykgfHwgJzAnKTtcbiAgcmV0dXJuIGFuaW1EdXJhdGlvbiA+IDAgfHwgdHJhbnNEdXJhdGlvbiA+IDA7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lclxuICogQHBhcmFtIHtib29sZWFufSByZXNldFxuICovXG5jb25zdCBhbmltYXRlVGltZXJQcm9ncmVzc0JhciA9IGZ1bmN0aW9uICh0aW1lcikge1xuICBsZXQgcmVzZXQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZhbHNlO1xuICBjb25zdCB0aW1lclByb2dyZXNzQmFyID0gZ2V0VGltZXJQcm9ncmVzc0JhcigpO1xuICBpZiAoIXRpbWVyUHJvZ3Jlc3NCYXIpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKGlzVmlzaWJsZSQxKHRpbWVyUHJvZ3Jlc3NCYXIpKSB7XG4gICAgaWYgKHJlc2V0KSB7XG4gICAgICB0aW1lclByb2dyZXNzQmFyLnN0eWxlLnRyYW5zaXRpb24gPSAnbm9uZSc7XG4gICAgICB0aW1lclByb2dyZXNzQmFyLnN0eWxlLndpZHRoID0gJzEwMCUnO1xuICAgIH1cbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRpbWVyUHJvZ3Jlc3NCYXIuc3R5bGUudHJhbnNpdGlvbiA9IGB3aWR0aCAke3RpbWVyIC8gMTAwMH1zIGxpbmVhcmA7XG4gICAgICB0aW1lclByb2dyZXNzQmFyLnN0eWxlLndpZHRoID0gJzAlJztcbiAgICB9LCAxMCk7XG4gIH1cbn07XG5jb25zdCBzdG9wVGltZXJQcm9ncmVzc0JhciA9ICgpID0+IHtcbiAgY29uc3QgdGltZXJQcm9ncmVzc0JhciA9IGdldFRpbWVyUHJvZ3Jlc3NCYXIoKTtcbiAgaWYgKCF0aW1lclByb2dyZXNzQmFyKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHRpbWVyUHJvZ3Jlc3NCYXJXaWR0aCA9IHBhcnNlSW50KHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHRpbWVyUHJvZ3Jlc3NCYXIpLndpZHRoKTtcbiAgdGltZXJQcm9ncmVzc0Jhci5zdHlsZS5yZW1vdmVQcm9wZXJ0eSgndHJhbnNpdGlvbicpO1xuICB0aW1lclByb2dyZXNzQmFyLnN0eWxlLndpZHRoID0gJzEwMCUnO1xuICBjb25zdCB0aW1lclByb2dyZXNzQmFyRnVsbFdpZHRoID0gcGFyc2VJbnQod2luZG93LmdldENvbXB1dGVkU3R5bGUodGltZXJQcm9ncmVzc0Jhcikud2lkdGgpO1xuICBjb25zdCB0aW1lclByb2dyZXNzQmFyUGVyY2VudCA9IHRpbWVyUHJvZ3Jlc3NCYXJXaWR0aCAvIHRpbWVyUHJvZ3Jlc3NCYXJGdWxsV2lkdGggKiAxMDA7XG4gIHRpbWVyUHJvZ3Jlc3NCYXIuc3R5bGUud2lkdGggPSBgJHt0aW1lclByb2dyZXNzQmFyUGVyY2VudH0lYDtcbn07XG5cbi8qKlxuICogRGV0ZWN0IE5vZGUgZW52XG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmNvbnN0IGlzTm9kZUVudiA9ICgpID0+IHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnIHx8IHR5cGVvZiBkb2N1bWVudCA9PT0gJ3VuZGVmaW5lZCc7XG5cbmNvbnN0IHN3ZWV0SFRNTCA9IGBcbiA8ZGl2IGFyaWEtbGFiZWxsZWRieT1cIiR7c3dhbENsYXNzZXMudGl0bGV9XCIgYXJpYS1kZXNjcmliZWRieT1cIiR7c3dhbENsYXNzZXNbJ2h0bWwtY29udGFpbmVyJ119XCIgY2xhc3M9XCIke3N3YWxDbGFzc2VzLnBvcHVwfVwiIHRhYmluZGV4PVwiLTFcIj5cbiAgIDxidXR0b24gdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwiJHtzd2FsQ2xhc3Nlcy5jbG9zZX1cIj48L2J1dHRvbj5cbiAgIDx1bCBjbGFzcz1cIiR7c3dhbENsYXNzZXNbJ3Byb2dyZXNzLXN0ZXBzJ119XCI+PC91bD5cbiAgIDxkaXYgY2xhc3M9XCIke3N3YWxDbGFzc2VzLmljb259XCI+PC9kaXY+XG4gICA8aW1nIGNsYXNzPVwiJHtzd2FsQ2xhc3Nlcy5pbWFnZX1cIiAvPlxuICAgPGgyIGNsYXNzPVwiJHtzd2FsQ2xhc3Nlcy50aXRsZX1cIiBpZD1cIiR7c3dhbENsYXNzZXMudGl0bGV9XCI+PC9oMj5cbiAgIDxkaXYgY2xhc3M9XCIke3N3YWxDbGFzc2VzWydodG1sLWNvbnRhaW5lciddfVwiIGlkPVwiJHtzd2FsQ2xhc3Nlc1snaHRtbC1jb250YWluZXInXX1cIj48L2Rpdj5cbiAgIDxpbnB1dCBjbGFzcz1cIiR7c3dhbENsYXNzZXMuaW5wdXR9XCIgaWQ9XCIke3N3YWxDbGFzc2VzLmlucHV0fVwiIC8+XG4gICA8aW5wdXQgdHlwZT1cImZpbGVcIiBjbGFzcz1cIiR7c3dhbENsYXNzZXMuZmlsZX1cIiAvPlxuICAgPGRpdiBjbGFzcz1cIiR7c3dhbENsYXNzZXMucmFuZ2V9XCI+XG4gICAgIDxpbnB1dCB0eXBlPVwicmFuZ2VcIiAvPlxuICAgICA8b3V0cHV0Pjwvb3V0cHV0PlxuICAgPC9kaXY+XG4gICA8c2VsZWN0IGNsYXNzPVwiJHtzd2FsQ2xhc3Nlcy5zZWxlY3R9XCIgaWQ9XCIke3N3YWxDbGFzc2VzLnNlbGVjdH1cIj48L3NlbGVjdD5cbiAgIDxkaXYgY2xhc3M9XCIke3N3YWxDbGFzc2VzLnJhZGlvfVwiPjwvZGl2PlxuICAgPGxhYmVsIGNsYXNzPVwiJHtzd2FsQ2xhc3Nlcy5jaGVja2JveH1cIj5cbiAgICAgPGlucHV0IHR5cGU9XCJjaGVja2JveFwiIGlkPVwiJHtzd2FsQ2xhc3Nlcy5jaGVja2JveH1cIiAvPlxuICAgICA8c3BhbiBjbGFzcz1cIiR7c3dhbENsYXNzZXMubGFiZWx9XCI+PC9zcGFuPlxuICAgPC9sYWJlbD5cbiAgIDx0ZXh0YXJlYSBjbGFzcz1cIiR7c3dhbENsYXNzZXMudGV4dGFyZWF9XCIgaWQ9XCIke3N3YWxDbGFzc2VzLnRleHRhcmVhfVwiPjwvdGV4dGFyZWE+XG4gICA8ZGl2IGNsYXNzPVwiJHtzd2FsQ2xhc3Nlc1sndmFsaWRhdGlvbi1tZXNzYWdlJ119XCIgaWQ9XCIke3N3YWxDbGFzc2VzWyd2YWxpZGF0aW9uLW1lc3NhZ2UnXX1cIj48L2Rpdj5cbiAgIDxkaXYgY2xhc3M9XCIke3N3YWxDbGFzc2VzLmFjdGlvbnN9XCI+XG4gICAgIDxkaXYgY2xhc3M9XCIke3N3YWxDbGFzc2VzLmxvYWRlcn1cIj48L2Rpdj5cbiAgICAgPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgY2xhc3M9XCIke3N3YWxDbGFzc2VzLmNvbmZpcm19XCI+PC9idXR0b24+XG4gICAgIDxidXR0b24gdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwiJHtzd2FsQ2xhc3Nlcy5kZW55fVwiPjwvYnV0dG9uPlxuICAgICA8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cIiR7c3dhbENsYXNzZXMuY2FuY2VsfVwiPjwvYnV0dG9uPlxuICAgPC9kaXY+XG4gICA8ZGl2IGNsYXNzPVwiJHtzd2FsQ2xhc3Nlcy5mb290ZXJ9XCI+PC9kaXY+XG4gICA8ZGl2IGNsYXNzPVwiJHtzd2FsQ2xhc3Nlc1sndGltZXItcHJvZ3Jlc3MtYmFyLWNvbnRhaW5lciddfVwiPlxuICAgICA8ZGl2IGNsYXNzPVwiJHtzd2FsQ2xhc3Nlc1sndGltZXItcHJvZ3Jlc3MtYmFyJ119XCI+PC9kaXY+XG4gICA8L2Rpdj5cbiA8L2Rpdj5cbmAucmVwbGFjZSgvKF58XFxuKVxccyovZywgJycpO1xuXG4vKipcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5jb25zdCByZXNldE9sZENvbnRhaW5lciA9ICgpID0+IHtcbiAgY29uc3Qgb2xkQ29udGFpbmVyID0gZ2V0Q29udGFpbmVyKCk7XG4gIGlmICghb2xkQ29udGFpbmVyKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIG9sZENvbnRhaW5lci5yZW1vdmUoKTtcbiAgcmVtb3ZlQ2xhc3MoW2RvY3VtZW50LmRvY3VtZW50RWxlbWVudCwgZG9jdW1lbnQuYm9keV0sIFtzd2FsQ2xhc3Nlc1snbm8tYmFja2Ryb3AnXSwgc3dhbENsYXNzZXNbJ3RvYXN0LXNob3duJ10sIHN3YWxDbGFzc2VzWydoYXMtY29sdW1uJ11dKTtcbiAgcmV0dXJuIHRydWU7XG59O1xuY29uc3QgcmVzZXRWYWxpZGF0aW9uTWVzc2FnZSQxID0gKCkgPT4ge1xuICBnbG9iYWxTdGF0ZS5jdXJyZW50SW5zdGFuY2UucmVzZXRWYWxpZGF0aW9uTWVzc2FnZSgpO1xufTtcbmNvbnN0IGFkZElucHV0Q2hhbmdlTGlzdGVuZXJzID0gKCkgPT4ge1xuICBjb25zdCBwb3B1cCA9IGdldFBvcHVwKCk7XG4gIGNvbnN0IGlucHV0ID0gZ2V0RGlyZWN0Q2hpbGRCeUNsYXNzKHBvcHVwLCBzd2FsQ2xhc3Nlcy5pbnB1dCk7XG4gIGNvbnN0IGZpbGUgPSBnZXREaXJlY3RDaGlsZEJ5Q2xhc3MocG9wdXAsIHN3YWxDbGFzc2VzLmZpbGUpO1xuICAvKiogQHR5cGUge0hUTUxJbnB1dEVsZW1lbnR9ICovXG4gIGNvbnN0IHJhbmdlID0gcG9wdXAucXVlcnlTZWxlY3RvcihgLiR7c3dhbENsYXNzZXMucmFuZ2V9IGlucHV0YCk7XG4gIC8qKiBAdHlwZSB7SFRNTE91dHB1dEVsZW1lbnR9ICovXG4gIGNvbnN0IHJhbmdlT3V0cHV0ID0gcG9wdXAucXVlcnlTZWxlY3RvcihgLiR7c3dhbENsYXNzZXMucmFuZ2V9IG91dHB1dGApO1xuICBjb25zdCBzZWxlY3QgPSBnZXREaXJlY3RDaGlsZEJ5Q2xhc3MocG9wdXAsIHN3YWxDbGFzc2VzLnNlbGVjdCk7XG4gIC8qKiBAdHlwZSB7SFRNTElucHV0RWxlbWVudH0gKi9cbiAgY29uc3QgY2hlY2tib3ggPSBwb3B1cC5xdWVyeVNlbGVjdG9yKGAuJHtzd2FsQ2xhc3Nlcy5jaGVja2JveH0gaW5wdXRgKTtcbiAgY29uc3QgdGV4dGFyZWEgPSBnZXREaXJlY3RDaGlsZEJ5Q2xhc3MocG9wdXAsIHN3YWxDbGFzc2VzLnRleHRhcmVhKTtcbiAgaW5wdXQub25pbnB1dCA9IHJlc2V0VmFsaWRhdGlvbk1lc3NhZ2UkMTtcbiAgZmlsZS5vbmNoYW5nZSA9IHJlc2V0VmFsaWRhdGlvbk1lc3NhZ2UkMTtcbiAgc2VsZWN0Lm9uY2hhbmdlID0gcmVzZXRWYWxpZGF0aW9uTWVzc2FnZSQxO1xuICBjaGVja2JveC5vbmNoYW5nZSA9IHJlc2V0VmFsaWRhdGlvbk1lc3NhZ2UkMTtcbiAgdGV4dGFyZWEub25pbnB1dCA9IHJlc2V0VmFsaWRhdGlvbk1lc3NhZ2UkMTtcbiAgcmFuZ2Uub25pbnB1dCA9ICgpID0+IHtcbiAgICByZXNldFZhbGlkYXRpb25NZXNzYWdlJDEoKTtcbiAgICByYW5nZU91dHB1dC52YWx1ZSA9IHJhbmdlLnZhbHVlO1xuICB9O1xuICByYW5nZS5vbmNoYW5nZSA9ICgpID0+IHtcbiAgICByZXNldFZhbGlkYXRpb25NZXNzYWdlJDEoKTtcbiAgICByYW5nZU91dHB1dC52YWx1ZSA9IHJhbmdlLnZhbHVlO1xuICB9O1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZyB8IEhUTUxFbGVtZW50fSB0YXJnZXRcbiAqIEByZXR1cm5zIHtIVE1MRWxlbWVudH1cbiAqL1xuY29uc3QgZ2V0VGFyZ2V0ID0gdGFyZ2V0ID0+IHR5cGVvZiB0YXJnZXQgPT09ICdzdHJpbmcnID8gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcih0YXJnZXQpIDogdGFyZ2V0O1xuXG4vKipcbiAqIEBwYXJhbSB7U3dlZXRBbGVydE9wdGlvbnN9IHBhcmFtc1xuICovXG5jb25zdCBzZXR1cEFjY2Vzc2liaWxpdHkgPSBwYXJhbXMgPT4ge1xuICBjb25zdCBwb3B1cCA9IGdldFBvcHVwKCk7XG4gIHBvcHVwLnNldEF0dHJpYnV0ZSgncm9sZScsIHBhcmFtcy50b2FzdCA/ICdhbGVydCcgOiAnZGlhbG9nJyk7XG4gIHBvcHVwLnNldEF0dHJpYnV0ZSgnYXJpYS1saXZlJywgcGFyYW1zLnRvYXN0ID8gJ3BvbGl0ZScgOiAnYXNzZXJ0aXZlJyk7XG4gIGlmICghcGFyYW1zLnRvYXN0KSB7XG4gICAgcG9wdXAuc2V0QXR0cmlidXRlKCdhcmlhLW1vZGFsJywgJ3RydWUnKTtcbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSB0YXJnZXRFbGVtZW50XG4gKi9cbmNvbnN0IHNldHVwUlRMID0gdGFyZ2V0RWxlbWVudCA9PiB7XG4gIGlmICh3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSh0YXJnZXRFbGVtZW50KS5kaXJlY3Rpb24gPT09ICdydGwnKSB7XG4gICAgYWRkQ2xhc3MoZ2V0Q29udGFpbmVyKCksIHN3YWxDbGFzc2VzLnJ0bCk7XG4gIH1cbn07XG5cbi8qKlxuICogQWRkIG1vZGFsICsgYmFja2Ryb3AgKyBuby13YXIgbWVzc2FnZSBmb3IgUnVzc2lhbnMgdG8gRE9NXG4gKlxuICogQHBhcmFtIHtTd2VldEFsZXJ0T3B0aW9uc30gcGFyYW1zXG4gKi9cbmNvbnN0IGluaXQgPSBwYXJhbXMgPT4ge1xuICAvLyBDbGVhbiB1cCB0aGUgb2xkIHBvcHVwIGNvbnRhaW5lciBpZiBpdCBleGlzdHNcbiAgY29uc3Qgb2xkQ29udGFpbmVyRXhpc3RlZCA9IHJlc2V0T2xkQ29udGFpbmVyKCk7XG4gIGlmIChpc05vZGVFbnYoKSkge1xuICAgIGVycm9yKCdTd2VldEFsZXJ0MiByZXF1aXJlcyBkb2N1bWVudCB0byBpbml0aWFsaXplJyk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICBjb250YWluZXIuY2xhc3NOYW1lID0gc3dhbENsYXNzZXMuY29udGFpbmVyO1xuICBpZiAob2xkQ29udGFpbmVyRXhpc3RlZCkge1xuICAgIGFkZENsYXNzKGNvbnRhaW5lciwgc3dhbENsYXNzZXNbJ25vLXRyYW5zaXRpb24nXSk7XG4gIH1cbiAgc2V0SW5uZXJIdG1sKGNvbnRhaW5lciwgc3dlZXRIVE1MKTtcbiAgY29uc3QgdGFyZ2V0RWxlbWVudCA9IGdldFRhcmdldChwYXJhbXMudGFyZ2V0KTtcbiAgdGFyZ2V0RWxlbWVudC5hcHBlbmRDaGlsZChjb250YWluZXIpO1xuICBzZXR1cEFjY2Vzc2liaWxpdHkocGFyYW1zKTtcbiAgc2V0dXBSVEwodGFyZ2V0RWxlbWVudCk7XG4gIGFkZElucHV0Q2hhbmdlTGlzdGVuZXJzKCk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnQgfCBvYmplY3QgfCBzdHJpbmd9IHBhcmFtXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSB0YXJnZXRcbiAqL1xuY29uc3QgcGFyc2VIdG1sVG9Db250YWluZXIgPSAocGFyYW0sIHRhcmdldCkgPT4ge1xuICAvLyBET00gZWxlbWVudFxuICBpZiAocGFyYW0gaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkge1xuICAgIHRhcmdldC5hcHBlbmRDaGlsZChwYXJhbSk7XG4gIH1cblxuICAvLyBPYmplY3RcbiAgZWxzZSBpZiAodHlwZW9mIHBhcmFtID09PSAnb2JqZWN0Jykge1xuICAgIGhhbmRsZU9iamVjdChwYXJhbSwgdGFyZ2V0KTtcbiAgfVxuXG4gIC8vIFBsYWluIHN0cmluZ1xuICBlbHNlIGlmIChwYXJhbSkge1xuICAgIHNldElubmVySHRtbCh0YXJnZXQsIHBhcmFtKTtcbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge2FueX0gcGFyYW1cbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHRhcmdldFxuICovXG5jb25zdCBoYW5kbGVPYmplY3QgPSAocGFyYW0sIHRhcmdldCkgPT4ge1xuICAvLyBKUXVlcnkgZWxlbWVudChzKVxuICBpZiAocGFyYW0uanF1ZXJ5KSB7XG4gICAgaGFuZGxlSnF1ZXJ5RWxlbSh0YXJnZXQsIHBhcmFtKTtcbiAgfVxuXG4gIC8vIEZvciBvdGhlciBvYmplY3RzIHVzZSB0aGVpciBzdHJpbmcgcmVwcmVzZW50YXRpb25cbiAgZWxzZSB7XG4gICAgc2V0SW5uZXJIdG1sKHRhcmdldCwgcGFyYW0udG9TdHJpbmcoKSk7XG4gIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gdGFyZ2V0XG4gKiBAcGFyYW0ge2FueX0gZWxlbVxuICovXG5jb25zdCBoYW5kbGVKcXVlcnlFbGVtID0gKHRhcmdldCwgZWxlbSkgPT4ge1xuICB0YXJnZXQudGV4dENvbnRlbnQgPSAnJztcbiAgaWYgKDAgaW4gZWxlbSkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIGluIGVsZW07IGkrKykge1xuICAgICAgdGFyZ2V0LmFwcGVuZENoaWxkKGVsZW1baV0uY2xvbmVOb2RlKHRydWUpKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGFyZ2V0LmFwcGVuZENoaWxkKGVsZW0uY2xvbmVOb2RlKHRydWUpKTtcbiAgfVxufTtcblxuLyoqXG4gKiBAcmV0dXJucyB7J3dlYmtpdEFuaW1hdGlvbkVuZCcgfCAnYW5pbWF0aW9uZW5kJyB8IGZhbHNlfVxuICovXG5jb25zdCBhbmltYXRpb25FbmRFdmVudCA9ICgoKSA9PiB7XG4gIC8vIFByZXZlbnQgcnVuIGluIE5vZGUgZW52XG4gIGlmIChpc05vZGVFbnYoKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCB0ZXN0RWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblxuICAvLyBDaHJvbWUsIFNhZmFyaSBhbmQgT3BlcmFcbiAgaWYgKHR5cGVvZiB0ZXN0RWwuc3R5bGUud2Via2l0QW5pbWF0aW9uICE9PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiAnd2Via2l0QW5pbWF0aW9uRW5kJztcbiAgfVxuXG4gIC8vIFN0YW5kYXJkIHN5bnRheFxuICBpZiAodHlwZW9mIHRlc3RFbC5zdHlsZS5hbmltYXRpb24gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuICdhbmltYXRpb25lbmQnO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn0pKCk7XG5cbi8qKlxuICogQHBhcmFtIHtTd2VldEFsZXJ0fSBpbnN0YW5jZVxuICogQHBhcmFtIHtTd2VldEFsZXJ0T3B0aW9uc30gcGFyYW1zXG4gKi9cbmNvbnN0IHJlbmRlckFjdGlvbnMgPSAoaW5zdGFuY2UsIHBhcmFtcykgPT4ge1xuICBjb25zdCBhY3Rpb25zID0gZ2V0QWN0aW9ucygpO1xuICBjb25zdCBsb2FkZXIgPSBnZXRMb2FkZXIoKTtcbiAgaWYgKCFhY3Rpb25zIHx8ICFsb2FkZXIpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBBY3Rpb25zIChidXR0b25zKSB3cmFwcGVyXG4gIGlmICghcGFyYW1zLnNob3dDb25maXJtQnV0dG9uICYmICFwYXJhbXMuc2hvd0RlbnlCdXR0b24gJiYgIXBhcmFtcy5zaG93Q2FuY2VsQnV0dG9uKSB7XG4gICAgaGlkZShhY3Rpb25zKTtcbiAgfSBlbHNlIHtcbiAgICBzaG93KGFjdGlvbnMpO1xuICB9XG5cbiAgLy8gQ3VzdG9tIGNsYXNzXG4gIGFwcGx5Q3VzdG9tQ2xhc3MoYWN0aW9ucywgcGFyYW1zLCAnYWN0aW9ucycpO1xuXG4gIC8vIFJlbmRlciBhbGwgdGhlIGJ1dHRvbnNcbiAgcmVuZGVyQnV0dG9ucyhhY3Rpb25zLCBsb2FkZXIsIHBhcmFtcyk7XG5cbiAgLy8gTG9hZGVyXG4gIHNldElubmVySHRtbChsb2FkZXIsIHBhcmFtcy5sb2FkZXJIdG1sIHx8ICcnKTtcbiAgYXBwbHlDdXN0b21DbGFzcyhsb2FkZXIsIHBhcmFtcywgJ2xvYWRlcicpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBhY3Rpb25zXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBsb2FkZXJcbiAqIEBwYXJhbSB7U3dlZXRBbGVydE9wdGlvbnN9IHBhcmFtc1xuICovXG5mdW5jdGlvbiByZW5kZXJCdXR0b25zKGFjdGlvbnMsIGxvYWRlciwgcGFyYW1zKSB7XG4gIGNvbnN0IGNvbmZpcm1CdXR0b24gPSBnZXRDb25maXJtQnV0dG9uKCk7XG4gIGNvbnN0IGRlbnlCdXR0b24gPSBnZXREZW55QnV0dG9uKCk7XG4gIGNvbnN0IGNhbmNlbEJ1dHRvbiA9IGdldENhbmNlbEJ1dHRvbigpO1xuICBpZiAoIWNvbmZpcm1CdXR0b24gfHwgIWRlbnlCdXR0b24gfHwgIWNhbmNlbEJ1dHRvbikge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIFJlbmRlciBidXR0b25zXG4gIHJlbmRlckJ1dHRvbihjb25maXJtQnV0dG9uLCAnY29uZmlybScsIHBhcmFtcyk7XG4gIHJlbmRlckJ1dHRvbihkZW55QnV0dG9uLCAnZGVueScsIHBhcmFtcyk7XG4gIHJlbmRlckJ1dHRvbihjYW5jZWxCdXR0b24sICdjYW5jZWwnLCBwYXJhbXMpO1xuICBoYW5kbGVCdXR0b25zU3R5bGluZyhjb25maXJtQnV0dG9uLCBkZW55QnV0dG9uLCBjYW5jZWxCdXR0b24sIHBhcmFtcyk7XG4gIGlmIChwYXJhbXMucmV2ZXJzZUJ1dHRvbnMpIHtcbiAgICBpZiAocGFyYW1zLnRvYXN0KSB7XG4gICAgICBhY3Rpb25zLmluc2VydEJlZm9yZShjYW5jZWxCdXR0b24sIGNvbmZpcm1CdXR0b24pO1xuICAgICAgYWN0aW9ucy5pbnNlcnRCZWZvcmUoZGVueUJ1dHRvbiwgY29uZmlybUJ1dHRvbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFjdGlvbnMuaW5zZXJ0QmVmb3JlKGNhbmNlbEJ1dHRvbiwgbG9hZGVyKTtcbiAgICAgIGFjdGlvbnMuaW5zZXJ0QmVmb3JlKGRlbnlCdXR0b24sIGxvYWRlcik7XG4gICAgICBhY3Rpb25zLmluc2VydEJlZm9yZShjb25maXJtQnV0dG9uLCBsb2FkZXIpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGNvbmZpcm1CdXR0b25cbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGRlbnlCdXR0b25cbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGNhbmNlbEJ1dHRvblxuICogQHBhcmFtIHtTd2VldEFsZXJ0T3B0aW9uc30gcGFyYW1zXG4gKi9cbmZ1bmN0aW9uIGhhbmRsZUJ1dHRvbnNTdHlsaW5nKGNvbmZpcm1CdXR0b24sIGRlbnlCdXR0b24sIGNhbmNlbEJ1dHRvbiwgcGFyYW1zKSB7XG4gIGlmICghcGFyYW1zLmJ1dHRvbnNTdHlsaW5nKSB7XG4gICAgcmVtb3ZlQ2xhc3MoW2NvbmZpcm1CdXR0b24sIGRlbnlCdXR0b24sIGNhbmNlbEJ1dHRvbl0sIHN3YWxDbGFzc2VzLnN0eWxlZCk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGFkZENsYXNzKFtjb25maXJtQnV0dG9uLCBkZW55QnV0dG9uLCBjYW5jZWxCdXR0b25dLCBzd2FsQ2xhc3Nlcy5zdHlsZWQpO1xuXG4gIC8vIEJ1dHRvbnMgYmFja2dyb3VuZCBjb2xvcnNcbiAgaWYgKHBhcmFtcy5jb25maXJtQnV0dG9uQ29sb3IpIHtcbiAgICBjb25maXJtQnV0dG9uLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IHBhcmFtcy5jb25maXJtQnV0dG9uQ29sb3I7XG4gICAgYWRkQ2xhc3MoY29uZmlybUJ1dHRvbiwgc3dhbENsYXNzZXNbJ2RlZmF1bHQtb3V0bGluZSddKTtcbiAgfVxuICBpZiAocGFyYW1zLmRlbnlCdXR0b25Db2xvcikge1xuICAgIGRlbnlCdXR0b24uc3R5bGUuYmFja2dyb3VuZENvbG9yID0gcGFyYW1zLmRlbnlCdXR0b25Db2xvcjtcbiAgICBhZGRDbGFzcyhkZW55QnV0dG9uLCBzd2FsQ2xhc3Nlc1snZGVmYXVsdC1vdXRsaW5lJ10pO1xuICB9XG4gIGlmIChwYXJhbXMuY2FuY2VsQnV0dG9uQ29sb3IpIHtcbiAgICBjYW5jZWxCdXR0b24uc3R5bGUuYmFja2dyb3VuZENvbG9yID0gcGFyYW1zLmNhbmNlbEJ1dHRvbkNvbG9yO1xuICAgIGFkZENsYXNzKGNhbmNlbEJ1dHRvbiwgc3dhbENsYXNzZXNbJ2RlZmF1bHQtb3V0bGluZSddKTtcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGJ1dHRvblxuICogQHBhcmFtIHsnY29uZmlybScgfCAnZGVueScgfCAnY2FuY2VsJ30gYnV0dG9uVHlwZVxuICogQHBhcmFtIHtTd2VldEFsZXJ0T3B0aW9uc30gcGFyYW1zXG4gKi9cbmZ1bmN0aW9uIHJlbmRlckJ1dHRvbihidXR0b24sIGJ1dHRvblR5cGUsIHBhcmFtcykge1xuICBjb25zdCBidXR0b25OYW1lID0gLyoqIEB0eXBlIHsnQ29uZmlybScgfCAnRGVueScgfCAnQ2FuY2VsJ30gKi9jYXBpdGFsaXplRmlyc3RMZXR0ZXIoYnV0dG9uVHlwZSk7XG4gIHRvZ2dsZShidXR0b24sIHBhcmFtc1tgc2hvdyR7YnV0dG9uTmFtZX1CdXR0b25gXSwgJ2lubGluZS1ibG9jaycpO1xuICBzZXRJbm5lckh0bWwoYnV0dG9uLCBwYXJhbXNbYCR7YnV0dG9uVHlwZX1CdXR0b25UZXh0YF0gfHwgJycpOyAvLyBTZXQgY2FwdGlvbiB0ZXh0XG4gIGJ1dHRvbi5zZXRBdHRyaWJ1dGUoJ2FyaWEtbGFiZWwnLCBwYXJhbXNbYCR7YnV0dG9uVHlwZX1CdXR0b25BcmlhTGFiZWxgXSB8fCAnJyk7IC8vIEFSSUEgbGFiZWxcblxuICAvLyBBZGQgYnV0dG9ucyBjdXN0b20gY2xhc3Nlc1xuICBidXR0b24uY2xhc3NOYW1lID0gc3dhbENsYXNzZXNbYnV0dG9uVHlwZV07XG4gIGFwcGx5Q3VzdG9tQ2xhc3MoYnV0dG9uLCBwYXJhbXMsIGAke2J1dHRvblR5cGV9QnV0dG9uYCk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtTd2VldEFsZXJ0fSBpbnN0YW5jZVxuICogQHBhcmFtIHtTd2VldEFsZXJ0T3B0aW9uc30gcGFyYW1zXG4gKi9cbmNvbnN0IHJlbmRlckNsb3NlQnV0dG9uID0gKGluc3RhbmNlLCBwYXJhbXMpID0+IHtcbiAgY29uc3QgY2xvc2VCdXR0b24gPSBnZXRDbG9zZUJ1dHRvbigpO1xuICBpZiAoIWNsb3NlQnV0dG9uKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHNldElubmVySHRtbChjbG9zZUJ1dHRvbiwgcGFyYW1zLmNsb3NlQnV0dG9uSHRtbCB8fCAnJyk7XG5cbiAgLy8gQ3VzdG9tIGNsYXNzXG4gIGFwcGx5Q3VzdG9tQ2xhc3MoY2xvc2VCdXR0b24sIHBhcmFtcywgJ2Nsb3NlQnV0dG9uJyk7XG4gIHRvZ2dsZShjbG9zZUJ1dHRvbiwgcGFyYW1zLnNob3dDbG9zZUJ1dHRvbik7XG4gIGNsb3NlQnV0dG9uLnNldEF0dHJpYnV0ZSgnYXJpYS1sYWJlbCcsIHBhcmFtcy5jbG9zZUJ1dHRvbkFyaWFMYWJlbCB8fCAnJyk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7U3dlZXRBbGVydH0gaW5zdGFuY2VcbiAqIEBwYXJhbSB7U3dlZXRBbGVydE9wdGlvbnN9IHBhcmFtc1xuICovXG5jb25zdCByZW5kZXJDb250YWluZXIgPSAoaW5zdGFuY2UsIHBhcmFtcykgPT4ge1xuICBjb25zdCBjb250YWluZXIgPSBnZXRDb250YWluZXIoKTtcbiAgaWYgKCFjb250YWluZXIpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaGFuZGxlQmFja2Ryb3BQYXJhbShjb250YWluZXIsIHBhcmFtcy5iYWNrZHJvcCk7XG4gIGhhbmRsZVBvc2l0aW9uUGFyYW0oY29udGFpbmVyLCBwYXJhbXMucG9zaXRpb24pO1xuICBoYW5kbGVHcm93UGFyYW0oY29udGFpbmVyLCBwYXJhbXMuZ3Jvdyk7XG5cbiAgLy8gQ3VzdG9tIGNsYXNzXG4gIGFwcGx5Q3VzdG9tQ2xhc3MoY29udGFpbmVyLCBwYXJhbXMsICdjb250YWluZXInKTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gY29udGFpbmVyXG4gKiBAcGFyYW0ge1N3ZWV0QWxlcnRPcHRpb25zWydiYWNrZHJvcCddfSBiYWNrZHJvcFxuICovXG5mdW5jdGlvbiBoYW5kbGVCYWNrZHJvcFBhcmFtKGNvbnRhaW5lciwgYmFja2Ryb3ApIHtcbiAgaWYgKHR5cGVvZiBiYWNrZHJvcCA9PT0gJ3N0cmluZycpIHtcbiAgICBjb250YWluZXIuc3R5bGUuYmFja2dyb3VuZCA9IGJhY2tkcm9wO1xuICB9IGVsc2UgaWYgKCFiYWNrZHJvcCkge1xuICAgIGFkZENsYXNzKFtkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsIGRvY3VtZW50LmJvZHldLCBzd2FsQ2xhc3Nlc1snbm8tYmFja2Ryb3AnXSk7XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBjb250YWluZXJcbiAqIEBwYXJhbSB7U3dlZXRBbGVydE9wdGlvbnNbJ3Bvc2l0aW9uJ119IHBvc2l0aW9uXG4gKi9cbmZ1bmN0aW9uIGhhbmRsZVBvc2l0aW9uUGFyYW0oY29udGFpbmVyLCBwb3NpdGlvbikge1xuICBpZiAoIXBvc2l0aW9uKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChwb3NpdGlvbiBpbiBzd2FsQ2xhc3Nlcykge1xuICAgIGFkZENsYXNzKGNvbnRhaW5lciwgc3dhbENsYXNzZXNbcG9zaXRpb25dKTtcbiAgfSBlbHNlIHtcbiAgICB3YXJuKCdUaGUgXCJwb3NpdGlvblwiIHBhcmFtZXRlciBpcyBub3QgdmFsaWQsIGRlZmF1bHRpbmcgdG8gXCJjZW50ZXJcIicpO1xuICAgIGFkZENsYXNzKGNvbnRhaW5lciwgc3dhbENsYXNzZXMuY2VudGVyKTtcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGNvbnRhaW5lclxuICogQHBhcmFtIHtTd2VldEFsZXJ0T3B0aW9uc1snZ3JvdyddfSBncm93XG4gKi9cbmZ1bmN0aW9uIGhhbmRsZUdyb3dQYXJhbShjb250YWluZXIsIGdyb3cpIHtcbiAgaWYgKCFncm93KSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGFkZENsYXNzKGNvbnRhaW5lciwgc3dhbENsYXNzZXNbYGdyb3ctJHtncm93fWBdKTtcbn1cblxuLyoqXG4gKiBUaGlzIG1vZHVsZSBjb250YWlucyBgV2Vha01hcGBzIGZvciBlYWNoIGVmZmVjdGl2ZWx5LVwicHJpdmF0ZSAgcHJvcGVydHlcIiB0aGF0IGEgYFN3YWxgIGhhcy5cbiAqIEZvciBleGFtcGxlLCB0byBzZXQgdGhlIHByaXZhdGUgcHJvcGVydHkgXCJmb29cIiBvZiBgdGhpc2AgdG8gXCJiYXJcIiwgeW91IGNhbiBgcHJpdmF0ZVByb3BzLmZvby5zZXQodGhpcywgJ2JhcicpYFxuICogVGhpcyBpcyB0aGUgYXBwcm9hY2ggdGhhdCBCYWJlbCB3aWxsIHByb2JhYmx5IHRha2UgdG8gaW1wbGVtZW50IHByaXZhdGUgbWV0aG9kcy9maWVsZHNcbiAqICAgaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtcHJpdmF0ZS1tZXRob2RzXG4gKiAgIGh0dHBzOi8vZ2l0aHViLmNvbS9iYWJlbC9iYWJlbC9wdWxsLzc1NTVcbiAqIE9uY2Ugd2UgaGF2ZSB0aGUgY2hhbmdlcyBmcm9tIHRoYXQgUFIgaW4gQmFiZWwsIGFuZCBvdXIgY29yZSBjbGFzcyBmaXRzIHJlYXNvbmFibGUgaW4gKm9uZSBtb2R1bGUqXG4gKiAgIHRoZW4gd2UgY2FuIHVzZSB0aGF0IGxhbmd1YWdlIGZlYXR1cmUuXG4gKi9cblxudmFyIHByaXZhdGVQcm9wcyA9IHtcbiAgaW5uZXJQYXJhbXM6IG5ldyBXZWFrTWFwKCksXG4gIGRvbUNhY2hlOiBuZXcgV2Vha01hcCgpXG59O1xuXG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vLi4vLi4vLi4vc3dlZXRhbGVydDIuZC50c1wiLz5cblxuXG4vKiogQHR5cGUge0lucHV0Q2xhc3NbXX0gKi9cbmNvbnN0IGlucHV0Q2xhc3NlcyA9IFsnaW5wdXQnLCAnZmlsZScsICdyYW5nZScsICdzZWxlY3QnLCAncmFkaW8nLCAnY2hlY2tib3gnLCAndGV4dGFyZWEnXTtcblxuLyoqXG4gKiBAcGFyYW0ge1N3ZWV0QWxlcnR9IGluc3RhbmNlXG4gKiBAcGFyYW0ge1N3ZWV0QWxlcnRPcHRpb25zfSBwYXJhbXNcbiAqL1xuY29uc3QgcmVuZGVySW5wdXQgPSAoaW5zdGFuY2UsIHBhcmFtcykgPT4ge1xuICBjb25zdCBwb3B1cCA9IGdldFBvcHVwKCk7XG4gIGlmICghcG9wdXApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgaW5uZXJQYXJhbXMgPSBwcml2YXRlUHJvcHMuaW5uZXJQYXJhbXMuZ2V0KGluc3RhbmNlKTtcbiAgY29uc3QgcmVyZW5kZXIgPSAhaW5uZXJQYXJhbXMgfHwgcGFyYW1zLmlucHV0ICE9PSBpbm5lclBhcmFtcy5pbnB1dDtcbiAgaW5wdXRDbGFzc2VzLmZvckVhY2goaW5wdXRDbGFzcyA9PiB7XG4gICAgY29uc3QgaW5wdXRDb250YWluZXIgPSBnZXREaXJlY3RDaGlsZEJ5Q2xhc3MocG9wdXAsIHN3YWxDbGFzc2VzW2lucHV0Q2xhc3NdKTtcbiAgICBpZiAoIWlucHV0Q29udGFpbmVyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gc2V0IGF0dHJpYnV0ZXNcbiAgICBzZXRBdHRyaWJ1dGVzKGlucHV0Q2xhc3MsIHBhcmFtcy5pbnB1dEF0dHJpYnV0ZXMpO1xuXG4gICAgLy8gc2V0IGNsYXNzXG4gICAgaW5wdXRDb250YWluZXIuY2xhc3NOYW1lID0gc3dhbENsYXNzZXNbaW5wdXRDbGFzc107XG4gICAgaWYgKHJlcmVuZGVyKSB7XG4gICAgICBoaWRlKGlucHV0Q29udGFpbmVyKTtcbiAgICB9XG4gIH0pO1xuICBpZiAocGFyYW1zLmlucHV0KSB7XG4gICAgaWYgKHJlcmVuZGVyKSB7XG4gICAgICBzaG93SW5wdXQocGFyYW1zKTtcbiAgICB9XG4gICAgLy8gc2V0IGN1c3RvbSBjbGFzc1xuICAgIHNldEN1c3RvbUNsYXNzKHBhcmFtcyk7XG4gIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtTd2VldEFsZXJ0T3B0aW9uc30gcGFyYW1zXG4gKi9cbmNvbnN0IHNob3dJbnB1dCA9IHBhcmFtcyA9PiB7XG4gIGlmICghcGFyYW1zLmlucHV0KSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICghcmVuZGVySW5wdXRUeXBlW3BhcmFtcy5pbnB1dF0pIHtcbiAgICBlcnJvcihgVW5leHBlY3RlZCB0eXBlIG9mIGlucHV0ISBFeHBlY3RlZCAke09iamVjdC5rZXlzKHJlbmRlcklucHV0VHlwZSkuam9pbignIHwgJyl9LCBnb3QgXCIke3BhcmFtcy5pbnB1dH1cImApO1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBpbnB1dENvbnRhaW5lciA9IGdldElucHV0Q29udGFpbmVyKHBhcmFtcy5pbnB1dCk7XG4gIGlmICghaW5wdXRDb250YWluZXIpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgaW5wdXQgPSByZW5kZXJJbnB1dFR5cGVbcGFyYW1zLmlucHV0XShpbnB1dENvbnRhaW5lciwgcGFyYW1zKTtcbiAgc2hvdyhpbnB1dENvbnRhaW5lcik7XG5cbiAgLy8gaW5wdXQgYXV0b2ZvY3VzXG4gIGlmIChwYXJhbXMuaW5wdXRBdXRvRm9jdXMpIHtcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGZvY3VzSW5wdXQoaW5wdXQpO1xuICAgIH0pO1xuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7SFRNTElucHV0RWxlbWVudH0gaW5wdXRcbiAqL1xuY29uc3QgcmVtb3ZlQXR0cmlidXRlcyA9IGlucHV0ID0+IHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnB1dC5hdHRyaWJ1dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgYXR0ck5hbWUgPSBpbnB1dC5hdHRyaWJ1dGVzW2ldLm5hbWU7XG4gICAgaWYgKCFbJ2lkJywgJ3R5cGUnLCAndmFsdWUnLCAnc3R5bGUnXS5pbmNsdWRlcyhhdHRyTmFtZSkpIHtcbiAgICAgIGlucHV0LnJlbW92ZUF0dHJpYnV0ZShhdHRyTmFtZSk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7SW5wdXRDbGFzc30gaW5wdXRDbGFzc1xuICogQHBhcmFtIHtTd2VldEFsZXJ0T3B0aW9uc1snaW5wdXRBdHRyaWJ1dGVzJ119IGlucHV0QXR0cmlidXRlc1xuICovXG5jb25zdCBzZXRBdHRyaWJ1dGVzID0gKGlucHV0Q2xhc3MsIGlucHV0QXR0cmlidXRlcykgPT4ge1xuICBjb25zdCBwb3B1cCA9IGdldFBvcHVwKCk7XG4gIGlmICghcG9wdXApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgaW5wdXQgPSBnZXRJbnB1dCQxKHBvcHVwLCBpbnB1dENsYXNzKTtcbiAgaWYgKCFpbnB1dCkge1xuICAgIHJldHVybjtcbiAgfVxuICByZW1vdmVBdHRyaWJ1dGVzKGlucHV0KTtcbiAgZm9yIChjb25zdCBhdHRyIGluIGlucHV0QXR0cmlidXRlcykge1xuICAgIGlucHV0LnNldEF0dHJpYnV0ZShhdHRyLCBpbnB1dEF0dHJpYnV0ZXNbYXR0cl0pO1xuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7U3dlZXRBbGVydE9wdGlvbnN9IHBhcmFtc1xuICovXG5jb25zdCBzZXRDdXN0b21DbGFzcyA9IHBhcmFtcyA9PiB7XG4gIGlmICghcGFyYW1zLmlucHV0KSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGlucHV0Q29udGFpbmVyID0gZ2V0SW5wdXRDb250YWluZXIocGFyYW1zLmlucHV0KTtcbiAgaWYgKGlucHV0Q29udGFpbmVyKSB7XG4gICAgYXBwbHlDdXN0b21DbGFzcyhpbnB1dENvbnRhaW5lciwgcGFyYW1zLCAnaW5wdXQnKTtcbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge0hUTUxJbnB1dEVsZW1lbnQgfCBIVE1MVGV4dEFyZWFFbGVtZW50fSBpbnB1dFxuICogQHBhcmFtIHtTd2VldEFsZXJ0T3B0aW9uc30gcGFyYW1zXG4gKi9cbmNvbnN0IHNldElucHV0UGxhY2Vob2xkZXIgPSAoaW5wdXQsIHBhcmFtcykgPT4ge1xuICBpZiAoIWlucHV0LnBsYWNlaG9sZGVyICYmIHBhcmFtcy5pbnB1dFBsYWNlaG9sZGVyKSB7XG4gICAgaW5wdXQucGxhY2Vob2xkZXIgPSBwYXJhbXMuaW5wdXRQbGFjZWhvbGRlcjtcbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge0lucHV0fSBpbnB1dFxuICogQHBhcmFtIHtJbnB1dH0gcHJlcGVuZFRvXG4gKiBAcGFyYW0ge1N3ZWV0QWxlcnRPcHRpb25zfSBwYXJhbXNcbiAqL1xuY29uc3Qgc2V0SW5wdXRMYWJlbCA9IChpbnB1dCwgcHJlcGVuZFRvLCBwYXJhbXMpID0+IHtcbiAgaWYgKHBhcmFtcy5pbnB1dExhYmVsKSB7XG4gICAgY29uc3QgbGFiZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsYWJlbCcpO1xuICAgIGNvbnN0IGxhYmVsQ2xhc3MgPSBzd2FsQ2xhc3Nlc1snaW5wdXQtbGFiZWwnXTtcbiAgICBsYWJlbC5zZXRBdHRyaWJ1dGUoJ2ZvcicsIGlucHV0LmlkKTtcbiAgICBsYWJlbC5jbGFzc05hbWUgPSBsYWJlbENsYXNzO1xuICAgIGlmICh0eXBlb2YgcGFyYW1zLmN1c3RvbUNsYXNzID09PSAnb2JqZWN0Jykge1xuICAgICAgYWRkQ2xhc3MobGFiZWwsIHBhcmFtcy5jdXN0b21DbGFzcy5pbnB1dExhYmVsKTtcbiAgICB9XG4gICAgbGFiZWwuaW5uZXJUZXh0ID0gcGFyYW1zLmlucHV0TGFiZWw7XG4gICAgcHJlcGVuZFRvLmluc2VydEFkamFjZW50RWxlbWVudCgnYmVmb3JlYmVnaW4nLCBsYWJlbCk7XG4gIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtTd2VldEFsZXJ0SW5wdXR9IGlucHV0VHlwZVxuICogQHJldHVybnMge0hUTUxFbGVtZW50IHwgdW5kZWZpbmVkfVxuICovXG5jb25zdCBnZXRJbnB1dENvbnRhaW5lciA9IGlucHV0VHlwZSA9PiB7XG4gIGNvbnN0IHBvcHVwID0gZ2V0UG9wdXAoKTtcbiAgaWYgKCFwb3B1cCkge1xuICAgIHJldHVybjtcbiAgfVxuICByZXR1cm4gZ2V0RGlyZWN0Q2hpbGRCeUNsYXNzKHBvcHVwLCBzd2FsQ2xhc3Nlc1soLyoqIEB0eXBlIHtTd2FsQ2xhc3N9ICovaW5wdXRUeXBlKV0gfHwgc3dhbENsYXNzZXMuaW5wdXQpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0hUTUxJbnB1dEVsZW1lbnQgfCBIVE1MT3V0cHV0RWxlbWVudCB8IEhUTUxUZXh0QXJlYUVsZW1lbnR9IGlucHV0XG4gKiBAcGFyYW0ge1N3ZWV0QWxlcnRPcHRpb25zWydpbnB1dFZhbHVlJ119IGlucHV0VmFsdWVcbiAqL1xuY29uc3QgY2hlY2tBbmRTZXRJbnB1dFZhbHVlID0gKGlucHV0LCBpbnB1dFZhbHVlKSA9PiB7XG4gIGlmIChbJ3N0cmluZycsICdudW1iZXInXS5pbmNsdWRlcyh0eXBlb2YgaW5wdXRWYWx1ZSkpIHtcbiAgICBpbnB1dC52YWx1ZSA9IGAke2lucHV0VmFsdWV9YDtcbiAgfSBlbHNlIGlmICghaXNQcm9taXNlKGlucHV0VmFsdWUpKSB7XG4gICAgd2FybihgVW5leHBlY3RlZCB0eXBlIG9mIGlucHV0VmFsdWUhIEV4cGVjdGVkIFwic3RyaW5nXCIsIFwibnVtYmVyXCIgb3IgXCJQcm9taXNlXCIsIGdvdCBcIiR7dHlwZW9mIGlucHV0VmFsdWV9XCJgKTtcbiAgfVxufTtcblxuLyoqIEB0eXBlIHtSZWNvcmQ8U3dlZXRBbGVydElucHV0LCAoaW5wdXQ6IElucHV0IHwgSFRNTEVsZW1lbnQsIHBhcmFtczogU3dlZXRBbGVydE9wdGlvbnMpID0+IElucHV0Pn0gKi9cbmNvbnN0IHJlbmRlcklucHV0VHlwZSA9IHt9O1xuXG4vKipcbiAqIEBwYXJhbSB7SFRNTElucHV0RWxlbWVudH0gaW5wdXRcbiAqIEBwYXJhbSB7U3dlZXRBbGVydE9wdGlvbnN9IHBhcmFtc1xuICogQHJldHVybnMge0hUTUxJbnB1dEVsZW1lbnR9XG4gKi9cbnJlbmRlcklucHV0VHlwZS50ZXh0ID0gcmVuZGVySW5wdXRUeXBlLmVtYWlsID0gcmVuZGVySW5wdXRUeXBlLnBhc3N3b3JkID0gcmVuZGVySW5wdXRUeXBlLm51bWJlciA9IHJlbmRlcklucHV0VHlwZS50ZWwgPSByZW5kZXJJbnB1dFR5cGUudXJsID0gcmVuZGVySW5wdXRUeXBlLnNlYXJjaCA9IHJlbmRlcklucHV0VHlwZS5kYXRlID0gcmVuZGVySW5wdXRUeXBlWydkYXRldGltZS1sb2NhbCddID0gcmVuZGVySW5wdXRUeXBlLnRpbWUgPSByZW5kZXJJbnB1dFR5cGUud2VlayA9IHJlbmRlcklucHV0VHlwZS5tb250aCA9IC8qKiBAdHlwZSB7KGlucHV0OiBJbnB1dCB8IEhUTUxFbGVtZW50LCBwYXJhbXM6IFN3ZWV0QWxlcnRPcHRpb25zKSA9PiBJbnB1dH0gKi9cbihpbnB1dCwgcGFyYW1zKSA9PiB7XG4gIGNoZWNrQW5kU2V0SW5wdXRWYWx1ZShpbnB1dCwgcGFyYW1zLmlucHV0VmFsdWUpO1xuICBzZXRJbnB1dExhYmVsKGlucHV0LCBpbnB1dCwgcGFyYW1zKTtcbiAgc2V0SW5wdXRQbGFjZWhvbGRlcihpbnB1dCwgcGFyYW1zKTtcbiAgaW5wdXQudHlwZSA9IHBhcmFtcy5pbnB1dDtcbiAgcmV0dXJuIGlucHV0O1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0hUTUxJbnB1dEVsZW1lbnR9IGlucHV0XG4gKiBAcGFyYW0ge1N3ZWV0QWxlcnRPcHRpb25zfSBwYXJhbXNcbiAqIEByZXR1cm5zIHtIVE1MSW5wdXRFbGVtZW50fVxuICovXG5yZW5kZXJJbnB1dFR5cGUuZmlsZSA9IChpbnB1dCwgcGFyYW1zKSA9PiB7XG4gIHNldElucHV0TGFiZWwoaW5wdXQsIGlucHV0LCBwYXJhbXMpO1xuICBzZXRJbnB1dFBsYWNlaG9sZGVyKGlucHV0LCBwYXJhbXMpO1xuICByZXR1cm4gaW5wdXQ7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7SFRNTElucHV0RWxlbWVudH0gcmFuZ2VcbiAqIEBwYXJhbSB7U3dlZXRBbGVydE9wdGlvbnN9IHBhcmFtc1xuICogQHJldHVybnMge0hUTUxJbnB1dEVsZW1lbnR9XG4gKi9cbnJlbmRlcklucHV0VHlwZS5yYW5nZSA9IChyYW5nZSwgcGFyYW1zKSA9PiB7XG4gIGNvbnN0IHJhbmdlSW5wdXQgPSByYW5nZS5xdWVyeVNlbGVjdG9yKCdpbnB1dCcpO1xuICBjb25zdCByYW5nZU91dHB1dCA9IHJhbmdlLnF1ZXJ5U2VsZWN0b3IoJ291dHB1dCcpO1xuICBjaGVja0FuZFNldElucHV0VmFsdWUocmFuZ2VJbnB1dCwgcGFyYW1zLmlucHV0VmFsdWUpO1xuICByYW5nZUlucHV0LnR5cGUgPSBwYXJhbXMuaW5wdXQ7XG4gIGNoZWNrQW5kU2V0SW5wdXRWYWx1ZShyYW5nZU91dHB1dCwgcGFyYW1zLmlucHV0VmFsdWUpO1xuICBzZXRJbnB1dExhYmVsKHJhbmdlSW5wdXQsIHJhbmdlLCBwYXJhbXMpO1xuICByZXR1cm4gcmFuZ2U7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7SFRNTFNlbGVjdEVsZW1lbnR9IHNlbGVjdFxuICogQHBhcmFtIHtTd2VldEFsZXJ0T3B0aW9uc30gcGFyYW1zXG4gKiBAcmV0dXJucyB7SFRNTFNlbGVjdEVsZW1lbnR9XG4gKi9cbnJlbmRlcklucHV0VHlwZS5zZWxlY3QgPSAoc2VsZWN0LCBwYXJhbXMpID0+IHtcbiAgc2VsZWN0LnRleHRDb250ZW50ID0gJyc7XG4gIGlmIChwYXJhbXMuaW5wdXRQbGFjZWhvbGRlcikge1xuICAgIGNvbnN0IHBsYWNlaG9sZGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnb3B0aW9uJyk7XG4gICAgc2V0SW5uZXJIdG1sKHBsYWNlaG9sZGVyLCBwYXJhbXMuaW5wdXRQbGFjZWhvbGRlcik7XG4gICAgcGxhY2Vob2xkZXIudmFsdWUgPSAnJztcbiAgICBwbGFjZWhvbGRlci5kaXNhYmxlZCA9IHRydWU7XG4gICAgcGxhY2Vob2xkZXIuc2VsZWN0ZWQgPSB0cnVlO1xuICAgIHNlbGVjdC5hcHBlbmRDaGlsZChwbGFjZWhvbGRlcik7XG4gIH1cbiAgc2V0SW5wdXRMYWJlbChzZWxlY3QsIHNlbGVjdCwgcGFyYW1zKTtcbiAgcmV0dXJuIHNlbGVjdDtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtIVE1MSW5wdXRFbGVtZW50fSByYWRpb1xuICogQHJldHVybnMge0hUTUxJbnB1dEVsZW1lbnR9XG4gKi9cbnJlbmRlcklucHV0VHlwZS5yYWRpbyA9IHJhZGlvID0+IHtcbiAgcmFkaW8udGV4dENvbnRlbnQgPSAnJztcbiAgcmV0dXJuIHJhZGlvO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0hUTUxMYWJlbEVsZW1lbnR9IGNoZWNrYm94Q29udGFpbmVyXG4gKiBAcGFyYW0ge1N3ZWV0QWxlcnRPcHRpb25zfSBwYXJhbXNcbiAqIEByZXR1cm5zIHtIVE1MSW5wdXRFbGVtZW50fVxuICovXG5yZW5kZXJJbnB1dFR5cGUuY2hlY2tib3ggPSAoY2hlY2tib3hDb250YWluZXIsIHBhcmFtcykgPT4ge1xuICBjb25zdCBjaGVja2JveCA9IGdldElucHV0JDEoZ2V0UG9wdXAoKSwgJ2NoZWNrYm94Jyk7XG4gIGNoZWNrYm94LnZhbHVlID0gJzEnO1xuICBjaGVja2JveC5jaGVja2VkID0gQm9vbGVhbihwYXJhbXMuaW5wdXRWYWx1ZSk7XG4gIGNvbnN0IGxhYmVsID0gY2hlY2tib3hDb250YWluZXIucXVlcnlTZWxlY3Rvcignc3BhbicpO1xuICBzZXRJbm5lckh0bWwobGFiZWwsIHBhcmFtcy5pbnB1dFBsYWNlaG9sZGVyIHx8IHBhcmFtcy5pbnB1dExhYmVsKTtcbiAgcmV0dXJuIGNoZWNrYm94O1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0hUTUxUZXh0QXJlYUVsZW1lbnR9IHRleHRhcmVhXG4gKiBAcGFyYW0ge1N3ZWV0QWxlcnRPcHRpb25zfSBwYXJhbXNcbiAqIEByZXR1cm5zIHtIVE1MVGV4dEFyZWFFbGVtZW50fVxuICovXG5yZW5kZXJJbnB1dFR5cGUudGV4dGFyZWEgPSAodGV4dGFyZWEsIHBhcmFtcykgPT4ge1xuICBjaGVja0FuZFNldElucHV0VmFsdWUodGV4dGFyZWEsIHBhcmFtcy5pbnB1dFZhbHVlKTtcbiAgc2V0SW5wdXRQbGFjZWhvbGRlcih0ZXh0YXJlYSwgcGFyYW1zKTtcbiAgc2V0SW5wdXRMYWJlbCh0ZXh0YXJlYSwgdGV4dGFyZWEsIHBhcmFtcyk7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAqL1xuICBjb25zdCBnZXRNYXJnaW4gPSBlbCA9PiBwYXJzZUludCh3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbCkubWFyZ2luTGVmdCkgKyBwYXJzZUludCh3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbCkubWFyZ2luUmlnaHQpO1xuXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9zd2VldGFsZXJ0Mi9zd2VldGFsZXJ0Mi9pc3N1ZXMvMjI5MVxuICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vc3dlZXRhbGVydDIvc3dlZXRhbGVydDIvaXNzdWVzLzE2OTlcbiAgICBpZiAoJ011dGF0aW9uT2JzZXJ2ZXInIGluIHdpbmRvdykge1xuICAgICAgY29uc3QgaW5pdGlhbFBvcHVwV2lkdGggPSBwYXJzZUludCh3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShnZXRQb3B1cCgpKS53aWR0aCk7XG4gICAgICBjb25zdCB0ZXh0YXJlYVJlc2l6ZUhhbmRsZXIgPSAoKSA9PiB7XG4gICAgICAgIC8vIGNoZWNrIGlmIHRleGFyZWEgaXMgc3RpbGwgaW4gZG9jdW1lbnQgKGkuZS4gcG9wdXAgd2Fzbid0IGNsb3NlZCBpbiB0aGUgbWVhbnRpbWUpXG4gICAgICAgIGlmICghZG9jdW1lbnQuYm9keS5jb250YWlucyh0ZXh0YXJlYSkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGV4dGFyZWFXaWR0aCA9IHRleHRhcmVhLm9mZnNldFdpZHRoICsgZ2V0TWFyZ2luKHRleHRhcmVhKTtcbiAgICAgICAgaWYgKHRleHRhcmVhV2lkdGggPiBpbml0aWFsUG9wdXBXaWR0aCkge1xuICAgICAgICAgIGdldFBvcHVwKCkuc3R5bGUud2lkdGggPSBgJHt0ZXh0YXJlYVdpZHRofXB4YDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhcHBseU51bWVyaWNhbFN0eWxlKGdldFBvcHVwKCksICd3aWR0aCcsIHBhcmFtcy53aWR0aCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBuZXcgTXV0YXRpb25PYnNlcnZlcih0ZXh0YXJlYVJlc2l6ZUhhbmRsZXIpLm9ic2VydmUodGV4dGFyZWEsIHtcbiAgICAgICAgYXR0cmlidXRlczogdHJ1ZSxcbiAgICAgICAgYXR0cmlidXRlRmlsdGVyOiBbJ3N0eWxlJ11cbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiB0ZXh0YXJlYTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtTd2VldEFsZXJ0fSBpbnN0YW5jZVxuICogQHBhcmFtIHtTd2VldEFsZXJ0T3B0aW9uc30gcGFyYW1zXG4gKi9cbmNvbnN0IHJlbmRlckNvbnRlbnQgPSAoaW5zdGFuY2UsIHBhcmFtcykgPT4ge1xuICBjb25zdCBodG1sQ29udGFpbmVyID0gZ2V0SHRtbENvbnRhaW5lcigpO1xuICBpZiAoIWh0bWxDb250YWluZXIpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgc2hvd1doZW5Jbm5lckh0bWxQcmVzZW50KGh0bWxDb250YWluZXIpO1xuICBhcHBseUN1c3RvbUNsYXNzKGh0bWxDb250YWluZXIsIHBhcmFtcywgJ2h0bWxDb250YWluZXInKTtcblxuICAvLyBDb250ZW50IGFzIEhUTUxcbiAgaWYgKHBhcmFtcy5odG1sKSB7XG4gICAgcGFyc2VIdG1sVG9Db250YWluZXIocGFyYW1zLmh0bWwsIGh0bWxDb250YWluZXIpO1xuICAgIHNob3coaHRtbENvbnRhaW5lciwgJ2Jsb2NrJyk7XG4gIH1cblxuICAvLyBDb250ZW50IGFzIHBsYWluIHRleHRcbiAgZWxzZSBpZiAocGFyYW1zLnRleHQpIHtcbiAgICBodG1sQ29udGFpbmVyLnRleHRDb250ZW50ID0gcGFyYW1zLnRleHQ7XG4gICAgc2hvdyhodG1sQ29udGFpbmVyLCAnYmxvY2snKTtcbiAgfVxuXG4gIC8vIE5vIGNvbnRlbnRcbiAgZWxzZSB7XG4gICAgaGlkZShodG1sQ29udGFpbmVyKTtcbiAgfVxuICByZW5kZXJJbnB1dChpbnN0YW5jZSwgcGFyYW1zKTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtTd2VldEFsZXJ0fSBpbnN0YW5jZVxuICogQHBhcmFtIHtTd2VldEFsZXJ0T3B0aW9uc30gcGFyYW1zXG4gKi9cbmNvbnN0IHJlbmRlckZvb3RlciA9IChpbnN0YW5jZSwgcGFyYW1zKSA9PiB7XG4gIGNvbnN0IGZvb3RlciA9IGdldEZvb3RlcigpO1xuICBpZiAoIWZvb3Rlcikge1xuICAgIHJldHVybjtcbiAgfVxuICBzaG93V2hlbklubmVySHRtbFByZXNlbnQoZm9vdGVyKTtcbiAgdG9nZ2xlKGZvb3RlciwgcGFyYW1zLmZvb3RlciwgJ2Jsb2NrJyk7XG4gIGlmIChwYXJhbXMuZm9vdGVyKSB7XG4gICAgcGFyc2VIdG1sVG9Db250YWluZXIocGFyYW1zLmZvb3RlciwgZm9vdGVyKTtcbiAgfVxuXG4gIC8vIEN1c3RvbSBjbGFzc1xuICBhcHBseUN1c3RvbUNsYXNzKGZvb3RlciwgcGFyYW1zLCAnZm9vdGVyJyk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7U3dlZXRBbGVydH0gaW5zdGFuY2VcbiAqIEBwYXJhbSB7U3dlZXRBbGVydE9wdGlvbnN9IHBhcmFtc1xuICovXG5jb25zdCByZW5kZXJJY29uID0gKGluc3RhbmNlLCBwYXJhbXMpID0+IHtcbiAgY29uc3QgaW5uZXJQYXJhbXMgPSBwcml2YXRlUHJvcHMuaW5uZXJQYXJhbXMuZ2V0KGluc3RhbmNlKTtcbiAgY29uc3QgaWNvbiA9IGdldEljb24oKTtcbiAgaWYgKCFpY29uKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gaWYgdGhlIGdpdmVuIGljb24gYWxyZWFkeSByZW5kZXJlZCwgYXBwbHkgdGhlIHN0eWxpbmcgd2l0aG91dCByZS1yZW5kZXJpbmcgdGhlIGljb25cbiAgaWYgKGlubmVyUGFyYW1zICYmIHBhcmFtcy5pY29uID09PSBpbm5lclBhcmFtcy5pY29uKSB7XG4gICAgLy8gQ3VzdG9tIG9yIGRlZmF1bHQgY29udGVudFxuICAgIHNldENvbnRlbnQoaWNvbiwgcGFyYW1zKTtcbiAgICBhcHBseVN0eWxlcyhpY29uLCBwYXJhbXMpO1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoIXBhcmFtcy5pY29uICYmICFwYXJhbXMuaWNvbkh0bWwpIHtcbiAgICBoaWRlKGljb24pO1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAocGFyYW1zLmljb24gJiYgT2JqZWN0LmtleXMoaWNvblR5cGVzKS5pbmRleE9mKHBhcmFtcy5pY29uKSA9PT0gLTEpIHtcbiAgICBlcnJvcihgVW5rbm93biBpY29uISBFeHBlY3RlZCBcInN1Y2Nlc3NcIiwgXCJlcnJvclwiLCBcIndhcm5pbmdcIiwgXCJpbmZvXCIgb3IgXCJxdWVzdGlvblwiLCBnb3QgXCIke3BhcmFtcy5pY29ufVwiYCk7XG4gICAgaGlkZShpY29uKTtcbiAgICByZXR1cm47XG4gIH1cbiAgc2hvdyhpY29uKTtcblxuICAvLyBDdXN0b20gb3IgZGVmYXVsdCBjb250ZW50XG4gIHNldENvbnRlbnQoaWNvbiwgcGFyYW1zKTtcbiAgYXBwbHlTdHlsZXMoaWNvbiwgcGFyYW1zKTtcblxuICAvLyBBbmltYXRlIGljb25cbiAgYWRkQ2xhc3MoaWNvbiwgcGFyYW1zLnNob3dDbGFzcyAmJiBwYXJhbXMuc2hvd0NsYXNzLmljb24pO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBpY29uXG4gKiBAcGFyYW0ge1N3ZWV0QWxlcnRPcHRpb25zfSBwYXJhbXNcbiAqL1xuY29uc3QgYXBwbHlTdHlsZXMgPSAoaWNvbiwgcGFyYW1zKSA9PiB7XG4gIGZvciAoY29uc3QgW2ljb25UeXBlLCBpY29uQ2xhc3NOYW1lXSBvZiBPYmplY3QuZW50cmllcyhpY29uVHlwZXMpKSB7XG4gICAgaWYgKHBhcmFtcy5pY29uICE9PSBpY29uVHlwZSkge1xuICAgICAgcmVtb3ZlQ2xhc3MoaWNvbiwgaWNvbkNsYXNzTmFtZSk7XG4gICAgfVxuICB9XG4gIGFkZENsYXNzKGljb24sIHBhcmFtcy5pY29uICYmIGljb25UeXBlc1twYXJhbXMuaWNvbl0pO1xuXG4gIC8vIEljb24gY29sb3JcbiAgc2V0Q29sb3IoaWNvbiwgcGFyYW1zKTtcblxuICAvLyBTdWNjZXNzIGljb24gYmFja2dyb3VuZCBjb2xvclxuICBhZGp1c3RTdWNjZXNzSWNvbkJhY2tncm91bmRDb2xvcigpO1xuXG4gIC8vIEN1c3RvbSBjbGFzc1xuICBhcHBseUN1c3RvbUNsYXNzKGljb24sIHBhcmFtcywgJ2ljb24nKTtcbn07XG5cbi8vIEFkanVzdCBzdWNjZXNzIGljb24gYmFja2dyb3VuZCBjb2xvciB0byBtYXRjaCB0aGUgcG9wdXAgYmFja2dyb3VuZCBjb2xvclxuY29uc3QgYWRqdXN0U3VjY2Vzc0ljb25CYWNrZ3JvdW5kQ29sb3IgPSAoKSA9PiB7XG4gIGNvbnN0IHBvcHVwID0gZ2V0UG9wdXAoKTtcbiAgaWYgKCFwb3B1cCkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBwb3B1cEJhY2tncm91bmRDb2xvciA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHBvcHVwKS5nZXRQcm9wZXJ0eVZhbHVlKCdiYWNrZ3JvdW5kLWNvbG9yJyk7XG4gIC8qKiBAdHlwZSB7Tm9kZUxpc3RPZjxIVE1MRWxlbWVudD59ICovXG4gIGNvbnN0IHN1Y2Nlc3NJY29uUGFydHMgPSBwb3B1cC5xdWVyeVNlbGVjdG9yQWxsKCdbY2xhc3NePXN3YWwyLXN1Y2Nlc3MtY2lyY3VsYXItbGluZV0sIC5zd2FsMi1zdWNjZXNzLWZpeCcpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHN1Y2Nlc3NJY29uUGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICBzdWNjZXNzSWNvblBhcnRzW2ldLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IHBvcHVwQmFja2dyb3VuZENvbG9yO1xuICB9XG59O1xuY29uc3Qgc3VjY2Vzc0ljb25IdG1sID0gYFxuICA8ZGl2IGNsYXNzPVwic3dhbDItc3VjY2Vzcy1jaXJjdWxhci1saW5lLWxlZnRcIj48L2Rpdj5cbiAgPHNwYW4gY2xhc3M9XCJzd2FsMi1zdWNjZXNzLWxpbmUtdGlwXCI+PC9zcGFuPiA8c3BhbiBjbGFzcz1cInN3YWwyLXN1Y2Nlc3MtbGluZS1sb25nXCI+PC9zcGFuPlxuICA8ZGl2IGNsYXNzPVwic3dhbDItc3VjY2Vzcy1yaW5nXCI+PC9kaXY+IDxkaXYgY2xhc3M9XCJzd2FsMi1zdWNjZXNzLWZpeFwiPjwvZGl2PlxuICA8ZGl2IGNsYXNzPVwic3dhbDItc3VjY2Vzcy1jaXJjdWxhci1saW5lLXJpZ2h0XCI+PC9kaXY+XG5gO1xuY29uc3QgZXJyb3JJY29uSHRtbCA9IGBcbiAgPHNwYW4gY2xhc3M9XCJzd2FsMi14LW1hcmtcIj5cbiAgICA8c3BhbiBjbGFzcz1cInN3YWwyLXgtbWFyay1saW5lLWxlZnRcIj48L3NwYW4+XG4gICAgPHNwYW4gY2xhc3M9XCJzd2FsMi14LW1hcmstbGluZS1yaWdodFwiPjwvc3Bhbj5cbiAgPC9zcGFuPlxuYDtcblxuLyoqXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBpY29uXG4gKiBAcGFyYW0ge1N3ZWV0QWxlcnRPcHRpb25zfSBwYXJhbXNcbiAqL1xuY29uc3Qgc2V0Q29udGVudCA9IChpY29uLCBwYXJhbXMpID0+IHtcbiAgaWYgKCFwYXJhbXMuaWNvbiAmJiAhcGFyYW1zLmljb25IdG1sKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGxldCBvbGRDb250ZW50ID0gaWNvbi5pbm5lckhUTUw7XG4gIGxldCBuZXdDb250ZW50ID0gJyc7XG4gIGlmIChwYXJhbXMuaWNvbkh0bWwpIHtcbiAgICBuZXdDb250ZW50ID0gaWNvbkNvbnRlbnQocGFyYW1zLmljb25IdG1sKTtcbiAgfSBlbHNlIGlmIChwYXJhbXMuaWNvbiA9PT0gJ3N1Y2Nlc3MnKSB7XG4gICAgbmV3Q29udGVudCA9IHN1Y2Nlc3NJY29uSHRtbDtcbiAgICBvbGRDb250ZW50ID0gb2xkQ29udGVudC5yZXBsYWNlKC8gc3R5bGU9XCIuKj9cIi9nLCAnJyk7IC8vIHVuZG8gYWRqdXN0U3VjY2Vzc0ljb25CYWNrZ3JvdW5kQ29sb3IoKVxuICB9IGVsc2UgaWYgKHBhcmFtcy5pY29uID09PSAnZXJyb3InKSB7XG4gICAgbmV3Q29udGVudCA9IGVycm9ySWNvbkh0bWw7XG4gIH0gZWxzZSBpZiAocGFyYW1zLmljb24pIHtcbiAgICBjb25zdCBkZWZhdWx0SWNvbkh0bWwgPSB7XG4gICAgICBxdWVzdGlvbjogJz8nLFxuICAgICAgd2FybmluZzogJyEnLFxuICAgICAgaW5mbzogJ2knXG4gICAgfTtcbiAgICBuZXdDb250ZW50ID0gaWNvbkNvbnRlbnQoZGVmYXVsdEljb25IdG1sW3BhcmFtcy5pY29uXSk7XG4gIH1cbiAgaWYgKG9sZENvbnRlbnQudHJpbSgpICE9PSBuZXdDb250ZW50LnRyaW0oKSkge1xuICAgIHNldElubmVySHRtbChpY29uLCBuZXdDb250ZW50KTtcbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBpY29uXG4gKiBAcGFyYW0ge1N3ZWV0QWxlcnRPcHRpb25zfSBwYXJhbXNcbiAqL1xuY29uc3Qgc2V0Q29sb3IgPSAoaWNvbiwgcGFyYW1zKSA9PiB7XG4gIGlmICghcGFyYW1zLmljb25Db2xvcikge1xuICAgIHJldHVybjtcbiAgfVxuICBpY29uLnN0eWxlLmNvbG9yID0gcGFyYW1zLmljb25Db2xvcjtcbiAgaWNvbi5zdHlsZS5ib3JkZXJDb2xvciA9IHBhcmFtcy5pY29uQ29sb3I7XG4gIGZvciAoY29uc3Qgc2VsIG9mIFsnLnN3YWwyLXN1Y2Nlc3MtbGluZS10aXAnLCAnLnN3YWwyLXN1Y2Nlc3MtbGluZS1sb25nJywgJy5zd2FsMi14LW1hcmstbGluZS1sZWZ0JywgJy5zd2FsMi14LW1hcmstbGluZS1yaWdodCddKSB7XG4gICAgc2V0U3R5bGUoaWNvbiwgc2VsLCAnYmFja2dyb3VuZC1jb2xvcicsIHBhcmFtcy5pY29uQ29sb3IpO1xuICB9XG4gIHNldFN0eWxlKGljb24sICcuc3dhbDItc3VjY2Vzcy1yaW5nJywgJ2JvcmRlci1jb2xvcicsIHBhcmFtcy5pY29uQ29sb3IpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gY29udGVudFxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuY29uc3QgaWNvbkNvbnRlbnQgPSBjb250ZW50ID0+IGA8ZGl2IGNsYXNzPVwiJHtzd2FsQ2xhc3Nlc1snaWNvbi1jb250ZW50J119XCI+JHtjb250ZW50fTwvZGl2PmA7XG5cbi8qKlxuICogQHBhcmFtIHtTd2VldEFsZXJ0fSBpbnN0YW5jZVxuICogQHBhcmFtIHtTd2VldEFsZXJ0T3B0aW9uc30gcGFyYW1zXG4gKi9cbmNvbnN0IHJlbmRlckltYWdlID0gKGluc3RhbmNlLCBwYXJhbXMpID0+IHtcbiAgY29uc3QgaW1hZ2UgPSBnZXRJbWFnZSgpO1xuICBpZiAoIWltYWdlKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICghcGFyYW1zLmltYWdlVXJsKSB7XG4gICAgaGlkZShpbWFnZSk7XG4gICAgcmV0dXJuO1xuICB9XG4gIHNob3coaW1hZ2UsICcnKTtcblxuICAvLyBTcmMsIGFsdFxuICBpbWFnZS5zZXRBdHRyaWJ1dGUoJ3NyYycsIHBhcmFtcy5pbWFnZVVybCk7XG4gIGltYWdlLnNldEF0dHJpYnV0ZSgnYWx0JywgcGFyYW1zLmltYWdlQWx0IHx8ICcnKTtcblxuICAvLyBXaWR0aCwgaGVpZ2h0XG4gIGFwcGx5TnVtZXJpY2FsU3R5bGUoaW1hZ2UsICd3aWR0aCcsIHBhcmFtcy5pbWFnZVdpZHRoKTtcbiAgYXBwbHlOdW1lcmljYWxTdHlsZShpbWFnZSwgJ2hlaWdodCcsIHBhcmFtcy5pbWFnZUhlaWdodCk7XG5cbiAgLy8gQ2xhc3NcbiAgaW1hZ2UuY2xhc3NOYW1lID0gc3dhbENsYXNzZXMuaW1hZ2U7XG4gIGFwcGx5Q3VzdG9tQ2xhc3MoaW1hZ2UsIHBhcmFtcywgJ2ltYWdlJyk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7U3dlZXRBbGVydH0gaW5zdGFuY2VcbiAqIEBwYXJhbSB7U3dlZXRBbGVydE9wdGlvbnN9IHBhcmFtc1xuICovXG5jb25zdCByZW5kZXJQb3B1cCA9IChpbnN0YW5jZSwgcGFyYW1zKSA9PiB7XG4gIGNvbnN0IGNvbnRhaW5lciA9IGdldENvbnRhaW5lcigpO1xuICBjb25zdCBwb3B1cCA9IGdldFBvcHVwKCk7XG4gIGlmICghY29udGFpbmVyIHx8ICFwb3B1cCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIFdpZHRoXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9zd2VldGFsZXJ0Mi9zd2VldGFsZXJ0Mi9pc3N1ZXMvMjE3MFxuICBpZiAocGFyYW1zLnRvYXN0KSB7XG4gICAgYXBwbHlOdW1lcmljYWxTdHlsZShjb250YWluZXIsICd3aWR0aCcsIHBhcmFtcy53aWR0aCk7XG4gICAgcG9wdXAuc3R5bGUud2lkdGggPSAnMTAwJSc7XG4gICAgY29uc3QgbG9hZGVyID0gZ2V0TG9hZGVyKCk7XG4gICAgaWYgKGxvYWRlcikge1xuICAgICAgcG9wdXAuaW5zZXJ0QmVmb3JlKGxvYWRlciwgZ2V0SWNvbigpKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgYXBwbHlOdW1lcmljYWxTdHlsZShwb3B1cCwgJ3dpZHRoJywgcGFyYW1zLndpZHRoKTtcbiAgfVxuXG4gIC8vIFBhZGRpbmdcbiAgYXBwbHlOdW1lcmljYWxTdHlsZShwb3B1cCwgJ3BhZGRpbmcnLCBwYXJhbXMucGFkZGluZyk7XG5cbiAgLy8gQ29sb3JcbiAgaWYgKHBhcmFtcy5jb2xvcikge1xuICAgIHBvcHVwLnN0eWxlLmNvbG9yID0gcGFyYW1zLmNvbG9yO1xuICB9XG5cbiAgLy8gQmFja2dyb3VuZFxuICBpZiAocGFyYW1zLmJhY2tncm91bmQpIHtcbiAgICBwb3B1cC5zdHlsZS5iYWNrZ3JvdW5kID0gcGFyYW1zLmJhY2tncm91bmQ7XG4gIH1cbiAgaGlkZShnZXRWYWxpZGF0aW9uTWVzc2FnZSgpKTtcblxuICAvLyBDbGFzc2VzXG4gIGFkZENsYXNzZXMkMShwb3B1cCwgcGFyYW1zKTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gcG9wdXBcbiAqIEBwYXJhbSB7U3dlZXRBbGVydE9wdGlvbnN9IHBhcmFtc1xuICovXG5jb25zdCBhZGRDbGFzc2VzJDEgPSAocG9wdXAsIHBhcmFtcykgPT4ge1xuICBjb25zdCBzaG93Q2xhc3MgPSBwYXJhbXMuc2hvd0NsYXNzIHx8IHt9O1xuICAvLyBEZWZhdWx0IENsYXNzICsgc2hvd0NsYXNzIHdoZW4gdXBkYXRpbmcgU3dhbC51cGRhdGUoe30pXG4gIHBvcHVwLmNsYXNzTmFtZSA9IGAke3N3YWxDbGFzc2VzLnBvcHVwfSAke2lzVmlzaWJsZSQxKHBvcHVwKSA/IHNob3dDbGFzcy5wb3B1cCA6ICcnfWA7XG4gIGlmIChwYXJhbXMudG9hc3QpIHtcbiAgICBhZGRDbGFzcyhbZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCBkb2N1bWVudC5ib2R5XSwgc3dhbENsYXNzZXNbJ3RvYXN0LXNob3duJ10pO1xuICAgIGFkZENsYXNzKHBvcHVwLCBzd2FsQ2xhc3Nlcy50b2FzdCk7XG4gIH0gZWxzZSB7XG4gICAgYWRkQ2xhc3MocG9wdXAsIHN3YWxDbGFzc2VzLm1vZGFsKTtcbiAgfVxuXG4gIC8vIEN1c3RvbSBjbGFzc1xuICBhcHBseUN1c3RvbUNsYXNzKHBvcHVwLCBwYXJhbXMsICdwb3B1cCcpO1xuICAvLyBUT0RPOiByZW1vdmUgaW4gdGhlIG5leHQgbWFqb3JcbiAgaWYgKHR5cGVvZiBwYXJhbXMuY3VzdG9tQ2xhc3MgPT09ICdzdHJpbmcnKSB7XG4gICAgYWRkQ2xhc3MocG9wdXAsIHBhcmFtcy5jdXN0b21DbGFzcyk7XG4gIH1cblxuICAvLyBJY29uIGNsYXNzICgjMTg0MilcbiAgaWYgKHBhcmFtcy5pY29uKSB7XG4gICAgYWRkQ2xhc3MocG9wdXAsIHN3YWxDbGFzc2VzW2BpY29uLSR7cGFyYW1zLmljb259YF0pO1xuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7U3dlZXRBbGVydH0gaW5zdGFuY2VcbiAqIEBwYXJhbSB7U3dlZXRBbGVydE9wdGlvbnN9IHBhcmFtc1xuICovXG5jb25zdCByZW5kZXJQcm9ncmVzc1N0ZXBzID0gKGluc3RhbmNlLCBwYXJhbXMpID0+IHtcbiAgY29uc3QgcHJvZ3Jlc3NTdGVwc0NvbnRhaW5lciA9IGdldFByb2dyZXNzU3RlcHMoKTtcbiAgaWYgKCFwcm9ncmVzc1N0ZXBzQ29udGFpbmVyKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHtcbiAgICBwcm9ncmVzc1N0ZXBzLFxuICAgIGN1cnJlbnRQcm9ncmVzc1N0ZXBcbiAgfSA9IHBhcmFtcztcbiAgaWYgKCFwcm9ncmVzc1N0ZXBzIHx8IHByb2dyZXNzU3RlcHMubGVuZ3RoID09PSAwIHx8IGN1cnJlbnRQcm9ncmVzc1N0ZXAgPT09IHVuZGVmaW5lZCkge1xuICAgIGhpZGUocHJvZ3Jlc3NTdGVwc0NvbnRhaW5lcik7XG4gICAgcmV0dXJuO1xuICB9XG4gIHNob3cocHJvZ3Jlc3NTdGVwc0NvbnRhaW5lcik7XG4gIHByb2dyZXNzU3RlcHNDb250YWluZXIudGV4dENvbnRlbnQgPSAnJztcbiAgaWYgKGN1cnJlbnRQcm9ncmVzc1N0ZXAgPj0gcHJvZ3Jlc3NTdGVwcy5sZW5ndGgpIHtcbiAgICB3YXJuKCdJbnZhbGlkIGN1cnJlbnRQcm9ncmVzc1N0ZXAgcGFyYW1ldGVyLCBpdCBzaG91bGQgYmUgbGVzcyB0aGFuIHByb2dyZXNzU3RlcHMubGVuZ3RoICcgKyAnKGN1cnJlbnRQcm9ncmVzc1N0ZXAgbGlrZSBKUyBhcnJheXMgc3RhcnRzIGZyb20gMCknKTtcbiAgfVxuICBwcm9ncmVzc1N0ZXBzLmZvckVhY2goKHN0ZXAsIGluZGV4KSA9PiB7XG4gICAgY29uc3Qgc3RlcEVsID0gY3JlYXRlU3RlcEVsZW1lbnQoc3RlcCk7XG4gICAgcHJvZ3Jlc3NTdGVwc0NvbnRhaW5lci5hcHBlbmRDaGlsZChzdGVwRWwpO1xuICAgIGlmIChpbmRleCA9PT0gY3VycmVudFByb2dyZXNzU3RlcCkge1xuICAgICAgYWRkQ2xhc3Moc3RlcEVsLCBzd2FsQ2xhc3Nlc1snYWN0aXZlLXByb2dyZXNzLXN0ZXAnXSk7XG4gICAgfVxuICAgIGlmIChpbmRleCAhPT0gcHJvZ3Jlc3NTdGVwcy5sZW5ndGggLSAxKSB7XG4gICAgICBjb25zdCBsaW5lRWwgPSBjcmVhdGVMaW5lRWxlbWVudChwYXJhbXMpO1xuICAgICAgcHJvZ3Jlc3NTdGVwc0NvbnRhaW5lci5hcHBlbmRDaGlsZChsaW5lRWwpO1xuICAgIH1cbiAgfSk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdGVwXG4gKiBAcmV0dXJucyB7SFRNTExJRWxlbWVudH1cbiAqL1xuY29uc3QgY3JlYXRlU3RlcEVsZW1lbnQgPSBzdGVwID0+IHtcbiAgY29uc3Qgc3RlcEVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGknKTtcbiAgYWRkQ2xhc3Moc3RlcEVsLCBzd2FsQ2xhc3Nlc1sncHJvZ3Jlc3Mtc3RlcCddKTtcbiAgc2V0SW5uZXJIdG1sKHN0ZXBFbCwgc3RlcCk7XG4gIHJldHVybiBzdGVwRWw7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7U3dlZXRBbGVydE9wdGlvbnN9IHBhcmFtc1xuICogQHJldHVybnMge0hUTUxMSUVsZW1lbnR9XG4gKi9cbmNvbnN0IGNyZWF0ZUxpbmVFbGVtZW50ID0gcGFyYW1zID0+IHtcbiAgY29uc3QgbGluZUVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGknKTtcbiAgYWRkQ2xhc3MobGluZUVsLCBzd2FsQ2xhc3Nlc1sncHJvZ3Jlc3Mtc3RlcC1saW5lJ10pO1xuICBpZiAocGFyYW1zLnByb2dyZXNzU3RlcHNEaXN0YW5jZSkge1xuICAgIGFwcGx5TnVtZXJpY2FsU3R5bGUobGluZUVsLCAnd2lkdGgnLCBwYXJhbXMucHJvZ3Jlc3NTdGVwc0Rpc3RhbmNlKTtcbiAgfVxuICByZXR1cm4gbGluZUVsO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge1N3ZWV0QWxlcnR9IGluc3RhbmNlXG4gKiBAcGFyYW0ge1N3ZWV0QWxlcnRPcHRpb25zfSBwYXJhbXNcbiAqL1xuY29uc3QgcmVuZGVyVGl0bGUgPSAoaW5zdGFuY2UsIHBhcmFtcykgPT4ge1xuICBjb25zdCB0aXRsZSA9IGdldFRpdGxlKCk7XG4gIGlmICghdGl0bGUpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgc2hvd1doZW5Jbm5lckh0bWxQcmVzZW50KHRpdGxlKTtcbiAgdG9nZ2xlKHRpdGxlLCBwYXJhbXMudGl0bGUgfHwgcGFyYW1zLnRpdGxlVGV4dCwgJ2Jsb2NrJyk7XG4gIGlmIChwYXJhbXMudGl0bGUpIHtcbiAgICBwYXJzZUh0bWxUb0NvbnRhaW5lcihwYXJhbXMudGl0bGUsIHRpdGxlKTtcbiAgfVxuICBpZiAocGFyYW1zLnRpdGxlVGV4dCkge1xuICAgIHRpdGxlLmlubmVyVGV4dCA9IHBhcmFtcy50aXRsZVRleHQ7XG4gIH1cblxuICAvLyBDdXN0b20gY2xhc3NcbiAgYXBwbHlDdXN0b21DbGFzcyh0aXRsZSwgcGFyYW1zLCAndGl0bGUnKTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtTd2VldEFsZXJ0fSBpbnN0YW5jZVxuICogQHBhcmFtIHtTd2VldEFsZXJ0T3B0aW9uc30gcGFyYW1zXG4gKi9cbmNvbnN0IHJlbmRlciA9IChpbnN0YW5jZSwgcGFyYW1zKSA9PiB7XG4gIHJlbmRlclBvcHVwKGluc3RhbmNlLCBwYXJhbXMpO1xuICByZW5kZXJDb250YWluZXIoaW5zdGFuY2UsIHBhcmFtcyk7XG4gIHJlbmRlclByb2dyZXNzU3RlcHMoaW5zdGFuY2UsIHBhcmFtcyk7XG4gIHJlbmRlckljb24oaW5zdGFuY2UsIHBhcmFtcyk7XG4gIHJlbmRlckltYWdlKGluc3RhbmNlLCBwYXJhbXMpO1xuICByZW5kZXJUaXRsZShpbnN0YW5jZSwgcGFyYW1zKTtcbiAgcmVuZGVyQ2xvc2VCdXR0b24oaW5zdGFuY2UsIHBhcmFtcyk7XG4gIHJlbmRlckNvbnRlbnQoaW5zdGFuY2UsIHBhcmFtcyk7XG4gIHJlbmRlckFjdGlvbnMoaW5zdGFuY2UsIHBhcmFtcyk7XG4gIHJlbmRlckZvb3RlcihpbnN0YW5jZSwgcGFyYW1zKTtcbiAgY29uc3QgcG9wdXAgPSBnZXRQb3B1cCgpO1xuICBpZiAodHlwZW9mIHBhcmFtcy5kaWRSZW5kZXIgPT09ICdmdW5jdGlvbicgJiYgcG9wdXApIHtcbiAgICBwYXJhbXMuZGlkUmVuZGVyKHBvcHVwKTtcbiAgfVxuICBnbG9iYWxTdGF0ZS5ldmVudEVtaXR0ZXIuZW1pdCgnZGlkUmVuZGVyJywgcG9wdXApO1xufTtcblxuLypcbiAqIEdsb2JhbCBmdW5jdGlvbiB0byBkZXRlcm1pbmUgaWYgU3dlZXRBbGVydDIgcG9wdXAgaXMgc2hvd25cbiAqL1xuY29uc3QgaXNWaXNpYmxlID0gKCkgPT4ge1xuICByZXR1cm4gaXNWaXNpYmxlJDEoZ2V0UG9wdXAoKSk7XG59O1xuXG4vKlxuICogR2xvYmFsIGZ1bmN0aW9uIHRvIGNsaWNrICdDb25maXJtJyBidXR0b25cbiAqL1xuY29uc3QgY2xpY2tDb25maXJtID0gKCkgPT4ge1xuICB2YXIgX2RvbSRnZXRDb25maXJtQnV0dG9uO1xuICByZXR1cm4gKF9kb20kZ2V0Q29uZmlybUJ1dHRvbiA9IGdldENvbmZpcm1CdXR0b24oKSkgPT09IG51bGwgfHwgX2RvbSRnZXRDb25maXJtQnV0dG9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZG9tJGdldENvbmZpcm1CdXR0b24uY2xpY2soKTtcbn07XG5cbi8qXG4gKiBHbG9iYWwgZnVuY3Rpb24gdG8gY2xpY2sgJ0RlbnknIGJ1dHRvblxuICovXG5jb25zdCBjbGlja0RlbnkgPSAoKSA9PiB7XG4gIHZhciBfZG9tJGdldERlbnlCdXR0b247XG4gIHJldHVybiAoX2RvbSRnZXREZW55QnV0dG9uID0gZ2V0RGVueUJ1dHRvbigpKSA9PT0gbnVsbCB8fCBfZG9tJGdldERlbnlCdXR0b24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kb20kZ2V0RGVueUJ1dHRvbi5jbGljaygpO1xufTtcblxuLypcbiAqIEdsb2JhbCBmdW5jdGlvbiB0byBjbGljayAnQ2FuY2VsJyBidXR0b25cbiAqL1xuY29uc3QgY2xpY2tDYW5jZWwgPSAoKSA9PiB7XG4gIHZhciBfZG9tJGdldENhbmNlbEJ1dHRvbjtcbiAgcmV0dXJuIChfZG9tJGdldENhbmNlbEJ1dHRvbiA9IGdldENhbmNlbEJ1dHRvbigpKSA9PT0gbnVsbCB8fCBfZG9tJGdldENhbmNlbEJ1dHRvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2RvbSRnZXRDYW5jZWxCdXR0b24uY2xpY2soKTtcbn07XG5cbi8qKiBAdHlwZWRlZiB7J2NhbmNlbCcgfCAnYmFja2Ryb3AnIHwgJ2Nsb3NlJyB8ICdlc2MnIHwgJ3RpbWVyJ30gRGlzbWlzc1JlYXNvbiAqL1xuXG4vKiogQHR5cGUge1JlY29yZDxEaXNtaXNzUmVhc29uLCBEaXNtaXNzUmVhc29uPn0gKi9cbmNvbnN0IERpc21pc3NSZWFzb24gPSBPYmplY3QuZnJlZXplKHtcbiAgY2FuY2VsOiAnY2FuY2VsJyxcbiAgYmFja2Ryb3A6ICdiYWNrZHJvcCcsXG4gIGNsb3NlOiAnY2xvc2UnLFxuICBlc2M6ICdlc2MnLFxuICB0aW1lcjogJ3RpbWVyJ1xufSk7XG5cbi8qKlxuICogQHBhcmFtIHtHbG9iYWxTdGF0ZX0gZ2xvYmFsU3RhdGVcbiAqL1xuY29uc3QgcmVtb3ZlS2V5ZG93bkhhbmRsZXIgPSBnbG9iYWxTdGF0ZSA9PiB7XG4gIGlmIChnbG9iYWxTdGF0ZS5rZXlkb3duVGFyZ2V0ICYmIGdsb2JhbFN0YXRlLmtleWRvd25IYW5kbGVyQWRkZWQpIHtcbiAgICBnbG9iYWxTdGF0ZS5rZXlkb3duVGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBnbG9iYWxTdGF0ZS5rZXlkb3duSGFuZGxlciwge1xuICAgICAgY2FwdHVyZTogZ2xvYmFsU3RhdGUua2V5ZG93bkxpc3RlbmVyQ2FwdHVyZVxuICAgIH0pO1xuICAgIGdsb2JhbFN0YXRlLmtleWRvd25IYW5kbGVyQWRkZWQgPSBmYWxzZTtcbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge0dsb2JhbFN0YXRlfSBnbG9iYWxTdGF0ZVxuICogQHBhcmFtIHtTd2VldEFsZXJ0T3B0aW9uc30gaW5uZXJQYXJhbXNcbiAqIEBwYXJhbSB7Kn0gZGlzbWlzc1dpdGhcbiAqL1xuY29uc3QgYWRkS2V5ZG93bkhhbmRsZXIgPSAoZ2xvYmFsU3RhdGUsIGlubmVyUGFyYW1zLCBkaXNtaXNzV2l0aCkgPT4ge1xuICByZW1vdmVLZXlkb3duSGFuZGxlcihnbG9iYWxTdGF0ZSk7XG4gIGlmICghaW5uZXJQYXJhbXMudG9hc3QpIHtcbiAgICBnbG9iYWxTdGF0ZS5rZXlkb3duSGFuZGxlciA9IGUgPT4ga2V5ZG93bkhhbmRsZXIoaW5uZXJQYXJhbXMsIGUsIGRpc21pc3NXaXRoKTtcbiAgICBnbG9iYWxTdGF0ZS5rZXlkb3duVGFyZ2V0ID0gaW5uZXJQYXJhbXMua2V5ZG93bkxpc3RlbmVyQ2FwdHVyZSA/IHdpbmRvdyA6IGdldFBvcHVwKCk7XG4gICAgZ2xvYmFsU3RhdGUua2V5ZG93bkxpc3RlbmVyQ2FwdHVyZSA9IGlubmVyUGFyYW1zLmtleWRvd25MaXN0ZW5lckNhcHR1cmU7XG4gICAgZ2xvYmFsU3RhdGUua2V5ZG93blRhcmdldC5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgZ2xvYmFsU3RhdGUua2V5ZG93bkhhbmRsZXIsIHtcbiAgICAgIGNhcHR1cmU6IGdsb2JhbFN0YXRlLmtleWRvd25MaXN0ZW5lckNhcHR1cmVcbiAgICB9KTtcbiAgICBnbG9iYWxTdGF0ZS5rZXlkb3duSGFuZGxlckFkZGVkID0gdHJ1ZTtcbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmNyZW1lbnRcbiAqL1xuY29uc3Qgc2V0Rm9jdXMgPSAoaW5kZXgsIGluY3JlbWVudCkgPT4ge1xuICB2YXIgX2RvbSRnZXRQb3B1cDtcbiAgY29uc3QgZm9jdXNhYmxlRWxlbWVudHMgPSBnZXRGb2N1c2FibGVFbGVtZW50cygpO1xuICAvLyBzZWFyY2ggZm9yIHZpc2libGUgZWxlbWVudHMgYW5kIHNlbGVjdCB0aGUgbmV4dCBwb3NzaWJsZSBtYXRjaFxuICBpZiAoZm9jdXNhYmxlRWxlbWVudHMubGVuZ3RoKSB7XG4gICAgaW5kZXggPSBpbmRleCArIGluY3JlbWVudDtcblxuICAgIC8vIHJvbGxvdmVyIHRvIGZpcnN0IGl0ZW1cbiAgICBpZiAoaW5kZXggPT09IGZvY3VzYWJsZUVsZW1lbnRzLmxlbmd0aCkge1xuICAgICAgaW5kZXggPSAwO1xuXG4gICAgICAvLyBnbyB0byBsYXN0IGl0ZW1cbiAgICB9IGVsc2UgaWYgKGluZGV4ID09PSAtMSkge1xuICAgICAgaW5kZXggPSBmb2N1c2FibGVFbGVtZW50cy5sZW5ndGggLSAxO1xuICAgIH1cbiAgICBmb2N1c2FibGVFbGVtZW50c1tpbmRleF0uZm9jdXMoKTtcbiAgICByZXR1cm47XG4gIH1cbiAgLy8gbm8gdmlzaWJsZSBmb2N1c2FibGUgZWxlbWVudHMsIGZvY3VzIHRoZSBwb3B1cFxuICAoX2RvbSRnZXRQb3B1cCA9IGdldFBvcHVwKCkpID09PSBudWxsIHx8IF9kb20kZ2V0UG9wdXAgPT09IHZvaWQgMCB8fCBfZG9tJGdldFBvcHVwLmZvY3VzKCk7XG59O1xuY29uc3QgYXJyb3dLZXlzTmV4dEJ1dHRvbiA9IFsnQXJyb3dSaWdodCcsICdBcnJvd0Rvd24nXTtcbmNvbnN0IGFycm93S2V5c1ByZXZpb3VzQnV0dG9uID0gWydBcnJvd0xlZnQnLCAnQXJyb3dVcCddO1xuXG4vKipcbiAqIEBwYXJhbSB7U3dlZXRBbGVydE9wdGlvbnN9IGlubmVyUGFyYW1zXG4gKiBAcGFyYW0ge0tleWJvYXJkRXZlbnR9IGV2ZW50XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBkaXNtaXNzV2l0aFxuICovXG5jb25zdCBrZXlkb3duSGFuZGxlciA9IChpbm5lclBhcmFtcywgZXZlbnQsIGRpc21pc3NXaXRoKSA9PiB7XG4gIGlmICghaW5uZXJQYXJhbXMpIHtcbiAgICByZXR1cm47IC8vIFRoaXMgaW5zdGFuY2UgaGFzIGFscmVhZHkgYmVlbiBkZXN0cm95ZWRcbiAgfVxuXG4gIC8vIElnbm9yZSBrZXlkb3duIGR1cmluZyBJTUUgY29tcG9zaXRpb25cbiAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0RvY3VtZW50L2tleWRvd25fZXZlbnQjaWdub3Jpbmdfa2V5ZG93bl9kdXJpbmdfaW1lX2NvbXBvc2l0aW9uXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9zd2VldGFsZXJ0Mi9zd2VldGFsZXJ0Mi9pc3N1ZXMvNzIwXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9zd2VldGFsZXJ0Mi9zd2VldGFsZXJ0Mi9pc3N1ZXMvMjQwNlxuICBpZiAoZXZlbnQuaXNDb21wb3NpbmcgfHwgZXZlbnQua2V5Q29kZSA9PT0gMjI5KSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChpbm5lclBhcmFtcy5zdG9wS2V5ZG93blByb3BhZ2F0aW9uKSB7XG4gICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gIH1cblxuICAvLyBFTlRFUlxuICBpZiAoZXZlbnQua2V5ID09PSAnRW50ZXInKSB7XG4gICAgaGFuZGxlRW50ZXIoZXZlbnQsIGlubmVyUGFyYW1zKTtcbiAgfVxuXG4gIC8vIFRBQlxuICBlbHNlIGlmIChldmVudC5rZXkgPT09ICdUYWInKSB7XG4gICAgaGFuZGxlVGFiKGV2ZW50KTtcbiAgfVxuXG4gIC8vIEFSUk9XUyAtIHN3aXRjaCBmb2N1cyBiZXR3ZWVuIGJ1dHRvbnNcbiAgZWxzZSBpZiAoWy4uLmFycm93S2V5c05leHRCdXR0b24sIC4uLmFycm93S2V5c1ByZXZpb3VzQnV0dG9uXS5pbmNsdWRlcyhldmVudC5rZXkpKSB7XG4gICAgaGFuZGxlQXJyb3dzKGV2ZW50LmtleSk7XG4gIH1cblxuICAvLyBFU0NcbiAgZWxzZSBpZiAoZXZlbnQua2V5ID09PSAnRXNjYXBlJykge1xuICAgIGhhbmRsZUVzYyhldmVudCwgaW5uZXJQYXJhbXMsIGRpc21pc3NXaXRoKTtcbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge0tleWJvYXJkRXZlbnR9IGV2ZW50XG4gKiBAcGFyYW0ge1N3ZWV0QWxlcnRPcHRpb25zfSBpbm5lclBhcmFtc1xuICovXG5jb25zdCBoYW5kbGVFbnRlciA9IChldmVudCwgaW5uZXJQYXJhbXMpID0+IHtcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3N3ZWV0YWxlcnQyL3N3ZWV0YWxlcnQyL2lzc3Vlcy8yMzg2XG4gIGlmICghY2FsbElmRnVuY3Rpb24oaW5uZXJQYXJhbXMuYWxsb3dFbnRlcktleSkpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgaW5wdXQgPSBnZXRJbnB1dCQxKGdldFBvcHVwKCksIGlubmVyUGFyYW1zLmlucHV0KTtcbiAgaWYgKGV2ZW50LnRhcmdldCAmJiBpbnB1dCAmJiBldmVudC50YXJnZXQgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCAmJiBldmVudC50YXJnZXQub3V0ZXJIVE1MID09PSBpbnB1dC5vdXRlckhUTUwpIHtcbiAgICBpZiAoWyd0ZXh0YXJlYScsICdmaWxlJ10uaW5jbHVkZXMoaW5uZXJQYXJhbXMuaW5wdXQpKSB7XG4gICAgICByZXR1cm47IC8vIGRvIG5vdCBzdWJtaXRcbiAgICB9XG4gICAgY2xpY2tDb25maXJtKCk7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge0tleWJvYXJkRXZlbnR9IGV2ZW50XG4gKi9cbmNvbnN0IGhhbmRsZVRhYiA9IGV2ZW50ID0+IHtcbiAgY29uc3QgdGFyZ2V0RWxlbWVudCA9IGV2ZW50LnRhcmdldDtcbiAgY29uc3QgZm9jdXNhYmxlRWxlbWVudHMgPSBnZXRGb2N1c2FibGVFbGVtZW50cygpO1xuICBsZXQgYnRuSW5kZXggPSAtMTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBmb2N1c2FibGVFbGVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIGlmICh0YXJnZXRFbGVtZW50ID09PSBmb2N1c2FibGVFbGVtZW50c1tpXSkge1xuICAgICAgYnRuSW5kZXggPSBpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgLy8gQ3ljbGUgdG8gdGhlIG5leHQgYnV0dG9uXG4gIGlmICghZXZlbnQuc2hpZnRLZXkpIHtcbiAgICBzZXRGb2N1cyhidG5JbmRleCwgMSk7XG4gIH1cblxuICAvLyBDeWNsZSB0byB0aGUgcHJldiBidXR0b25cbiAgZWxzZSB7XG4gICAgc2V0Rm9jdXMoYnRuSW5kZXgsIC0xKTtcbiAgfVxuICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICovXG5jb25zdCBoYW5kbGVBcnJvd3MgPSBrZXkgPT4ge1xuICBjb25zdCBhY3Rpb25zID0gZ2V0QWN0aW9ucygpO1xuICBjb25zdCBjb25maXJtQnV0dG9uID0gZ2V0Q29uZmlybUJ1dHRvbigpO1xuICBjb25zdCBkZW55QnV0dG9uID0gZ2V0RGVueUJ1dHRvbigpO1xuICBjb25zdCBjYW5jZWxCdXR0b24gPSBnZXRDYW5jZWxCdXR0b24oKTtcbiAgaWYgKCFhY3Rpb25zIHx8ICFjb25maXJtQnV0dG9uIHx8ICFkZW55QnV0dG9uIHx8ICFjYW5jZWxCdXR0b24pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgLyoqIEB0eXBlIEhUTUxFbGVtZW50W10gKi9cbiAgY29uc3QgYnV0dG9ucyA9IFtjb25maXJtQnV0dG9uLCBkZW55QnV0dG9uLCBjYW5jZWxCdXR0b25dO1xuICBpZiAoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50ICYmICFidXR0b25zLmluY2x1ZGVzKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHNpYmxpbmcgPSBhcnJvd0tleXNOZXh0QnV0dG9uLmluY2x1ZGVzKGtleSkgPyAnbmV4dEVsZW1lbnRTaWJsaW5nJyA6ICdwcmV2aW91c0VsZW1lbnRTaWJsaW5nJztcbiAgbGV0IGJ1dHRvblRvRm9jdXMgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuICBpZiAoIWJ1dHRvblRvRm9jdXMpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBhY3Rpb25zLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgYnV0dG9uVG9Gb2N1cyA9IGJ1dHRvblRvRm9jdXNbc2libGluZ107XG4gICAgaWYgKCFidXR0b25Ub0ZvY3VzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChidXR0b25Ub0ZvY3VzIGluc3RhbmNlb2YgSFRNTEJ1dHRvbkVsZW1lbnQgJiYgaXNWaXNpYmxlJDEoYnV0dG9uVG9Gb2N1cykpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBpZiAoYnV0dG9uVG9Gb2N1cyBpbnN0YW5jZW9mIEhUTUxCdXR0b25FbGVtZW50KSB7XG4gICAgYnV0dG9uVG9Gb2N1cy5mb2N1cygpO1xuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7S2V5Ym9hcmRFdmVudH0gZXZlbnRcbiAqIEBwYXJhbSB7U3dlZXRBbGVydE9wdGlvbnN9IGlubmVyUGFyYW1zXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBkaXNtaXNzV2l0aFxuICovXG5jb25zdCBoYW5kbGVFc2MgPSAoZXZlbnQsIGlubmVyUGFyYW1zLCBkaXNtaXNzV2l0aCkgPT4ge1xuICBpZiAoY2FsbElmRnVuY3Rpb24oaW5uZXJQYXJhbXMuYWxsb3dFc2NhcGVLZXkpKSB7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICBkaXNtaXNzV2l0aChEaXNtaXNzUmVhc29uLmVzYyk7XG4gIH1cbn07XG5cbi8qKlxuICogVGhpcyBtb2R1bGUgY29udGFpbnMgYFdlYWtNYXBgcyBmb3IgZWFjaCBlZmZlY3RpdmVseS1cInByaXZhdGUgIHByb3BlcnR5XCIgdGhhdCBhIGBTd2FsYCBoYXMuXG4gKiBGb3IgZXhhbXBsZSwgdG8gc2V0IHRoZSBwcml2YXRlIHByb3BlcnR5IFwiZm9vXCIgb2YgYHRoaXNgIHRvIFwiYmFyXCIsIHlvdSBjYW4gYHByaXZhdGVQcm9wcy5mb28uc2V0KHRoaXMsICdiYXInKWBcbiAqIFRoaXMgaXMgdGhlIGFwcHJvYWNoIHRoYXQgQmFiZWwgd2lsbCBwcm9iYWJseSB0YWtlIHRvIGltcGxlbWVudCBwcml2YXRlIG1ldGhvZHMvZmllbGRzXG4gKiAgIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLXByaXZhdGUtbWV0aG9kc1xuICogICBodHRwczovL2dpdGh1Yi5jb20vYmFiZWwvYmFiZWwvcHVsbC83NTU1XG4gKiBPbmNlIHdlIGhhdmUgdGhlIGNoYW5nZXMgZnJvbSB0aGF0IFBSIGluIEJhYmVsLCBhbmQgb3VyIGNvcmUgY2xhc3MgZml0cyByZWFzb25hYmxlIGluICpvbmUgbW9kdWxlKlxuICogICB0aGVuIHdlIGNhbiB1c2UgdGhhdCBsYW5ndWFnZSBmZWF0dXJlLlxuICovXG5cbnZhciBwcml2YXRlTWV0aG9kcyA9IHtcbiAgc3dhbFByb21pc2VSZXNvbHZlOiBuZXcgV2Vha01hcCgpLFxuICBzd2FsUHJvbWlzZVJlamVjdDogbmV3IFdlYWtNYXAoKVxufTtcblxuLy8gRnJvbSBodHRwczovL2RldmVsb3Blci5wYWNpZWxsb2dyb3VwLmNvbS9ibG9nLzIwMTgvMDYvdGhlLWN1cnJlbnQtc3RhdGUtb2YtbW9kYWwtZGlhbG9nLWFjY2Vzc2liaWxpdHkvXG4vLyBBZGRpbmcgYXJpYS1oaWRkZW49XCJ0cnVlXCIgdG8gZWxlbWVudHMgb3V0c2lkZSBvZiB0aGUgYWN0aXZlIG1vZGFsIGRpYWxvZyBlbnN1cmVzIHRoYXRcbi8vIGVsZW1lbnRzIG5vdCB3aXRoaW4gdGhlIGFjdGl2ZSBtb2RhbCBkaWFsb2cgd2lsbCBub3QgYmUgc3VyZmFjZWQgaWYgYSB1c2VyIG9wZW5zIGEgc2NyZWVuXG4vLyByZWFkZXLigJlzIGxpc3Qgb2YgZWxlbWVudHMgKGhlYWRpbmdzLCBmb3JtIGNvbnRyb2xzLCBsYW5kbWFya3MsIGV0Yy4pIGluIHRoZSBkb2N1bWVudC5cblxuY29uc3Qgc2V0QXJpYUhpZGRlbiA9ICgpID0+IHtcbiAgY29uc3QgY29udGFpbmVyID0gZ2V0Q29udGFpbmVyKCk7XG4gIGNvbnN0IGJvZHlDaGlsZHJlbiA9IEFycmF5LmZyb20oZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gIGJvZHlDaGlsZHJlbi5mb3JFYWNoKGVsID0+IHtcbiAgICBpZiAoZWwuY29udGFpbnMoY29udGFpbmVyKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZWwuaGFzQXR0cmlidXRlKCdhcmlhLWhpZGRlbicpKSB7XG4gICAgICBlbC5zZXRBdHRyaWJ1dGUoJ2RhdGEtcHJldmlvdXMtYXJpYS1oaWRkZW4nLCBlbC5nZXRBdHRyaWJ1dGUoJ2FyaWEtaGlkZGVuJykgfHwgJycpO1xuICAgIH1cbiAgICBlbC5zZXRBdHRyaWJ1dGUoJ2FyaWEtaGlkZGVuJywgJ3RydWUnKTtcbiAgfSk7XG59O1xuY29uc3QgdW5zZXRBcmlhSGlkZGVuID0gKCkgPT4ge1xuICBjb25zdCBib2R5Q2hpbGRyZW4gPSBBcnJheS5mcm9tKGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICBib2R5Q2hpbGRyZW4uZm9yRWFjaChlbCA9PiB7XG4gICAgaWYgKGVsLmhhc0F0dHJpYnV0ZSgnZGF0YS1wcmV2aW91cy1hcmlhLWhpZGRlbicpKSB7XG4gICAgICBlbC5zZXRBdHRyaWJ1dGUoJ2FyaWEtaGlkZGVuJywgZWwuZ2V0QXR0cmlidXRlKCdkYXRhLXByZXZpb3VzLWFyaWEtaGlkZGVuJykgfHwgJycpO1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKCdkYXRhLXByZXZpb3VzLWFyaWEtaGlkZGVuJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nKTtcbiAgICB9XG4gIH0pO1xufTtcblxuLy8gQHRzLWlnbm9yZVxuY29uc3QgaXNTYWZhcmlPcklPUyA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmICEhd2luZG93Lkdlc3R1cmVFdmVudDsgLy8gdHJ1ZSBmb3IgU2FmYXJpIGRlc2t0b3AgKyBhbGwgaU9TIGJyb3dzZXJzIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS83MDU4NTM5NFxuXG4vKipcbiAqIEZpeCBpT1Mgc2Nyb2xsaW5nXG4gKiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcS8zOTYyNjMwMlxuICovXG5jb25zdCBpT1NmaXggPSAoKSA9PiB7XG4gIGlmIChpc1NhZmFyaU9ySU9TICYmICFoYXNDbGFzcyhkb2N1bWVudC5ib2R5LCBzd2FsQ2xhc3Nlcy5pb3NmaXgpKSB7XG4gICAgY29uc3Qgb2Zmc2V0ID0gZG9jdW1lbnQuYm9keS5zY3JvbGxUb3A7XG4gICAgZG9jdW1lbnQuYm9keS5zdHlsZS50b3AgPSBgJHtvZmZzZXQgKiAtMX1weGA7XG4gICAgYWRkQ2xhc3MoZG9jdW1lbnQuYm9keSwgc3dhbENsYXNzZXMuaW9zZml4KTtcbiAgICBsb2NrQm9keVNjcm9sbCgpO1xuICB9XG59O1xuXG4vKipcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9zd2VldGFsZXJ0Mi9zd2VldGFsZXJ0Mi9pc3N1ZXMvMTI0NlxuICovXG5jb25zdCBsb2NrQm9keVNjcm9sbCA9ICgpID0+IHtcbiAgY29uc3QgY29udGFpbmVyID0gZ2V0Q29udGFpbmVyKCk7XG4gIGlmICghY29udGFpbmVyKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIC8qKiBAdHlwZSB7Ym9vbGVhbn0gKi9cbiAgbGV0IHByZXZlbnRUb3VjaE1vdmU7XG4gIC8qKlxuICAgKiBAcGFyYW0ge1RvdWNoRXZlbnR9IGV2ZW50XG4gICAqL1xuICBjb250YWluZXIub250b3VjaHN0YXJ0ID0gZXZlbnQgPT4ge1xuICAgIHByZXZlbnRUb3VjaE1vdmUgPSBzaG91bGRQcmV2ZW50VG91Y2hNb3ZlKGV2ZW50KTtcbiAgfTtcbiAgLyoqXG4gICAqIEBwYXJhbSB7VG91Y2hFdmVudH0gZXZlbnRcbiAgICovXG4gIGNvbnRhaW5lci5vbnRvdWNobW92ZSA9IGV2ZW50ID0+IHtcbiAgICBpZiAocHJldmVudFRvdWNoTW92ZSkge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIH1cbiAgfTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtUb3VjaEV2ZW50fSBldmVudFxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmNvbnN0IHNob3VsZFByZXZlbnRUb3VjaE1vdmUgPSBldmVudCA9PiB7XG4gIGNvbnN0IHRhcmdldCA9IGV2ZW50LnRhcmdldDtcbiAgY29uc3QgY29udGFpbmVyID0gZ2V0Q29udGFpbmVyKCk7XG4gIGNvbnN0IGh0bWxDb250YWluZXIgPSBnZXRIdG1sQ29udGFpbmVyKCk7XG4gIGlmICghY29udGFpbmVyIHx8ICFodG1sQ29udGFpbmVyKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChpc1N0eWx1cyhldmVudCkgfHwgaXNab29tKGV2ZW50KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAodGFyZ2V0ID09PSBjb250YWluZXIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoIWlzU2Nyb2xsYWJsZShjb250YWluZXIpICYmIHRhcmdldCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50ICYmIHRhcmdldC50YWdOYW1lICE9PSAnSU5QVVQnICYmXG4gIC8vICMxNjAzXG4gIHRhcmdldC50YWdOYW1lICE9PSAnVEVYVEFSRUEnICYmXG4gIC8vICMyMjY2XG4gICEoaXNTY3JvbGxhYmxlKGh0bWxDb250YWluZXIpICYmXG4gIC8vICMxOTQ0XG4gIGh0bWxDb250YWluZXIuY29udGFpbnModGFyZ2V0KSkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG4vKipcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9zd2VldGFsZXJ0Mi9zd2VldGFsZXJ0Mi9pc3N1ZXMvMTc4NlxuICpcbiAqIEBwYXJhbSB7Kn0gZXZlbnRcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5jb25zdCBpc1N0eWx1cyA9IGV2ZW50ID0+IHtcbiAgcmV0dXJuIGV2ZW50LnRvdWNoZXMgJiYgZXZlbnQudG91Y2hlcy5sZW5ndGggJiYgZXZlbnQudG91Y2hlc1swXS50b3VjaFR5cGUgPT09ICdzdHlsdXMnO1xufTtcblxuLyoqXG4gKiBodHRwczovL2dpdGh1Yi5jb20vc3dlZXRhbGVydDIvc3dlZXRhbGVydDIvaXNzdWVzLzE4OTFcbiAqXG4gKiBAcGFyYW0ge1RvdWNoRXZlbnR9IGV2ZW50XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuY29uc3QgaXNab29tID0gZXZlbnQgPT4ge1xuICByZXR1cm4gZXZlbnQudG91Y2hlcyAmJiBldmVudC50b3VjaGVzLmxlbmd0aCA+IDE7XG59O1xuY29uc3QgdW5kb0lPU2ZpeCA9ICgpID0+IHtcbiAgaWYgKGhhc0NsYXNzKGRvY3VtZW50LmJvZHksIHN3YWxDbGFzc2VzLmlvc2ZpeCkpIHtcbiAgICBjb25zdCBvZmZzZXQgPSBwYXJzZUludChkb2N1bWVudC5ib2R5LnN0eWxlLnRvcCwgMTApO1xuICAgIHJlbW92ZUNsYXNzKGRvY3VtZW50LmJvZHksIHN3YWxDbGFzc2VzLmlvc2ZpeCk7XG4gICAgZG9jdW1lbnQuYm9keS5zdHlsZS50b3AgPSAnJztcbiAgICBkb2N1bWVudC5ib2R5LnNjcm9sbFRvcCA9IG9mZnNldCAqIC0xO1xuICB9XG59O1xuXG4vKipcbiAqIE1lYXN1cmUgc2Nyb2xsYmFyIHdpZHRoIGZvciBwYWRkaW5nIGJvZHkgZHVyaW5nIG1vZGFsIHNob3cvaGlkZVxuICogaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFzdGVyL2pzL3NyYy9tb2RhbC5qc1xuICpcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmNvbnN0IG1lYXN1cmVTY3JvbGxiYXIgPSAoKSA9PiB7XG4gIGNvbnN0IHNjcm9sbERpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICBzY3JvbGxEaXYuY2xhc3NOYW1lID0gc3dhbENsYXNzZXNbJ3Njcm9sbGJhci1tZWFzdXJlJ107XG4gIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoc2Nyb2xsRGl2KTtcbiAgY29uc3Qgc2Nyb2xsYmFyV2lkdGggPSBzY3JvbGxEaXYuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGggLSBzY3JvbGxEaXYuY2xpZW50V2lkdGg7XG4gIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoc2Nyb2xsRGl2KTtcbiAgcmV0dXJuIHNjcm9sbGJhcldpZHRoO1xufTtcblxuLyoqXG4gKiBSZW1lbWJlciBzdGF0ZSBpbiBjYXNlcyB3aGVyZSBvcGVuaW5nIGFuZCBoYW5kbGluZyBhIG1vZGFsIHdpbGwgZmlkZGxlIHdpdGggaXQuXG4gKiBAdHlwZSB7bnVtYmVyIHwgbnVsbH1cbiAqL1xubGV0IHByZXZpb3VzQm9keVBhZGRpbmcgPSBudWxsO1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBpbml0aWFsQm9keU92ZXJmbG93XG4gKi9cbmNvbnN0IHJlcGxhY2VTY3JvbGxiYXJXaXRoUGFkZGluZyA9IGluaXRpYWxCb2R5T3ZlcmZsb3cgPT4ge1xuICAvLyBmb3IgcXVldWVzLCBkbyBub3QgZG8gdGhpcyBtb3JlIHRoYW4gb25jZVxuICBpZiAocHJldmlvdXNCb2R5UGFkZGluZyAhPT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuICAvLyBpZiB0aGUgYm9keSBoYXMgb3ZlcmZsb3dcbiAgaWYgKGRvY3VtZW50LmJvZHkuc2Nyb2xsSGVpZ2h0ID4gd2luZG93LmlubmVySGVpZ2h0IHx8IGluaXRpYWxCb2R5T3ZlcmZsb3cgPT09ICdzY3JvbGwnIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9zd2VldGFsZXJ0Mi9zd2VldGFsZXJ0Mi9pc3N1ZXMvMjY2M1xuICApIHtcbiAgICAvLyBhZGQgcGFkZGluZyBzbyB0aGUgY29udGVudCBkb2Vzbid0IHNoaWZ0IGFmdGVyIHJlbW92YWwgb2Ygc2Nyb2xsYmFyXG4gICAgcHJldmlvdXNCb2R5UGFkZGluZyA9IHBhcnNlSW50KHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGRvY3VtZW50LmJvZHkpLmdldFByb3BlcnR5VmFsdWUoJ3BhZGRpbmctcmlnaHQnKSk7XG4gICAgZG9jdW1lbnQuYm9keS5zdHlsZS5wYWRkaW5nUmlnaHQgPSBgJHtwcmV2aW91c0JvZHlQYWRkaW5nICsgbWVhc3VyZVNjcm9sbGJhcigpfXB4YDtcbiAgfVxufTtcbmNvbnN0IHVuZG9SZXBsYWNlU2Nyb2xsYmFyV2l0aFBhZGRpbmcgPSAoKSA9PiB7XG4gIGlmIChwcmV2aW91c0JvZHlQYWRkaW5nICE9PSBudWxsKSB7XG4gICAgZG9jdW1lbnQuYm9keS5zdHlsZS5wYWRkaW5nUmlnaHQgPSBgJHtwcmV2aW91c0JvZHlQYWRkaW5nfXB4YDtcbiAgICBwcmV2aW91c0JvZHlQYWRkaW5nID0gbnVsbDtcbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge1N3ZWV0QWxlcnR9IGluc3RhbmNlXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBjb250YWluZXJcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gcmV0dXJuRm9jdXNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGRpZENsb3NlXG4gKi9cbmZ1bmN0aW9uIHJlbW92ZVBvcHVwQW5kUmVzZXRTdGF0ZShpbnN0YW5jZSwgY29udGFpbmVyLCByZXR1cm5Gb2N1cywgZGlkQ2xvc2UpIHtcbiAgaWYgKGlzVG9hc3QoKSkge1xuICAgIHRyaWdnZXJEaWRDbG9zZUFuZERpc3Bvc2UoaW5zdGFuY2UsIGRpZENsb3NlKTtcbiAgfSBlbHNlIHtcbiAgICByZXN0b3JlQWN0aXZlRWxlbWVudChyZXR1cm5Gb2N1cykudGhlbigoKSA9PiB0cmlnZ2VyRGlkQ2xvc2VBbmREaXNwb3NlKGluc3RhbmNlLCBkaWRDbG9zZSkpO1xuICAgIHJlbW92ZUtleWRvd25IYW5kbGVyKGdsb2JhbFN0YXRlKTtcbiAgfVxuXG4gIC8vIHdvcmthcm91bmQgZm9yIGh0dHBzOi8vZ2l0aHViLmNvbS9zd2VldGFsZXJ0Mi9zd2VldGFsZXJ0Mi9pc3N1ZXMvMjA4OFxuICAvLyBmb3Igc29tZSByZWFzb24gcmVtb3ZpbmcgdGhlIGNvbnRhaW5lciBpbiBTYWZhcmkgd2lsbCBzY3JvbGwgdGhlIGRvY3VtZW50IHRvIGJvdHRvbVxuICBpZiAoaXNTYWZhcmlPcklPUykge1xuICAgIGNvbnRhaW5lci5zZXRBdHRyaWJ1dGUoJ3N0eWxlJywgJ2Rpc3BsYXk6bm9uZSAhaW1wb3J0YW50Jyk7XG4gICAgY29udGFpbmVyLnJlbW92ZUF0dHJpYnV0ZSgnY2xhc3MnKTtcbiAgICBjb250YWluZXIuaW5uZXJIVE1MID0gJyc7XG4gIH0gZWxzZSB7XG4gICAgY29udGFpbmVyLnJlbW92ZSgpO1xuICB9XG4gIGlmIChpc01vZGFsKCkpIHtcbiAgICB1bmRvUmVwbGFjZVNjcm9sbGJhcldpdGhQYWRkaW5nKCk7XG4gICAgdW5kb0lPU2ZpeCgpO1xuICAgIHVuc2V0QXJpYUhpZGRlbigpO1xuICB9XG4gIHJlbW92ZUJvZHlDbGFzc2VzKCk7XG59XG5cbi8qKlxuICogUmVtb3ZlIFN3ZWV0QWxlcnQyIGNsYXNzZXMgZnJvbSBib2R5XG4gKi9cbmZ1bmN0aW9uIHJlbW92ZUJvZHlDbGFzc2VzKCkge1xuICByZW1vdmVDbGFzcyhbZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCBkb2N1bWVudC5ib2R5XSwgW3N3YWxDbGFzc2VzLnNob3duLCBzd2FsQ2xhc3Nlc1snaGVpZ2h0LWF1dG8nXSwgc3dhbENsYXNzZXNbJ25vLWJhY2tkcm9wJ10sIHN3YWxDbGFzc2VzWyd0b2FzdC1zaG93biddXSk7XG59XG5cbi8qKlxuICogSW5zdGFuY2UgbWV0aG9kIHRvIGNsb3NlIHN3ZWV0QWxlcnRcbiAqXG4gKiBAcGFyYW0ge2FueX0gcmVzb2x2ZVZhbHVlXG4gKi9cbmZ1bmN0aW9uIGNsb3NlKHJlc29sdmVWYWx1ZSkge1xuICByZXNvbHZlVmFsdWUgPSBwcmVwYXJlUmVzb2x2ZVZhbHVlKHJlc29sdmVWYWx1ZSk7XG4gIGNvbnN0IHN3YWxQcm9taXNlUmVzb2x2ZSA9IHByaXZhdGVNZXRob2RzLnN3YWxQcm9taXNlUmVzb2x2ZS5nZXQodGhpcyk7XG4gIGNvbnN0IGRpZENsb3NlID0gdHJpZ2dlckNsb3NlUG9wdXAodGhpcyk7XG4gIGlmICh0aGlzLmlzQXdhaXRpbmdQcm9taXNlKSB7XG4gICAgLy8gQSBzd2FsIGF3YWl0aW5nIGZvciBhIHByb21pc2UgKGFmdGVyIGEgY2xpY2sgb24gQ29uZmlybSBvciBEZW55KSBjYW5ub3QgYmUgZGlzbWlzc2VkIGFueW1vcmUgIzIzMzVcbiAgICBpZiAoIXJlc29sdmVWYWx1ZS5pc0Rpc21pc3NlZCkge1xuICAgICAgaGFuZGxlQXdhaXRpbmdQcm9taXNlKHRoaXMpO1xuICAgICAgc3dhbFByb21pc2VSZXNvbHZlKHJlc29sdmVWYWx1ZSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGRpZENsb3NlKSB7XG4gICAgLy8gUmVzb2x2ZSBTd2FsIHByb21pc2VcbiAgICBzd2FsUHJvbWlzZVJlc29sdmUocmVzb2x2ZVZhbHVlKTtcbiAgfVxufVxuY29uc3QgdHJpZ2dlckNsb3NlUG9wdXAgPSBpbnN0YW5jZSA9PiB7XG4gIGNvbnN0IHBvcHVwID0gZ2V0UG9wdXAoKTtcbiAgaWYgKCFwb3B1cCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBpbm5lclBhcmFtcyA9IHByaXZhdGVQcm9wcy5pbm5lclBhcmFtcy5nZXQoaW5zdGFuY2UpO1xuICBpZiAoIWlubmVyUGFyYW1zIHx8IGhhc0NsYXNzKHBvcHVwLCBpbm5lclBhcmFtcy5oaWRlQ2xhc3MucG9wdXApKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJlbW92ZUNsYXNzKHBvcHVwLCBpbm5lclBhcmFtcy5zaG93Q2xhc3MucG9wdXApO1xuICBhZGRDbGFzcyhwb3B1cCwgaW5uZXJQYXJhbXMuaGlkZUNsYXNzLnBvcHVwKTtcbiAgY29uc3QgYmFja2Ryb3AgPSBnZXRDb250YWluZXIoKTtcbiAgcmVtb3ZlQ2xhc3MoYmFja2Ryb3AsIGlubmVyUGFyYW1zLnNob3dDbGFzcy5iYWNrZHJvcCk7XG4gIGFkZENsYXNzKGJhY2tkcm9wLCBpbm5lclBhcmFtcy5oaWRlQ2xhc3MuYmFja2Ryb3ApO1xuICBoYW5kbGVQb3B1cEFuaW1hdGlvbihpbnN0YW5jZSwgcG9wdXAsIGlubmVyUGFyYW1zKTtcbiAgcmV0dXJuIHRydWU7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7YW55fSBlcnJvclxuICovXG5mdW5jdGlvbiByZWplY3RQcm9taXNlKGVycm9yKSB7XG4gIGNvbnN0IHJlamVjdFByb21pc2UgPSBwcml2YXRlTWV0aG9kcy5zd2FsUHJvbWlzZVJlamVjdC5nZXQodGhpcyk7XG4gIGhhbmRsZUF3YWl0aW5nUHJvbWlzZSh0aGlzKTtcbiAgaWYgKHJlamVjdFByb21pc2UpIHtcbiAgICAvLyBSZWplY3QgU3dhbCBwcm9taXNlXG4gICAgcmVqZWN0UHJvbWlzZShlcnJvcik7XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge1N3ZWV0QWxlcnR9IGluc3RhbmNlXG4gKi9cbmNvbnN0IGhhbmRsZUF3YWl0aW5nUHJvbWlzZSA9IGluc3RhbmNlID0+IHtcbiAgaWYgKGluc3RhbmNlLmlzQXdhaXRpbmdQcm9taXNlKSB7XG4gICAgZGVsZXRlIGluc3RhbmNlLmlzQXdhaXRpbmdQcm9taXNlO1xuICAgIC8vIFRoZSBpbnN0YW5jZSBtaWdodCBoYXZlIGJlZW4gcHJldmlvdXNseSBwYXJ0bHkgZGVzdHJveWVkLCB3ZSBtdXN0IHJlc3VtZSB0aGUgZGVzdHJveSBwcm9jZXNzIGluIHRoaXMgY2FzZSAjMjMzNVxuICAgIGlmICghcHJpdmF0ZVByb3BzLmlubmVyUGFyYW1zLmdldChpbnN0YW5jZSkpIHtcbiAgICAgIGluc3RhbmNlLl9kZXN0cm95KCk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7YW55fSByZXNvbHZlVmFsdWVcbiAqIEByZXR1cm5zIHtTd2VldEFsZXJ0UmVzdWx0fVxuICovXG5jb25zdCBwcmVwYXJlUmVzb2x2ZVZhbHVlID0gcmVzb2x2ZVZhbHVlID0+IHtcbiAgLy8gV2hlbiB1c2VyIGNhbGxzIFN3YWwuY2xvc2UoKVxuICBpZiAodHlwZW9mIHJlc29sdmVWYWx1ZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaXNDb25maXJtZWQ6IGZhbHNlLFxuICAgICAgaXNEZW5pZWQ6IGZhbHNlLFxuICAgICAgaXNEaXNtaXNzZWQ6IHRydWVcbiAgICB9O1xuICB9XG4gIHJldHVybiBPYmplY3QuYXNzaWduKHtcbiAgICBpc0NvbmZpcm1lZDogZmFsc2UsXG4gICAgaXNEZW5pZWQ6IGZhbHNlLFxuICAgIGlzRGlzbWlzc2VkOiBmYWxzZVxuICB9LCByZXNvbHZlVmFsdWUpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge1N3ZWV0QWxlcnR9IGluc3RhbmNlXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBwb3B1cFxuICogQHBhcmFtIHtTd2VldEFsZXJ0T3B0aW9uc30gaW5uZXJQYXJhbXNcbiAqL1xuY29uc3QgaGFuZGxlUG9wdXBBbmltYXRpb24gPSAoaW5zdGFuY2UsIHBvcHVwLCBpbm5lclBhcmFtcykgPT4ge1xuICBjb25zdCBjb250YWluZXIgPSBnZXRDb250YWluZXIoKTtcbiAgLy8gSWYgYW5pbWF0aW9uIGlzIHN1cHBvcnRlZCwgYW5pbWF0ZVxuICBjb25zdCBhbmltYXRpb25Jc1N1cHBvcnRlZCA9IGFuaW1hdGlvbkVuZEV2ZW50ICYmIGhhc0Nzc0FuaW1hdGlvbihwb3B1cCk7XG4gIGlmICh0eXBlb2YgaW5uZXJQYXJhbXMud2lsbENsb3NlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgaW5uZXJQYXJhbXMud2lsbENsb3NlKHBvcHVwKTtcbiAgfVxuICBnbG9iYWxTdGF0ZS5ldmVudEVtaXR0ZXIuZW1pdCgnd2lsbENsb3NlJywgcG9wdXApO1xuICBpZiAoYW5pbWF0aW9uSXNTdXBwb3J0ZWQpIHtcbiAgICBhbmltYXRlUG9wdXAoaW5zdGFuY2UsIHBvcHVwLCBjb250YWluZXIsIGlubmVyUGFyYW1zLnJldHVybkZvY3VzLCBpbm5lclBhcmFtcy5kaWRDbG9zZSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gT3RoZXJ3aXNlLCByZW1vdmUgaW1tZWRpYXRlbHlcbiAgICByZW1vdmVQb3B1cEFuZFJlc2V0U3RhdGUoaW5zdGFuY2UsIGNvbnRhaW5lciwgaW5uZXJQYXJhbXMucmV0dXJuRm9jdXMsIGlubmVyUGFyYW1zLmRpZENsb3NlKTtcbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge1N3ZWV0QWxlcnR9IGluc3RhbmNlXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBwb3B1cFxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gY29udGFpbmVyXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHJldHVybkZvY3VzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBkaWRDbG9zZVxuICovXG5jb25zdCBhbmltYXRlUG9wdXAgPSAoaW5zdGFuY2UsIHBvcHVwLCBjb250YWluZXIsIHJldHVybkZvY3VzLCBkaWRDbG9zZSkgPT4ge1xuICBpZiAoIWFuaW1hdGlvbkVuZEV2ZW50KSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGdsb2JhbFN0YXRlLnN3YWxDbG9zZUV2ZW50RmluaXNoZWRDYWxsYmFjayA9IHJlbW92ZVBvcHVwQW5kUmVzZXRTdGF0ZS5iaW5kKG51bGwsIGluc3RhbmNlLCBjb250YWluZXIsIHJldHVybkZvY3VzLCBkaWRDbG9zZSk7XG4gIHBvcHVwLmFkZEV2ZW50TGlzdGVuZXIoYW5pbWF0aW9uRW5kRXZlbnQsIGZ1bmN0aW9uIChlKSB7XG4gICAgaWYgKGUudGFyZ2V0ID09PSBwb3B1cCkge1xuICAgICAgZ2xvYmFsU3RhdGUuc3dhbENsb3NlRXZlbnRGaW5pc2hlZENhbGxiYWNrKCk7XG4gICAgICBkZWxldGUgZ2xvYmFsU3RhdGUuc3dhbENsb3NlRXZlbnRGaW5pc2hlZENhbGxiYWNrO1xuICAgIH1cbiAgfSk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7U3dlZXRBbGVydH0gaW5zdGFuY2VcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGRpZENsb3NlXG4gKi9cbmNvbnN0IHRyaWdnZXJEaWRDbG9zZUFuZERpc3Bvc2UgPSAoaW5zdGFuY2UsIGRpZENsb3NlKSA9PiB7XG4gIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgIGlmICh0eXBlb2YgZGlkQ2xvc2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGRpZENsb3NlLmJpbmQoaW5zdGFuY2UucGFyYW1zKSgpO1xuICAgIH1cbiAgICBnbG9iYWxTdGF0ZS5ldmVudEVtaXR0ZXIuZW1pdCgnZGlkQ2xvc2UnKTtcbiAgICAvLyBpbnN0YW5jZSBtaWdodCBoYXZlIGJlZW4gZGVzdHJveWVkIGFscmVhZHlcbiAgICBpZiAoaW5zdGFuY2UuX2Rlc3Ryb3kpIHtcbiAgICAgIGluc3RhbmNlLl9kZXN0cm95KCk7XG4gICAgfVxuICB9KTtcbn07XG5cbi8qKlxuICogU2hvd3MgbG9hZGVyIChzcGlubmVyKSwgdGhpcyBpcyB1c2VmdWwgd2l0aCBBSkFYIHJlcXVlc3RzLlxuICogQnkgZGVmYXVsdCB0aGUgbG9hZGVyIGJlIHNob3duIGluc3RlYWQgb2YgdGhlIFwiQ29uZmlybVwiIGJ1dHRvbi5cbiAqXG4gKiBAcGFyYW0ge0hUTUxCdXR0b25FbGVtZW50IHwgbnVsbH0gW2J1dHRvblRvUmVwbGFjZV1cbiAqL1xuY29uc3Qgc2hvd0xvYWRpbmcgPSBidXR0b25Ub1JlcGxhY2UgPT4ge1xuICBsZXQgcG9wdXAgPSBnZXRQb3B1cCgpO1xuICBpZiAoIXBvcHVwKSB7XG4gICAgbmV3IFN3YWwoKTtcbiAgfVxuICBwb3B1cCA9IGdldFBvcHVwKCk7XG4gIGlmICghcG9wdXApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgbG9hZGVyID0gZ2V0TG9hZGVyKCk7XG4gIGlmIChpc1RvYXN0KCkpIHtcbiAgICBoaWRlKGdldEljb24oKSk7XG4gIH0gZWxzZSB7XG4gICAgcmVwbGFjZUJ1dHRvbihwb3B1cCwgYnV0dG9uVG9SZXBsYWNlKTtcbiAgfVxuICBzaG93KGxvYWRlcik7XG4gIHBvcHVwLnNldEF0dHJpYnV0ZSgnZGF0YS1sb2FkaW5nJywgJ3RydWUnKTtcbiAgcG9wdXAuc2V0QXR0cmlidXRlKCdhcmlhLWJ1c3knLCAndHJ1ZScpO1xuICBwb3B1cC5mb2N1cygpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBwb3B1cFxuICogQHBhcmFtIHtIVE1MQnV0dG9uRWxlbWVudCB8IG51bGx9IFtidXR0b25Ub1JlcGxhY2VdXG4gKi9cbmNvbnN0IHJlcGxhY2VCdXR0b24gPSAocG9wdXAsIGJ1dHRvblRvUmVwbGFjZSkgPT4ge1xuICBjb25zdCBhY3Rpb25zID0gZ2V0QWN0aW9ucygpO1xuICBjb25zdCBsb2FkZXIgPSBnZXRMb2FkZXIoKTtcbiAgaWYgKCFhY3Rpb25zIHx8ICFsb2FkZXIpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKCFidXR0b25Ub1JlcGxhY2UgJiYgaXNWaXNpYmxlJDEoZ2V0Q29uZmlybUJ1dHRvbigpKSkge1xuICAgIGJ1dHRvblRvUmVwbGFjZSA9IGdldENvbmZpcm1CdXR0b24oKTtcbiAgfVxuICBzaG93KGFjdGlvbnMpO1xuICBpZiAoYnV0dG9uVG9SZXBsYWNlKSB7XG4gICAgaGlkZShidXR0b25Ub1JlcGxhY2UpO1xuICAgIGxvYWRlci5zZXRBdHRyaWJ1dGUoJ2RhdGEtYnV0dG9uLXRvLXJlcGxhY2UnLCBidXR0b25Ub1JlcGxhY2UuY2xhc3NOYW1lKTtcbiAgICBhY3Rpb25zLmluc2VydEJlZm9yZShsb2FkZXIsIGJ1dHRvblRvUmVwbGFjZSk7XG4gIH1cbiAgYWRkQ2xhc3MoW3BvcHVwLCBhY3Rpb25zXSwgc3dhbENsYXNzZXMubG9hZGluZyk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7U3dlZXRBbGVydH0gaW5zdGFuY2VcbiAqIEBwYXJhbSB7U3dlZXRBbGVydE9wdGlvbnN9IHBhcmFtc1xuICovXG5jb25zdCBoYW5kbGVJbnB1dE9wdGlvbnNBbmRWYWx1ZSA9IChpbnN0YW5jZSwgcGFyYW1zKSA9PiB7XG4gIGlmIChwYXJhbXMuaW5wdXQgPT09ICdzZWxlY3QnIHx8IHBhcmFtcy5pbnB1dCA9PT0gJ3JhZGlvJykge1xuICAgIGhhbmRsZUlucHV0T3B0aW9ucyhpbnN0YW5jZSwgcGFyYW1zKTtcbiAgfSBlbHNlIGlmIChbJ3RleHQnLCAnZW1haWwnLCAnbnVtYmVyJywgJ3RlbCcsICd0ZXh0YXJlYSddLnNvbWUoaSA9PiBpID09PSBwYXJhbXMuaW5wdXQpICYmIChoYXNUb1Byb21pc2VGbihwYXJhbXMuaW5wdXRWYWx1ZSkgfHwgaXNQcm9taXNlKHBhcmFtcy5pbnB1dFZhbHVlKSkpIHtcbiAgICBzaG93TG9hZGluZyhnZXRDb25maXJtQnV0dG9uKCkpO1xuICAgIGhhbmRsZUlucHV0VmFsdWUoaW5zdGFuY2UsIHBhcmFtcyk7XG4gIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtTd2VldEFsZXJ0fSBpbnN0YW5jZVxuICogQHBhcmFtIHtTd2VldEFsZXJ0T3B0aW9uc30gaW5uZXJQYXJhbXNcbiAqIEByZXR1cm5zIHtTd2VldEFsZXJ0SW5wdXRWYWx1ZX1cbiAqL1xuY29uc3QgZ2V0SW5wdXRWYWx1ZSA9IChpbnN0YW5jZSwgaW5uZXJQYXJhbXMpID0+IHtcbiAgY29uc3QgaW5wdXQgPSBpbnN0YW5jZS5nZXRJbnB1dCgpO1xuICBpZiAoIWlucHV0KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgc3dpdGNoIChpbm5lclBhcmFtcy5pbnB1dCkge1xuICAgIGNhc2UgJ2NoZWNrYm94JzpcbiAgICAgIHJldHVybiBnZXRDaGVja2JveFZhbHVlKGlucHV0KTtcbiAgICBjYXNlICdyYWRpbyc6XG4gICAgICByZXR1cm4gZ2V0UmFkaW9WYWx1ZShpbnB1dCk7XG4gICAgY2FzZSAnZmlsZSc6XG4gICAgICByZXR1cm4gZ2V0RmlsZVZhbHVlKGlucHV0KTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGlubmVyUGFyYW1zLmlucHV0QXV0b1RyaW0gPyBpbnB1dC52YWx1ZS50cmltKCkgOiBpbnB1dC52YWx1ZTtcbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge0hUTUxJbnB1dEVsZW1lbnR9IGlucHV0XG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5jb25zdCBnZXRDaGVja2JveFZhbHVlID0gaW5wdXQgPT4gaW5wdXQuY2hlY2tlZCA/IDEgOiAwO1xuXG4vKipcbiAqIEBwYXJhbSB7SFRNTElucHV0RWxlbWVudH0gaW5wdXRcbiAqIEByZXR1cm5zIHtzdHJpbmcgfCBudWxsfVxuICovXG5jb25zdCBnZXRSYWRpb1ZhbHVlID0gaW5wdXQgPT4gaW5wdXQuY2hlY2tlZCA/IGlucHV0LnZhbHVlIDogbnVsbDtcblxuLyoqXG4gKiBAcGFyYW0ge0hUTUxJbnB1dEVsZW1lbnR9IGlucHV0XG4gKiBAcmV0dXJucyB7RmlsZUxpc3QgfCBGaWxlIHwgbnVsbH1cbiAqL1xuY29uc3QgZ2V0RmlsZVZhbHVlID0gaW5wdXQgPT4gaW5wdXQuZmlsZXMgJiYgaW5wdXQuZmlsZXMubGVuZ3RoID8gaW5wdXQuZ2V0QXR0cmlidXRlKCdtdWx0aXBsZScpICE9PSBudWxsID8gaW5wdXQuZmlsZXMgOiBpbnB1dC5maWxlc1swXSA6IG51bGw7XG5cbi8qKlxuICogQHBhcmFtIHtTd2VldEFsZXJ0fSBpbnN0YW5jZVxuICogQHBhcmFtIHtTd2VldEFsZXJ0T3B0aW9uc30gcGFyYW1zXG4gKi9cbmNvbnN0IGhhbmRsZUlucHV0T3B0aW9ucyA9IChpbnN0YW5jZSwgcGFyYW1zKSA9PiB7XG4gIGNvbnN0IHBvcHVwID0gZ2V0UG9wdXAoKTtcbiAgaWYgKCFwb3B1cCkge1xuICAgIHJldHVybjtcbiAgfVxuICAvKipcbiAgICogQHBhcmFtIHtSZWNvcmQ8c3RyaW5nLCBhbnk+fSBpbnB1dE9wdGlvbnNcbiAgICovXG4gIGNvbnN0IHByb2Nlc3NJbnB1dE9wdGlvbnMgPSBpbnB1dE9wdGlvbnMgPT4ge1xuICAgIGlmIChwYXJhbXMuaW5wdXQgPT09ICdzZWxlY3QnKSB7XG4gICAgICBwb3B1bGF0ZVNlbGVjdE9wdGlvbnMocG9wdXAsIGZvcm1hdElucHV0T3B0aW9ucyhpbnB1dE9wdGlvbnMpLCBwYXJhbXMpO1xuICAgIH0gZWxzZSBpZiAocGFyYW1zLmlucHV0ID09PSAncmFkaW8nKSB7XG4gICAgICBwb3B1bGF0ZVJhZGlvT3B0aW9ucyhwb3B1cCwgZm9ybWF0SW5wdXRPcHRpb25zKGlucHV0T3B0aW9ucyksIHBhcmFtcyk7XG4gICAgfVxuICB9O1xuICBpZiAoaGFzVG9Qcm9taXNlRm4ocGFyYW1zLmlucHV0T3B0aW9ucykgfHwgaXNQcm9taXNlKHBhcmFtcy5pbnB1dE9wdGlvbnMpKSB7XG4gICAgc2hvd0xvYWRpbmcoZ2V0Q29uZmlybUJ1dHRvbigpKTtcbiAgICBhc1Byb21pc2UocGFyYW1zLmlucHV0T3B0aW9ucykudGhlbihpbnB1dE9wdGlvbnMgPT4ge1xuICAgICAgaW5zdGFuY2UuaGlkZUxvYWRpbmcoKTtcbiAgICAgIHByb2Nlc3NJbnB1dE9wdGlvbnMoaW5wdXRPcHRpb25zKTtcbiAgICB9KTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgcGFyYW1zLmlucHV0T3B0aW9ucyA9PT0gJ29iamVjdCcpIHtcbiAgICBwcm9jZXNzSW5wdXRPcHRpb25zKHBhcmFtcy5pbnB1dE9wdGlvbnMpO1xuICB9IGVsc2Uge1xuICAgIGVycm9yKGBVbmV4cGVjdGVkIHR5cGUgb2YgaW5wdXRPcHRpb25zISBFeHBlY3RlZCBvYmplY3QsIE1hcCBvciBQcm9taXNlLCBnb3QgJHt0eXBlb2YgcGFyYW1zLmlucHV0T3B0aW9uc31gKTtcbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge1N3ZWV0QWxlcnR9IGluc3RhbmNlXG4gKiBAcGFyYW0ge1N3ZWV0QWxlcnRPcHRpb25zfSBwYXJhbXNcbiAqL1xuY29uc3QgaGFuZGxlSW5wdXRWYWx1ZSA9IChpbnN0YW5jZSwgcGFyYW1zKSA9PiB7XG4gIGNvbnN0IGlucHV0ID0gaW5zdGFuY2UuZ2V0SW5wdXQoKTtcbiAgaWYgKCFpbnB1dCkge1xuICAgIHJldHVybjtcbiAgfVxuICBoaWRlKGlucHV0KTtcbiAgYXNQcm9taXNlKHBhcmFtcy5pbnB1dFZhbHVlKS50aGVuKGlucHV0VmFsdWUgPT4ge1xuICAgIGlucHV0LnZhbHVlID0gcGFyYW1zLmlucHV0ID09PSAnbnVtYmVyJyA/IGAke3BhcnNlRmxvYXQoaW5wdXRWYWx1ZSkgfHwgMH1gIDogYCR7aW5wdXRWYWx1ZX1gO1xuICAgIHNob3coaW5wdXQpO1xuICAgIGlucHV0LmZvY3VzKCk7XG4gICAgaW5zdGFuY2UuaGlkZUxvYWRpbmcoKTtcbiAgfSkuY2F0Y2goZXJyID0+IHtcbiAgICBlcnJvcihgRXJyb3IgaW4gaW5wdXRWYWx1ZSBwcm9taXNlOiAke2Vycn1gKTtcbiAgICBpbnB1dC52YWx1ZSA9ICcnO1xuICAgIHNob3coaW5wdXQpO1xuICAgIGlucHV0LmZvY3VzKCk7XG4gICAgaW5zdGFuY2UuaGlkZUxvYWRpbmcoKTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHBvcHVwXG4gKiBAcGFyYW0ge0lucHV0T3B0aW9uRmxhdHRlbmVkW119IGlucHV0T3B0aW9uc1xuICogQHBhcmFtIHtTd2VldEFsZXJ0T3B0aW9uc30gcGFyYW1zXG4gKi9cbmZ1bmN0aW9uIHBvcHVsYXRlU2VsZWN0T3B0aW9ucyhwb3B1cCwgaW5wdXRPcHRpb25zLCBwYXJhbXMpIHtcbiAgY29uc3Qgc2VsZWN0ID0gZ2V0RGlyZWN0Q2hpbGRCeUNsYXNzKHBvcHVwLCBzd2FsQ2xhc3Nlcy5zZWxlY3QpO1xuICBpZiAoIXNlbGVjdCkge1xuICAgIHJldHVybjtcbiAgfVxuICAvKipcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gcGFyZW50XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25MYWJlbFxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9uVmFsdWVcbiAgICovXG4gIGNvbnN0IHJlbmRlck9wdGlvbiA9IChwYXJlbnQsIG9wdGlvbkxhYmVsLCBvcHRpb25WYWx1ZSkgPT4ge1xuICAgIGNvbnN0IG9wdGlvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ29wdGlvbicpO1xuICAgIG9wdGlvbi52YWx1ZSA9IG9wdGlvblZhbHVlO1xuICAgIHNldElubmVySHRtbChvcHRpb24sIG9wdGlvbkxhYmVsKTtcbiAgICBvcHRpb24uc2VsZWN0ZWQgPSBpc1NlbGVjdGVkKG9wdGlvblZhbHVlLCBwYXJhbXMuaW5wdXRWYWx1ZSk7XG4gICAgcGFyZW50LmFwcGVuZENoaWxkKG9wdGlvbik7XG4gIH07XG4gIGlucHV0T3B0aW9ucy5mb3JFYWNoKGlucHV0T3B0aW9uID0+IHtcbiAgICBjb25zdCBvcHRpb25WYWx1ZSA9IGlucHV0T3B0aW9uWzBdO1xuICAgIGNvbnN0IG9wdGlvbkxhYmVsID0gaW5wdXRPcHRpb25bMV07XG4gICAgLy8gPG9wdGdyb3VwPiBzcGVjOlxuICAgIC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9odG1sNDAxL2ludGVyYWN0L2Zvcm1zLmh0bWwjaC0xNy42XG4gICAgLy8gXCIuLi5hbGwgT1BUR1JPVVAgZWxlbWVudHMgbXVzdCBiZSBzcGVjaWZpZWQgZGlyZWN0bHkgd2l0aGluIGEgU0VMRUNUIGVsZW1lbnQgKGkuZS4sIGdyb3VwcyBtYXkgbm90IGJlIG5lc3RlZCkuLi5cIlxuICAgIC8vIGNoZWNrIHdoZXRoZXIgdGhpcyBpcyBhIDxvcHRncm91cD5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShvcHRpb25MYWJlbCkpIHtcbiAgICAgIC8vIGlmIGl0IGlzIGFuIGFycmF5LCB0aGVuIGl0IGlzIGFuIDxvcHRncm91cD5cbiAgICAgIGNvbnN0IG9wdGdyb3VwID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnb3B0Z3JvdXAnKTtcbiAgICAgIG9wdGdyb3VwLmxhYmVsID0gb3B0aW9uVmFsdWU7XG4gICAgICBvcHRncm91cC5kaXNhYmxlZCA9IGZhbHNlOyAvLyBub3QgY29uZmlndXJhYmxlIGZvciBub3dcbiAgICAgIHNlbGVjdC5hcHBlbmRDaGlsZChvcHRncm91cCk7XG4gICAgICBvcHRpb25MYWJlbC5mb3JFYWNoKG8gPT4gcmVuZGVyT3B0aW9uKG9wdGdyb3VwLCBvWzFdLCBvWzBdKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGNhc2Ugb2YgPG9wdGlvbj5cbiAgICAgIHJlbmRlck9wdGlvbihzZWxlY3QsIG9wdGlvbkxhYmVsLCBvcHRpb25WYWx1ZSk7XG4gICAgfVxuICB9KTtcbiAgc2VsZWN0LmZvY3VzKCk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gcG9wdXBcbiAqIEBwYXJhbSB7SW5wdXRPcHRpb25GbGF0dGVuZWRbXX0gaW5wdXRPcHRpb25zXG4gKiBAcGFyYW0ge1N3ZWV0QWxlcnRPcHRpb25zfSBwYXJhbXNcbiAqL1xuZnVuY3Rpb24gcG9wdWxhdGVSYWRpb09wdGlvbnMocG9wdXAsIGlucHV0T3B0aW9ucywgcGFyYW1zKSB7XG4gIGNvbnN0IHJhZGlvID0gZ2V0RGlyZWN0Q2hpbGRCeUNsYXNzKHBvcHVwLCBzd2FsQ2xhc3Nlcy5yYWRpbyk7XG4gIGlmICghcmFkaW8pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaW5wdXRPcHRpb25zLmZvckVhY2goaW5wdXRPcHRpb24gPT4ge1xuICAgIGNvbnN0IHJhZGlvVmFsdWUgPSBpbnB1dE9wdGlvblswXTtcbiAgICBjb25zdCByYWRpb0xhYmVsID0gaW5wdXRPcHRpb25bMV07XG4gICAgY29uc3QgcmFkaW9JbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0Jyk7XG4gICAgY29uc3QgcmFkaW9MYWJlbEVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsYWJlbCcpO1xuICAgIHJhZGlvSW5wdXQudHlwZSA9ICdyYWRpbyc7XG4gICAgcmFkaW9JbnB1dC5uYW1lID0gc3dhbENsYXNzZXMucmFkaW87XG4gICAgcmFkaW9JbnB1dC52YWx1ZSA9IHJhZGlvVmFsdWU7XG4gICAgaWYgKGlzU2VsZWN0ZWQocmFkaW9WYWx1ZSwgcGFyYW1zLmlucHV0VmFsdWUpKSB7XG4gICAgICByYWRpb0lucHV0LmNoZWNrZWQgPSB0cnVlO1xuICAgIH1cbiAgICBjb25zdCBsYWJlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICBzZXRJbm5lckh0bWwobGFiZWwsIHJhZGlvTGFiZWwpO1xuICAgIGxhYmVsLmNsYXNzTmFtZSA9IHN3YWxDbGFzc2VzLmxhYmVsO1xuICAgIHJhZGlvTGFiZWxFbGVtZW50LmFwcGVuZENoaWxkKHJhZGlvSW5wdXQpO1xuICAgIHJhZGlvTGFiZWxFbGVtZW50LmFwcGVuZENoaWxkKGxhYmVsKTtcbiAgICByYWRpby5hcHBlbmRDaGlsZChyYWRpb0xhYmVsRWxlbWVudCk7XG4gIH0pO1xuICBjb25zdCByYWRpb3MgPSByYWRpby5xdWVyeVNlbGVjdG9yQWxsKCdpbnB1dCcpO1xuICBpZiAocmFkaW9zLmxlbmd0aCkge1xuICAgIHJhZGlvc1swXS5mb2N1cygpO1xuICB9XG59XG5cbi8qKlxuICogQ29udmVydHMgYGlucHV0T3B0aW9uc2AgaW50byBhbiBhcnJheSBvZiBgW3ZhbHVlLCBsYWJlbF1gc1xuICpcbiAqIEBwYXJhbSB7UmVjb3JkPHN0cmluZywgYW55Pn0gaW5wdXRPcHRpb25zXG4gKiBAdHlwZWRlZiB7c3RyaW5nW119IElucHV0T3B0aW9uRmxhdHRlbmVkXG4gKiBAcmV0dXJucyB7SW5wdXRPcHRpb25GbGF0dGVuZWRbXX1cbiAqL1xuY29uc3QgZm9ybWF0SW5wdXRPcHRpb25zID0gaW5wdXRPcHRpb25zID0+IHtcbiAgLyoqIEB0eXBlIHtJbnB1dE9wdGlvbkZsYXR0ZW5lZFtdfSAqL1xuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgaWYgKGlucHV0T3B0aW9ucyBpbnN0YW5jZW9mIE1hcCkge1xuICAgIGlucHV0T3B0aW9ucy5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICBsZXQgdmFsdWVGb3JtYXR0ZWQgPSB2YWx1ZTtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWVGb3JtYXR0ZWQgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIC8vIGNhc2Ugb2YgPG9wdGdyb3VwPlxuICAgICAgICB2YWx1ZUZvcm1hdHRlZCA9IGZvcm1hdElucHV0T3B0aW9ucyh2YWx1ZUZvcm1hdHRlZCk7XG4gICAgICB9XG4gICAgICByZXN1bHQucHVzaChba2V5LCB2YWx1ZUZvcm1hdHRlZF0pO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIE9iamVjdC5rZXlzKGlucHV0T3B0aW9ucykuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgbGV0IHZhbHVlRm9ybWF0dGVkID0gaW5wdXRPcHRpb25zW2tleV07XG4gICAgICBpZiAodHlwZW9mIHZhbHVlRm9ybWF0dGVkID09PSAnb2JqZWN0Jykge1xuICAgICAgICAvLyBjYXNlIG9mIDxvcHRncm91cD5cbiAgICAgICAgdmFsdWVGb3JtYXR0ZWQgPSBmb3JtYXRJbnB1dE9wdGlvbnModmFsdWVGb3JtYXR0ZWQpO1xuICAgICAgfVxuICAgICAgcmVzdWx0LnB1c2goW2tleSwgdmFsdWVGb3JtYXR0ZWRdKTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9uVmFsdWVcbiAqIEBwYXJhbSB7U3dlZXRBbGVydElucHV0VmFsdWV9IGlucHV0VmFsdWVcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5jb25zdCBpc1NlbGVjdGVkID0gKG9wdGlvblZhbHVlLCBpbnB1dFZhbHVlKSA9PiB7XG4gIHJldHVybiAhIWlucHV0VmFsdWUgJiYgaW5wdXRWYWx1ZS50b1N0cmluZygpID09PSBvcHRpb25WYWx1ZS50b1N0cmluZygpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge1N3ZWV0QWxlcnR9IGluc3RhbmNlXG4gKi9cbmNvbnN0IGhhbmRsZUNvbmZpcm1CdXR0b25DbGljayA9IGluc3RhbmNlID0+IHtcbiAgY29uc3QgaW5uZXJQYXJhbXMgPSBwcml2YXRlUHJvcHMuaW5uZXJQYXJhbXMuZ2V0KGluc3RhbmNlKTtcbiAgaW5zdGFuY2UuZGlzYWJsZUJ1dHRvbnMoKTtcbiAgaWYgKGlubmVyUGFyYW1zLmlucHV0KSB7XG4gICAgaGFuZGxlQ29uZmlybU9yRGVueVdpdGhJbnB1dChpbnN0YW5jZSwgJ2NvbmZpcm0nKTtcbiAgfSBlbHNlIHtcbiAgICBjb25maXJtKGluc3RhbmNlLCB0cnVlKTtcbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge1N3ZWV0QWxlcnR9IGluc3RhbmNlXG4gKi9cbmNvbnN0IGhhbmRsZURlbnlCdXR0b25DbGljayA9IGluc3RhbmNlID0+IHtcbiAgY29uc3QgaW5uZXJQYXJhbXMgPSBwcml2YXRlUHJvcHMuaW5uZXJQYXJhbXMuZ2V0KGluc3RhbmNlKTtcbiAgaW5zdGFuY2UuZGlzYWJsZUJ1dHRvbnMoKTtcbiAgaWYgKGlubmVyUGFyYW1zLnJldHVybklucHV0VmFsdWVPbkRlbnkpIHtcbiAgICBoYW5kbGVDb25maXJtT3JEZW55V2l0aElucHV0KGluc3RhbmNlLCAnZGVueScpO1xuICB9IGVsc2Uge1xuICAgIGRlbnkoaW5zdGFuY2UsIGZhbHNlKTtcbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge1N3ZWV0QWxlcnR9IGluc3RhbmNlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBkaXNtaXNzV2l0aFxuICovXG5jb25zdCBoYW5kbGVDYW5jZWxCdXR0b25DbGljayA9IChpbnN0YW5jZSwgZGlzbWlzc1dpdGgpID0+IHtcbiAgaW5zdGFuY2UuZGlzYWJsZUJ1dHRvbnMoKTtcbiAgZGlzbWlzc1dpdGgoRGlzbWlzc1JlYXNvbi5jYW5jZWwpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge1N3ZWV0QWxlcnR9IGluc3RhbmNlXG4gKiBAcGFyYW0geydjb25maXJtJyB8ICdkZW55J30gdHlwZVxuICovXG5jb25zdCBoYW5kbGVDb25maXJtT3JEZW55V2l0aElucHV0ID0gKGluc3RhbmNlLCB0eXBlKSA9PiB7XG4gIGNvbnN0IGlubmVyUGFyYW1zID0gcHJpdmF0ZVByb3BzLmlubmVyUGFyYW1zLmdldChpbnN0YW5jZSk7XG4gIGlmICghaW5uZXJQYXJhbXMuaW5wdXQpIHtcbiAgICBlcnJvcihgVGhlIFwiaW5wdXRcIiBwYXJhbWV0ZXIgaXMgbmVlZGVkIHRvIGJlIHNldCB3aGVuIHVzaW5nIHJldHVybklucHV0VmFsdWVPbiR7Y2FwaXRhbGl6ZUZpcnN0TGV0dGVyKHR5cGUpfWApO1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBpbnB1dCA9IGluc3RhbmNlLmdldElucHV0KCk7XG4gIGNvbnN0IGlucHV0VmFsdWUgPSBnZXRJbnB1dFZhbHVlKGluc3RhbmNlLCBpbm5lclBhcmFtcyk7XG4gIGlmIChpbm5lclBhcmFtcy5pbnB1dFZhbGlkYXRvcikge1xuICAgIGhhbmRsZUlucHV0VmFsaWRhdG9yKGluc3RhbmNlLCBpbnB1dFZhbHVlLCB0eXBlKTtcbiAgfSBlbHNlIGlmIChpbnB1dCAmJiAhaW5wdXQuY2hlY2tWYWxpZGl0eSgpKSB7XG4gICAgaW5zdGFuY2UuZW5hYmxlQnV0dG9ucygpO1xuICAgIGluc3RhbmNlLnNob3dWYWxpZGF0aW9uTWVzc2FnZShpbm5lclBhcmFtcy52YWxpZGF0aW9uTWVzc2FnZSB8fCBpbnB1dC52YWxpZGF0aW9uTWVzc2FnZSk7XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gJ2RlbnknKSB7XG4gICAgZGVueShpbnN0YW5jZSwgaW5wdXRWYWx1ZSk7XG4gIH0gZWxzZSB7XG4gICAgY29uZmlybShpbnN0YW5jZSwgaW5wdXRWYWx1ZSk7XG4gIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtTd2VldEFsZXJ0fSBpbnN0YW5jZVxuICogQHBhcmFtIHtTd2VldEFsZXJ0SW5wdXRWYWx1ZX0gaW5wdXRWYWx1ZVxuICogQHBhcmFtIHsnY29uZmlybScgfCAnZGVueSd9IHR5cGVcbiAqL1xuY29uc3QgaGFuZGxlSW5wdXRWYWxpZGF0b3IgPSAoaW5zdGFuY2UsIGlucHV0VmFsdWUsIHR5cGUpID0+IHtcbiAgY29uc3QgaW5uZXJQYXJhbXMgPSBwcml2YXRlUHJvcHMuaW5uZXJQYXJhbXMuZ2V0KGluc3RhbmNlKTtcbiAgaW5zdGFuY2UuZGlzYWJsZUlucHV0KCk7XG4gIGNvbnN0IHZhbGlkYXRpb25Qcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKSA9PiBhc1Byb21pc2UoaW5uZXJQYXJhbXMuaW5wdXRWYWxpZGF0b3IoaW5wdXRWYWx1ZSwgaW5uZXJQYXJhbXMudmFsaWRhdGlvbk1lc3NhZ2UpKSk7XG4gIHZhbGlkYXRpb25Qcm9taXNlLnRoZW4odmFsaWRhdGlvbk1lc3NhZ2UgPT4ge1xuICAgIGluc3RhbmNlLmVuYWJsZUJ1dHRvbnMoKTtcbiAgICBpbnN0YW5jZS5lbmFibGVJbnB1dCgpO1xuICAgIGlmICh2YWxpZGF0aW9uTWVzc2FnZSkge1xuICAgICAgaW5zdGFuY2Uuc2hvd1ZhbGlkYXRpb25NZXNzYWdlKHZhbGlkYXRpb25NZXNzYWdlKTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdkZW55Jykge1xuICAgICAgZGVueShpbnN0YW5jZSwgaW5wdXRWYWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbmZpcm0oaW5zdGFuY2UsIGlucHV0VmFsdWUpO1xuICAgIH1cbiAgfSk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7U3dlZXRBbGVydH0gaW5zdGFuY2VcbiAqIEBwYXJhbSB7YW55fSB2YWx1ZVxuICovXG5jb25zdCBkZW55ID0gKGluc3RhbmNlLCB2YWx1ZSkgPT4ge1xuICBjb25zdCBpbm5lclBhcmFtcyA9IHByaXZhdGVQcm9wcy5pbm5lclBhcmFtcy5nZXQoaW5zdGFuY2UgfHwgdW5kZWZpbmVkKTtcbiAgaWYgKGlubmVyUGFyYW1zLnNob3dMb2FkZXJPbkRlbnkpIHtcbiAgICBzaG93TG9hZGluZyhnZXREZW55QnV0dG9uKCkpO1xuICB9XG4gIGlmIChpbm5lclBhcmFtcy5wcmVEZW55KSB7XG4gICAgaW5zdGFuY2UuaXNBd2FpdGluZ1Byb21pc2UgPSB0cnVlOyAvLyBGbGFnZ2luZyB0aGUgaW5zdGFuY2UgYXMgYXdhaXRpbmcgYSBwcm9taXNlIHNvIGl0J3Mgb3duIHByb21pc2UncyByZWplY3QvcmVzb2x2ZSBtZXRob2RzIGRvZXNuJ3QgZ2V0IGRlc3Ryb3llZCB1bnRpbCB0aGUgcmVzdWx0IGZyb20gdGhpcyBwcmVEZW55J3MgcHJvbWlzZSBpcyByZWNlaXZlZFxuICAgIGNvbnN0IHByZURlbnlQcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKSA9PiBhc1Byb21pc2UoaW5uZXJQYXJhbXMucHJlRGVueSh2YWx1ZSwgaW5uZXJQYXJhbXMudmFsaWRhdGlvbk1lc3NhZ2UpKSk7XG4gICAgcHJlRGVueVByb21pc2UudGhlbihwcmVEZW55VmFsdWUgPT4ge1xuICAgICAgaWYgKHByZURlbnlWYWx1ZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgaW5zdGFuY2UuaGlkZUxvYWRpbmcoKTtcbiAgICAgICAgaGFuZGxlQXdhaXRpbmdQcm9taXNlKGluc3RhbmNlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGluc3RhbmNlLmNsb3NlKHtcbiAgICAgICAgICBpc0RlbmllZDogdHJ1ZSxcbiAgICAgICAgICB2YWx1ZTogdHlwZW9mIHByZURlbnlWYWx1ZSA9PT0gJ3VuZGVmaW5lZCcgPyB2YWx1ZSA6IHByZURlbnlWYWx1ZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KS5jYXRjaChlcnJvciA9PiByZWplY3RXaXRoKGluc3RhbmNlIHx8IHVuZGVmaW5lZCwgZXJyb3IpKTtcbiAgfSBlbHNlIHtcbiAgICBpbnN0YW5jZS5jbG9zZSh7XG4gICAgICBpc0RlbmllZDogdHJ1ZSxcbiAgICAgIHZhbHVlXG4gICAgfSk7XG4gIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtTd2VldEFsZXJ0fSBpbnN0YW5jZVxuICogQHBhcmFtIHthbnl9IHZhbHVlXG4gKi9cbmNvbnN0IHN1Y2NlZWRXaXRoID0gKGluc3RhbmNlLCB2YWx1ZSkgPT4ge1xuICBpbnN0YW5jZS5jbG9zZSh7XG4gICAgaXNDb25maXJtZWQ6IHRydWUsXG4gICAgdmFsdWVcbiAgfSk7XG59O1xuXG4vKipcbiAqXG4gKiBAcGFyYW0ge1N3ZWV0QWxlcnR9IGluc3RhbmNlXG4gKiBAcGFyYW0ge3N0cmluZ30gZXJyb3JcbiAqL1xuY29uc3QgcmVqZWN0V2l0aCA9IChpbnN0YW5jZSwgZXJyb3IpID0+IHtcbiAgaW5zdGFuY2UucmVqZWN0UHJvbWlzZShlcnJvcik7XG59O1xuXG4vKipcbiAqXG4gKiBAcGFyYW0ge1N3ZWV0QWxlcnR9IGluc3RhbmNlXG4gKiBAcGFyYW0ge2FueX0gdmFsdWVcbiAqL1xuY29uc3QgY29uZmlybSA9IChpbnN0YW5jZSwgdmFsdWUpID0+IHtcbiAgY29uc3QgaW5uZXJQYXJhbXMgPSBwcml2YXRlUHJvcHMuaW5uZXJQYXJhbXMuZ2V0KGluc3RhbmNlIHx8IHVuZGVmaW5lZCk7XG4gIGlmIChpbm5lclBhcmFtcy5zaG93TG9hZGVyT25Db25maXJtKSB7XG4gICAgc2hvd0xvYWRpbmcoKTtcbiAgfVxuICBpZiAoaW5uZXJQYXJhbXMucHJlQ29uZmlybSkge1xuICAgIGluc3RhbmNlLnJlc2V0VmFsaWRhdGlvbk1lc3NhZ2UoKTtcbiAgICBpbnN0YW5jZS5pc0F3YWl0aW5nUHJvbWlzZSA9IHRydWU7IC8vIEZsYWdnaW5nIHRoZSBpbnN0YW5jZSBhcyBhd2FpdGluZyBhIHByb21pc2Ugc28gaXQncyBvd24gcHJvbWlzZSdzIHJlamVjdC9yZXNvbHZlIG1ldGhvZHMgZG9lc24ndCBnZXQgZGVzdHJveWVkIHVudGlsIHRoZSByZXN1bHQgZnJvbSB0aGlzIHByZUNvbmZpcm0ncyBwcm9taXNlIGlzIHJlY2VpdmVkXG4gICAgY29uc3QgcHJlQ29uZmlybVByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IGFzUHJvbWlzZShpbm5lclBhcmFtcy5wcmVDb25maXJtKHZhbHVlLCBpbm5lclBhcmFtcy52YWxpZGF0aW9uTWVzc2FnZSkpKTtcbiAgICBwcmVDb25maXJtUHJvbWlzZS50aGVuKHByZUNvbmZpcm1WYWx1ZSA9PiB7XG4gICAgICBpZiAoaXNWaXNpYmxlJDEoZ2V0VmFsaWRhdGlvbk1lc3NhZ2UoKSkgfHwgcHJlQ29uZmlybVZhbHVlID09PSBmYWxzZSkge1xuICAgICAgICBpbnN0YW5jZS5oaWRlTG9hZGluZygpO1xuICAgICAgICBoYW5kbGVBd2FpdGluZ1Byb21pc2UoaW5zdGFuY2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3VjY2VlZFdpdGgoaW5zdGFuY2UsIHR5cGVvZiBwcmVDb25maXJtVmFsdWUgPT09ICd1bmRlZmluZWQnID8gdmFsdWUgOiBwcmVDb25maXJtVmFsdWUpO1xuICAgICAgfVxuICAgIH0pLmNhdGNoKGVycm9yID0+IHJlamVjdFdpdGgoaW5zdGFuY2UgfHwgdW5kZWZpbmVkLCBlcnJvcikpO1xuICB9IGVsc2Uge1xuICAgIHN1Y2NlZWRXaXRoKGluc3RhbmNlLCB2YWx1ZSk7XG4gIH1cbn07XG5cbi8qKlxuICogSGlkZXMgbG9hZGVyIGFuZCBzaG93cyBiYWNrIHRoZSBidXR0b24gd2hpY2ggd2FzIGhpZGRlbiBieSAuc2hvd0xvYWRpbmcoKVxuICovXG5mdW5jdGlvbiBoaWRlTG9hZGluZygpIHtcbiAgLy8gZG8gbm90aGluZyBpZiBwb3B1cCBpcyBjbG9zZWRcbiAgY29uc3QgaW5uZXJQYXJhbXMgPSBwcml2YXRlUHJvcHMuaW5uZXJQYXJhbXMuZ2V0KHRoaXMpO1xuICBpZiAoIWlubmVyUGFyYW1zKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGRvbUNhY2hlID0gcHJpdmF0ZVByb3BzLmRvbUNhY2hlLmdldCh0aGlzKTtcbiAgaGlkZShkb21DYWNoZS5sb2FkZXIpO1xuICBpZiAoaXNUb2FzdCgpKSB7XG4gICAgaWYgKGlubmVyUGFyYW1zLmljb24pIHtcbiAgICAgIHNob3coZ2V0SWNvbigpKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgc2hvd1JlbGF0ZWRCdXR0b24oZG9tQ2FjaGUpO1xuICB9XG4gIHJlbW92ZUNsYXNzKFtkb21DYWNoZS5wb3B1cCwgZG9tQ2FjaGUuYWN0aW9uc10sIHN3YWxDbGFzc2VzLmxvYWRpbmcpO1xuICBkb21DYWNoZS5wb3B1cC5yZW1vdmVBdHRyaWJ1dGUoJ2FyaWEtYnVzeScpO1xuICBkb21DYWNoZS5wb3B1cC5yZW1vdmVBdHRyaWJ1dGUoJ2RhdGEtbG9hZGluZycpO1xuICBkb21DYWNoZS5jb25maXJtQnV0dG9uLmRpc2FibGVkID0gZmFsc2U7XG4gIGRvbUNhY2hlLmRlbnlCdXR0b24uZGlzYWJsZWQgPSBmYWxzZTtcbiAgZG9tQ2FjaGUuY2FuY2VsQnV0dG9uLmRpc2FibGVkID0gZmFsc2U7XG59XG5jb25zdCBzaG93UmVsYXRlZEJ1dHRvbiA9IGRvbUNhY2hlID0+IHtcbiAgY29uc3QgYnV0dG9uVG9SZXBsYWNlID0gZG9tQ2FjaGUucG9wdXAuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShkb21DYWNoZS5sb2FkZXIuZ2V0QXR0cmlidXRlKCdkYXRhLWJ1dHRvbi10by1yZXBsYWNlJykpO1xuICBpZiAoYnV0dG9uVG9SZXBsYWNlLmxlbmd0aCkge1xuICAgIHNob3coYnV0dG9uVG9SZXBsYWNlWzBdLCAnaW5saW5lLWJsb2NrJyk7XG4gIH0gZWxzZSBpZiAoYWxsQnV0dG9uc0FyZUhpZGRlbigpKSB7XG4gICAgaGlkZShkb21DYWNoZS5hY3Rpb25zKTtcbiAgfVxufTtcblxuLyoqXG4gKiBHZXRzIHRoZSBpbnB1dCBET00gbm9kZSwgdGhpcyBtZXRob2Qgd29ya3Mgd2l0aCBpbnB1dCBwYXJhbWV0ZXIuXG4gKlxuICogQHJldHVybnMge0hUTUxJbnB1dEVsZW1lbnQgfCBudWxsfVxuICovXG5mdW5jdGlvbiBnZXRJbnB1dCgpIHtcbiAgY29uc3QgaW5uZXJQYXJhbXMgPSBwcml2YXRlUHJvcHMuaW5uZXJQYXJhbXMuZ2V0KHRoaXMpO1xuICBjb25zdCBkb21DYWNoZSA9IHByaXZhdGVQcm9wcy5kb21DYWNoZS5nZXQodGhpcyk7XG4gIGlmICghZG9tQ2FjaGUpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gZ2V0SW5wdXQkMShkb21DYWNoZS5wb3B1cCwgaW5uZXJQYXJhbXMuaW5wdXQpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7U3dlZXRBbGVydH0gaW5zdGFuY2VcbiAqIEBwYXJhbSB7c3RyaW5nW119IGJ1dHRvbnNcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gZGlzYWJsZWRcbiAqL1xuZnVuY3Rpb24gc2V0QnV0dG9uc0Rpc2FibGVkKGluc3RhbmNlLCBidXR0b25zLCBkaXNhYmxlZCkge1xuICBjb25zdCBkb21DYWNoZSA9IHByaXZhdGVQcm9wcy5kb21DYWNoZS5nZXQoaW5zdGFuY2UpO1xuICBidXR0b25zLmZvckVhY2goYnV0dG9uID0+IHtcbiAgICBkb21DYWNoZVtidXR0b25dLmRpc2FibGVkID0gZGlzYWJsZWQ7XG4gIH0pO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7SFRNTElucHV0RWxlbWVudCB8IG51bGx9IGlucHV0XG4gKiBAcGFyYW0ge2Jvb2xlYW59IGRpc2FibGVkXG4gKi9cbmZ1bmN0aW9uIHNldElucHV0RGlzYWJsZWQoaW5wdXQsIGRpc2FibGVkKSB7XG4gIGNvbnN0IHBvcHVwID0gZ2V0UG9wdXAoKTtcbiAgaWYgKCFwb3B1cCB8fCAhaW5wdXQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKGlucHV0LnR5cGUgPT09ICdyYWRpbycpIHtcbiAgICAvKiogQHR5cGUge05vZGVMaXN0T2Y8SFRNTElucHV0RWxlbWVudD59ICovXG4gICAgY29uc3QgcmFkaW9zID0gcG9wdXAucXVlcnlTZWxlY3RvckFsbChgW25hbWU9XCIke3N3YWxDbGFzc2VzLnJhZGlvfVwiXWApO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmFkaW9zLmxlbmd0aDsgaSsrKSB7XG4gICAgICByYWRpb3NbaV0uZGlzYWJsZWQgPSBkaXNhYmxlZDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaW5wdXQuZGlzYWJsZWQgPSBkaXNhYmxlZDtcbiAgfVxufVxuXG4vKipcbiAqIEVuYWJsZSBhbGwgdGhlIGJ1dHRvbnNcbiAqIEB0aGlzIHtTd2VldEFsZXJ0fVxuICovXG5mdW5jdGlvbiBlbmFibGVCdXR0b25zKCkge1xuICBzZXRCdXR0b25zRGlzYWJsZWQodGhpcywgWydjb25maXJtQnV0dG9uJywgJ2RlbnlCdXR0b24nLCAnY2FuY2VsQnV0dG9uJ10sIGZhbHNlKTtcbn1cblxuLyoqXG4gKiBEaXNhYmxlIGFsbCB0aGUgYnV0dG9uc1xuICogQHRoaXMge1N3ZWV0QWxlcnR9XG4gKi9cbmZ1bmN0aW9uIGRpc2FibGVCdXR0b25zKCkge1xuICBzZXRCdXR0b25zRGlzYWJsZWQodGhpcywgWydjb25maXJtQnV0dG9uJywgJ2RlbnlCdXR0b24nLCAnY2FuY2VsQnV0dG9uJ10sIHRydWUpO1xufVxuXG4vKipcbiAqIEVuYWJsZSB0aGUgaW5wdXQgZmllbGRcbiAqIEB0aGlzIHtTd2VldEFsZXJ0fVxuICovXG5mdW5jdGlvbiBlbmFibGVJbnB1dCgpIHtcbiAgc2V0SW5wdXREaXNhYmxlZCh0aGlzLmdldElucHV0KCksIGZhbHNlKTtcbn1cblxuLyoqXG4gKiBEaXNhYmxlIHRoZSBpbnB1dCBmaWVsZFxuICogQHRoaXMge1N3ZWV0QWxlcnR9XG4gKi9cbmZ1bmN0aW9uIGRpc2FibGVJbnB1dCgpIHtcbiAgc2V0SW5wdXREaXNhYmxlZCh0aGlzLmdldElucHV0KCksIHRydWUpO1xufVxuXG4vKipcbiAqIFNob3cgYmxvY2sgd2l0aCB2YWxpZGF0aW9uIG1lc3NhZ2VcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZXJyb3JcbiAqIEB0aGlzIHtTd2VldEFsZXJ0fVxuICovXG5mdW5jdGlvbiBzaG93VmFsaWRhdGlvbk1lc3NhZ2UoZXJyb3IpIHtcbiAgY29uc3QgZG9tQ2FjaGUgPSBwcml2YXRlUHJvcHMuZG9tQ2FjaGUuZ2V0KHRoaXMpO1xuICBjb25zdCBwYXJhbXMgPSBwcml2YXRlUHJvcHMuaW5uZXJQYXJhbXMuZ2V0KHRoaXMpO1xuICBzZXRJbm5lckh0bWwoZG9tQ2FjaGUudmFsaWRhdGlvbk1lc3NhZ2UsIGVycm9yKTtcbiAgZG9tQ2FjaGUudmFsaWRhdGlvbk1lc3NhZ2UuY2xhc3NOYW1lID0gc3dhbENsYXNzZXNbJ3ZhbGlkYXRpb24tbWVzc2FnZSddO1xuICBpZiAocGFyYW1zLmN1c3RvbUNsYXNzICYmIHBhcmFtcy5jdXN0b21DbGFzcy52YWxpZGF0aW9uTWVzc2FnZSkge1xuICAgIGFkZENsYXNzKGRvbUNhY2hlLnZhbGlkYXRpb25NZXNzYWdlLCBwYXJhbXMuY3VzdG9tQ2xhc3MudmFsaWRhdGlvbk1lc3NhZ2UpO1xuICB9XG4gIHNob3coZG9tQ2FjaGUudmFsaWRhdGlvbk1lc3NhZ2UpO1xuICBjb25zdCBpbnB1dCA9IHRoaXMuZ2V0SW5wdXQoKTtcbiAgaWYgKGlucHV0KSB7XG4gICAgaW5wdXQuc2V0QXR0cmlidXRlKCdhcmlhLWludmFsaWQnLCAndHJ1ZScpO1xuICAgIGlucHV0LnNldEF0dHJpYnV0ZSgnYXJpYS1kZXNjcmliZWRieScsIHN3YWxDbGFzc2VzWyd2YWxpZGF0aW9uLW1lc3NhZ2UnXSk7XG4gICAgZm9jdXNJbnB1dChpbnB1dCk7XG4gICAgYWRkQ2xhc3MoaW5wdXQsIHN3YWxDbGFzc2VzLmlucHV0ZXJyb3IpO1xuICB9XG59XG5cbi8qKlxuICogSGlkZSBibG9jayB3aXRoIHZhbGlkYXRpb24gbWVzc2FnZVxuICpcbiAqIEB0aGlzIHtTd2VldEFsZXJ0fVxuICovXG5mdW5jdGlvbiByZXNldFZhbGlkYXRpb25NZXNzYWdlKCkge1xuICBjb25zdCBkb21DYWNoZSA9IHByaXZhdGVQcm9wcy5kb21DYWNoZS5nZXQodGhpcyk7XG4gIGlmIChkb21DYWNoZS52YWxpZGF0aW9uTWVzc2FnZSkge1xuICAgIGhpZGUoZG9tQ2FjaGUudmFsaWRhdGlvbk1lc3NhZ2UpO1xuICB9XG4gIGNvbnN0IGlucHV0ID0gdGhpcy5nZXRJbnB1dCgpO1xuICBpZiAoaW5wdXQpIHtcbiAgICBpbnB1dC5yZW1vdmVBdHRyaWJ1dGUoJ2FyaWEtaW52YWxpZCcpO1xuICAgIGlucHV0LnJlbW92ZUF0dHJpYnV0ZSgnYXJpYS1kZXNjcmliZWRieScpO1xuICAgIHJlbW92ZUNsYXNzKGlucHV0LCBzd2FsQ2xhc3Nlcy5pbnB1dGVycm9yKTtcbiAgfVxufVxuXG5jb25zdCBkZWZhdWx0UGFyYW1zID0ge1xuICB0aXRsZTogJycsXG4gIHRpdGxlVGV4dDogJycsXG4gIHRleHQ6ICcnLFxuICBodG1sOiAnJyxcbiAgZm9vdGVyOiAnJyxcbiAgaWNvbjogdW5kZWZpbmVkLFxuICBpY29uQ29sb3I6IHVuZGVmaW5lZCxcbiAgaWNvbkh0bWw6IHVuZGVmaW5lZCxcbiAgdGVtcGxhdGU6IHVuZGVmaW5lZCxcbiAgdG9hc3Q6IGZhbHNlLFxuICBhbmltYXRpb246IHRydWUsXG4gIHNob3dDbGFzczoge1xuICAgIHBvcHVwOiAnc3dhbDItc2hvdycsXG4gICAgYmFja2Ryb3A6ICdzd2FsMi1iYWNrZHJvcC1zaG93JyxcbiAgICBpY29uOiAnc3dhbDItaWNvbi1zaG93J1xuICB9LFxuICBoaWRlQ2xhc3M6IHtcbiAgICBwb3B1cDogJ3N3YWwyLWhpZGUnLFxuICAgIGJhY2tkcm9wOiAnc3dhbDItYmFja2Ryb3AtaGlkZScsXG4gICAgaWNvbjogJ3N3YWwyLWljb24taGlkZSdcbiAgfSxcbiAgY3VzdG9tQ2xhc3M6IHt9LFxuICB0YXJnZXQ6ICdib2R5JyxcbiAgY29sb3I6IHVuZGVmaW5lZCxcbiAgYmFja2Ryb3A6IHRydWUsXG4gIGhlaWdodEF1dG86IHRydWUsXG4gIGFsbG93T3V0c2lkZUNsaWNrOiB0cnVlLFxuICBhbGxvd0VzY2FwZUtleTogdHJ1ZSxcbiAgYWxsb3dFbnRlcktleTogdHJ1ZSxcbiAgc3RvcEtleWRvd25Qcm9wYWdhdGlvbjogdHJ1ZSxcbiAga2V5ZG93bkxpc3RlbmVyQ2FwdHVyZTogZmFsc2UsXG4gIHNob3dDb25maXJtQnV0dG9uOiB0cnVlLFxuICBzaG93RGVueUJ1dHRvbjogZmFsc2UsXG4gIHNob3dDYW5jZWxCdXR0b246IGZhbHNlLFxuICBwcmVDb25maXJtOiB1bmRlZmluZWQsXG4gIHByZURlbnk6IHVuZGVmaW5lZCxcbiAgY29uZmlybUJ1dHRvblRleHQ6ICdPSycsXG4gIGNvbmZpcm1CdXR0b25BcmlhTGFiZWw6ICcnLFxuICBjb25maXJtQnV0dG9uQ29sb3I6IHVuZGVmaW5lZCxcbiAgZGVueUJ1dHRvblRleHQ6ICdObycsXG4gIGRlbnlCdXR0b25BcmlhTGFiZWw6ICcnLFxuICBkZW55QnV0dG9uQ29sb3I6IHVuZGVmaW5lZCxcbiAgY2FuY2VsQnV0dG9uVGV4dDogJ0NhbmNlbCcsXG4gIGNhbmNlbEJ1dHRvbkFyaWFMYWJlbDogJycsXG4gIGNhbmNlbEJ1dHRvbkNvbG9yOiB1bmRlZmluZWQsXG4gIGJ1dHRvbnNTdHlsaW5nOiB0cnVlLFxuICByZXZlcnNlQnV0dG9uczogZmFsc2UsXG4gIGZvY3VzQ29uZmlybTogdHJ1ZSxcbiAgZm9jdXNEZW55OiBmYWxzZSxcbiAgZm9jdXNDYW5jZWw6IGZhbHNlLFxuICByZXR1cm5Gb2N1czogdHJ1ZSxcbiAgc2hvd0Nsb3NlQnV0dG9uOiBmYWxzZSxcbiAgY2xvc2VCdXR0b25IdG1sOiAnJnRpbWVzOycsXG4gIGNsb3NlQnV0dG9uQXJpYUxhYmVsOiAnQ2xvc2UgdGhpcyBkaWFsb2cnLFxuICBsb2FkZXJIdG1sOiAnJyxcbiAgc2hvd0xvYWRlck9uQ29uZmlybTogZmFsc2UsXG4gIHNob3dMb2FkZXJPbkRlbnk6IGZhbHNlLFxuICBpbWFnZVVybDogdW5kZWZpbmVkLFxuICBpbWFnZVdpZHRoOiB1bmRlZmluZWQsXG4gIGltYWdlSGVpZ2h0OiB1bmRlZmluZWQsXG4gIGltYWdlQWx0OiAnJyxcbiAgdGltZXI6IHVuZGVmaW5lZCxcbiAgdGltZXJQcm9ncmVzc0JhcjogZmFsc2UsXG4gIHdpZHRoOiB1bmRlZmluZWQsXG4gIHBhZGRpbmc6IHVuZGVmaW5lZCxcbiAgYmFja2dyb3VuZDogdW5kZWZpbmVkLFxuICBpbnB1dDogdW5kZWZpbmVkLFxuICBpbnB1dFBsYWNlaG9sZGVyOiAnJyxcbiAgaW5wdXRMYWJlbDogJycsXG4gIGlucHV0VmFsdWU6ICcnLFxuICBpbnB1dE9wdGlvbnM6IHt9LFxuICBpbnB1dEF1dG9Gb2N1czogdHJ1ZSxcbiAgaW5wdXRBdXRvVHJpbTogdHJ1ZSxcbiAgaW5wdXRBdHRyaWJ1dGVzOiB7fSxcbiAgaW5wdXRWYWxpZGF0b3I6IHVuZGVmaW5lZCxcbiAgcmV0dXJuSW5wdXRWYWx1ZU9uRGVueTogZmFsc2UsXG4gIHZhbGlkYXRpb25NZXNzYWdlOiB1bmRlZmluZWQsXG4gIGdyb3c6IGZhbHNlLFxuICBwb3NpdGlvbjogJ2NlbnRlcicsXG4gIHByb2dyZXNzU3RlcHM6IFtdLFxuICBjdXJyZW50UHJvZ3Jlc3NTdGVwOiB1bmRlZmluZWQsXG4gIHByb2dyZXNzU3RlcHNEaXN0YW5jZTogdW5kZWZpbmVkLFxuICB3aWxsT3BlbjogdW5kZWZpbmVkLFxuICBkaWRPcGVuOiB1bmRlZmluZWQsXG4gIGRpZFJlbmRlcjogdW5kZWZpbmVkLFxuICB3aWxsQ2xvc2U6IHVuZGVmaW5lZCxcbiAgZGlkQ2xvc2U6IHVuZGVmaW5lZCxcbiAgZGlkRGVzdHJveTogdW5kZWZpbmVkLFxuICBzY3JvbGxiYXJQYWRkaW5nOiB0cnVlXG59O1xuY29uc3QgdXBkYXRhYmxlUGFyYW1zID0gWydhbGxvd0VzY2FwZUtleScsICdhbGxvd091dHNpZGVDbGljaycsICdiYWNrZ3JvdW5kJywgJ2J1dHRvbnNTdHlsaW5nJywgJ2NhbmNlbEJ1dHRvbkFyaWFMYWJlbCcsICdjYW5jZWxCdXR0b25Db2xvcicsICdjYW5jZWxCdXR0b25UZXh0JywgJ2Nsb3NlQnV0dG9uQXJpYUxhYmVsJywgJ2Nsb3NlQnV0dG9uSHRtbCcsICdjb2xvcicsICdjb25maXJtQnV0dG9uQXJpYUxhYmVsJywgJ2NvbmZpcm1CdXR0b25Db2xvcicsICdjb25maXJtQnV0dG9uVGV4dCcsICdjdXJyZW50UHJvZ3Jlc3NTdGVwJywgJ2N1c3RvbUNsYXNzJywgJ2RlbnlCdXR0b25BcmlhTGFiZWwnLCAnZGVueUJ1dHRvbkNvbG9yJywgJ2RlbnlCdXR0b25UZXh0JywgJ2RpZENsb3NlJywgJ2RpZERlc3Ryb3knLCAnZm9vdGVyJywgJ2hpZGVDbGFzcycsICdodG1sJywgJ2ljb24nLCAnaWNvbkNvbG9yJywgJ2ljb25IdG1sJywgJ2ltYWdlQWx0JywgJ2ltYWdlSGVpZ2h0JywgJ2ltYWdlVXJsJywgJ2ltYWdlV2lkdGgnLCAncHJlQ29uZmlybScsICdwcmVEZW55JywgJ3Byb2dyZXNzU3RlcHMnLCAncmV0dXJuRm9jdXMnLCAncmV2ZXJzZUJ1dHRvbnMnLCAnc2hvd0NhbmNlbEJ1dHRvbicsICdzaG93Q2xvc2VCdXR0b24nLCAnc2hvd0NvbmZpcm1CdXR0b24nLCAnc2hvd0RlbnlCdXR0b24nLCAndGV4dCcsICd0aXRsZScsICd0aXRsZVRleHQnLCAnd2lsbENsb3NlJ107XG5cbi8qKiBAdHlwZSB7UmVjb3JkPHN0cmluZywgc3RyaW5nIHwgdW5kZWZpbmVkPn0gKi9cbmNvbnN0IGRlcHJlY2F0ZWRQYXJhbXMgPSB7XG4gIGFsbG93RW50ZXJLZXk6IHVuZGVmaW5lZFxufTtcbmNvbnN0IHRvYXN0SW5jb21wYXRpYmxlUGFyYW1zID0gWydhbGxvd091dHNpZGVDbGljaycsICdhbGxvd0VudGVyS2V5JywgJ2JhY2tkcm9wJywgJ2ZvY3VzQ29uZmlybScsICdmb2N1c0RlbnknLCAnZm9jdXNDYW5jZWwnLCAncmV0dXJuRm9jdXMnLCAnaGVpZ2h0QXV0bycsICdrZXlkb3duTGlzdGVuZXJDYXB0dXJlJ107XG5cbi8qKlxuICogSXMgdmFsaWQgcGFyYW1ldGVyXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtTmFtZVxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmNvbnN0IGlzVmFsaWRQYXJhbWV0ZXIgPSBwYXJhbU5hbWUgPT4ge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGRlZmF1bHRQYXJhbXMsIHBhcmFtTmFtZSk7XG59O1xuXG4vKipcbiAqIElzIHZhbGlkIHBhcmFtZXRlciBmb3IgU3dhbC51cGRhdGUoKSBtZXRob2RcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1OYW1lXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuY29uc3QgaXNVcGRhdGFibGVQYXJhbWV0ZXIgPSBwYXJhbU5hbWUgPT4ge1xuICByZXR1cm4gdXBkYXRhYmxlUGFyYW1zLmluZGV4T2YocGFyYW1OYW1lKSAhPT0gLTE7XG59O1xuXG4vKipcbiAqIElzIGRlcHJlY2F0ZWQgcGFyYW1ldGVyXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtTmFtZVxuICogQHJldHVybnMge3N0cmluZyB8IHVuZGVmaW5lZH1cbiAqL1xuY29uc3QgaXNEZXByZWNhdGVkUGFyYW1ldGVyID0gcGFyYW1OYW1lID0+IHtcbiAgcmV0dXJuIGRlcHJlY2F0ZWRQYXJhbXNbcGFyYW1OYW1lXTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtXG4gKi9cbmNvbnN0IGNoZWNrSWZQYXJhbUlzVmFsaWQgPSBwYXJhbSA9PiB7XG4gIGlmICghaXNWYWxpZFBhcmFtZXRlcihwYXJhbSkpIHtcbiAgICB3YXJuKGBVbmtub3duIHBhcmFtZXRlciBcIiR7cGFyYW19XCJgKTtcbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1cbiAqL1xuY29uc3QgY2hlY2tJZlRvYXN0UGFyYW1Jc1ZhbGlkID0gcGFyYW0gPT4ge1xuICBpZiAodG9hc3RJbmNvbXBhdGlibGVQYXJhbXMuaW5jbHVkZXMocGFyYW0pKSB7XG4gICAgd2FybihgVGhlIHBhcmFtZXRlciBcIiR7cGFyYW19XCIgaXMgaW5jb21wYXRpYmxlIHdpdGggdG9hc3RzYCk7XG4gIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtXG4gKi9cbmNvbnN0IGNoZWNrSWZQYXJhbUlzRGVwcmVjYXRlZCA9IHBhcmFtID0+IHtcbiAgY29uc3QgaXNEZXByZWNhdGVkID0gaXNEZXByZWNhdGVkUGFyYW1ldGVyKHBhcmFtKTtcbiAgaWYgKGlzRGVwcmVjYXRlZCkge1xuICAgIHdhcm5BYm91dERlcHJlY2F0aW9uKHBhcmFtLCBpc0RlcHJlY2F0ZWQpO1xuICB9XG59O1xuXG4vKipcbiAqIFNob3cgcmVsZXZhbnQgd2FybmluZ3MgZm9yIGdpdmVuIHBhcmFtc1xuICpcbiAqIEBwYXJhbSB7U3dlZXRBbGVydE9wdGlvbnN9IHBhcmFtc1xuICovXG5jb25zdCBzaG93V2FybmluZ3NGb3JQYXJhbXMgPSBwYXJhbXMgPT4ge1xuICBpZiAocGFyYW1zLmJhY2tkcm9wID09PSBmYWxzZSAmJiBwYXJhbXMuYWxsb3dPdXRzaWRlQ2xpY2spIHtcbiAgICB3YXJuKCdcImFsbG93T3V0c2lkZUNsaWNrXCIgcGFyYW1ldGVyIHJlcXVpcmVzIGBiYWNrZHJvcGAgcGFyYW1ldGVyIHRvIGJlIHNldCB0byBgdHJ1ZWAnKTtcbiAgfVxuICBmb3IgKGNvbnN0IHBhcmFtIGluIHBhcmFtcykge1xuICAgIGNoZWNrSWZQYXJhbUlzVmFsaWQocGFyYW0pO1xuICAgIGlmIChwYXJhbXMudG9hc3QpIHtcbiAgICAgIGNoZWNrSWZUb2FzdFBhcmFtSXNWYWxpZChwYXJhbSk7XG4gICAgfVxuICAgIGNoZWNrSWZQYXJhbUlzRGVwcmVjYXRlZChwYXJhbSk7XG4gIH1cbn07XG5cbi8qKlxuICogVXBkYXRlcyBwb3B1cCBwYXJhbWV0ZXJzLlxuICpcbiAqIEBwYXJhbSB7U3dlZXRBbGVydE9wdGlvbnN9IHBhcmFtc1xuICovXG5mdW5jdGlvbiB1cGRhdGUocGFyYW1zKSB7XG4gIGNvbnN0IHBvcHVwID0gZ2V0UG9wdXAoKTtcbiAgY29uc3QgaW5uZXJQYXJhbXMgPSBwcml2YXRlUHJvcHMuaW5uZXJQYXJhbXMuZ2V0KHRoaXMpO1xuICBpZiAoIXBvcHVwIHx8IGhhc0NsYXNzKHBvcHVwLCBpbm5lclBhcmFtcy5oaWRlQ2xhc3MucG9wdXApKSB7XG4gICAgd2FybihgWW91J3JlIHRyeWluZyB0byB1cGRhdGUgdGhlIGNsb3NlZCBvciBjbG9zaW5nIHBvcHVwLCB0aGF0IHdvbid0IHdvcmsuIFVzZSB0aGUgdXBkYXRlKCkgbWV0aG9kIGluIHByZUNvbmZpcm0gcGFyYW1ldGVyIG9yIHNob3cgYSBuZXcgcG9wdXAuYCk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHZhbGlkVXBkYXRhYmxlUGFyYW1zID0gZmlsdGVyVmFsaWRQYXJhbXMocGFyYW1zKTtcbiAgY29uc3QgdXBkYXRlZFBhcmFtcyA9IE9iamVjdC5hc3NpZ24oe30sIGlubmVyUGFyYW1zLCB2YWxpZFVwZGF0YWJsZVBhcmFtcyk7XG4gIHJlbmRlcih0aGlzLCB1cGRhdGVkUGFyYW1zKTtcbiAgcHJpdmF0ZVByb3BzLmlubmVyUGFyYW1zLnNldCh0aGlzLCB1cGRhdGVkUGFyYW1zKTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGhpcywge1xuICAgIHBhcmFtczoge1xuICAgICAgdmFsdWU6IE9iamVjdC5hc3NpZ24oe30sIHRoaXMucGFyYW1zLCBwYXJhbXMpLFxuICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgIH1cbiAgfSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtTd2VldEFsZXJ0T3B0aW9uc30gcGFyYW1zXG4gKiBAcmV0dXJucyB7U3dlZXRBbGVydE9wdGlvbnN9XG4gKi9cbmNvbnN0IGZpbHRlclZhbGlkUGFyYW1zID0gcGFyYW1zID0+IHtcbiAgY29uc3QgdmFsaWRVcGRhdGFibGVQYXJhbXMgPSB7fTtcbiAgT2JqZWN0LmtleXMocGFyYW1zKS5mb3JFYWNoKHBhcmFtID0+IHtcbiAgICBpZiAoaXNVcGRhdGFibGVQYXJhbWV0ZXIocGFyYW0pKSB7XG4gICAgICB2YWxpZFVwZGF0YWJsZVBhcmFtc1twYXJhbV0gPSBwYXJhbXNbcGFyYW1dO1xuICAgIH0gZWxzZSB7XG4gICAgICB3YXJuKGBJbnZhbGlkIHBhcmFtZXRlciB0byB1cGRhdGU6ICR7cGFyYW19YCk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHZhbGlkVXBkYXRhYmxlUGFyYW1zO1xufTtcblxuLyoqXG4gKiBEaXNwb3NlIHRoZSBjdXJyZW50IFN3ZWV0QWxlcnQyIGluc3RhbmNlXG4gKi9cbmZ1bmN0aW9uIF9kZXN0cm95KCkge1xuICBjb25zdCBkb21DYWNoZSA9IHByaXZhdGVQcm9wcy5kb21DYWNoZS5nZXQodGhpcyk7XG4gIGNvbnN0IGlubmVyUGFyYW1zID0gcHJpdmF0ZVByb3BzLmlubmVyUGFyYW1zLmdldCh0aGlzKTtcbiAgaWYgKCFpbm5lclBhcmFtcykge1xuICAgIGRpc3Bvc2VXZWFrTWFwcyh0aGlzKTsgLy8gVGhlIFdlYWtNYXBzIG1pZ2h0IGhhdmUgYmVlbiBwYXJ0bHkgZGVzdHJveWVkLCB3ZSBtdXN0IHJlY2FsbCBpdCB0byBkaXNwb3NlIGFueSByZW1haW5pbmcgV2Vha01hcHMgIzIzMzVcbiAgICByZXR1cm47IC8vIFRoaXMgaW5zdGFuY2UgaGFzIGFscmVhZHkgYmVlbiBkZXN0cm95ZWRcbiAgfVxuXG4gIC8vIENoZWNrIGlmIHRoZXJlIGlzIGFub3RoZXIgU3dhbCBjbG9zaW5nXG4gIGlmIChkb21DYWNoZS5wb3B1cCAmJiBnbG9iYWxTdGF0ZS5zd2FsQ2xvc2VFdmVudEZpbmlzaGVkQ2FsbGJhY2spIHtcbiAgICBnbG9iYWxTdGF0ZS5zd2FsQ2xvc2VFdmVudEZpbmlzaGVkQ2FsbGJhY2soKTtcbiAgICBkZWxldGUgZ2xvYmFsU3RhdGUuc3dhbENsb3NlRXZlbnRGaW5pc2hlZENhbGxiYWNrO1xuICB9XG4gIGlmICh0eXBlb2YgaW5uZXJQYXJhbXMuZGlkRGVzdHJveSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGlubmVyUGFyYW1zLmRpZERlc3Ryb3koKTtcbiAgfVxuICBnbG9iYWxTdGF0ZS5ldmVudEVtaXR0ZXIuZW1pdCgnZGlkRGVzdHJveScpO1xuICBkaXNwb3NlU3dhbCh0aGlzKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1N3ZWV0QWxlcnR9IGluc3RhbmNlXG4gKi9cbmNvbnN0IGRpc3Bvc2VTd2FsID0gaW5zdGFuY2UgPT4ge1xuICBkaXNwb3NlV2Vha01hcHMoaW5zdGFuY2UpO1xuICAvLyBVbnNldCB0aGlzLnBhcmFtcyBzbyBHQyB3aWxsIGRpc3Bvc2UgaXQgKCMxNTY5KVxuICBkZWxldGUgaW5zdGFuY2UucGFyYW1zO1xuICAvLyBVbnNldCBnbG9iYWxTdGF0ZSBwcm9wcyBzbyBHQyB3aWxsIGRpc3Bvc2UgZ2xvYmFsU3RhdGUgKCMxNTY5KVxuICBkZWxldGUgZ2xvYmFsU3RhdGUua2V5ZG93bkhhbmRsZXI7XG4gIGRlbGV0ZSBnbG9iYWxTdGF0ZS5rZXlkb3duVGFyZ2V0O1xuICAvLyBVbnNldCBjdXJyZW50SW5zdGFuY2VcbiAgZGVsZXRlIGdsb2JhbFN0YXRlLmN1cnJlbnRJbnN0YW5jZTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtTd2VldEFsZXJ0fSBpbnN0YW5jZVxuICovXG5jb25zdCBkaXNwb3NlV2Vha01hcHMgPSBpbnN0YW5jZSA9PiB7XG4gIC8vIElmIHRoZSBjdXJyZW50IGluc3RhbmNlIGlzIGF3YWl0aW5nIGEgcHJvbWlzZSByZXN1bHQsIHdlIGtlZXAgdGhlIHByaXZhdGVNZXRob2RzIHRvIGNhbGwgdGhlbSBvbmNlIHRoZSBwcm9taXNlIHJlc3VsdCBpcyByZXRyaWV2ZWQgIzIzMzVcbiAgaWYgKGluc3RhbmNlLmlzQXdhaXRpbmdQcm9taXNlKSB7XG4gICAgdW5zZXRXZWFrTWFwcyhwcml2YXRlUHJvcHMsIGluc3RhbmNlKTtcbiAgICBpbnN0YW5jZS5pc0F3YWl0aW5nUHJvbWlzZSA9IHRydWU7XG4gIH0gZWxzZSB7XG4gICAgdW5zZXRXZWFrTWFwcyhwcml2YXRlTWV0aG9kcywgaW5zdGFuY2UpO1xuICAgIHVuc2V0V2Vha01hcHMocHJpdmF0ZVByb3BzLCBpbnN0YW5jZSk7XG4gICAgZGVsZXRlIGluc3RhbmNlLmlzQXdhaXRpbmdQcm9taXNlO1xuICAgIC8vIFVuc2V0IGluc3RhbmNlIG1ldGhvZHNcbiAgICBkZWxldGUgaW5zdGFuY2UuZGlzYWJsZUJ1dHRvbnM7XG4gICAgZGVsZXRlIGluc3RhbmNlLmVuYWJsZUJ1dHRvbnM7XG4gICAgZGVsZXRlIGluc3RhbmNlLmdldElucHV0O1xuICAgIGRlbGV0ZSBpbnN0YW5jZS5kaXNhYmxlSW5wdXQ7XG4gICAgZGVsZXRlIGluc3RhbmNlLmVuYWJsZUlucHV0O1xuICAgIGRlbGV0ZSBpbnN0YW5jZS5oaWRlTG9hZGluZztcbiAgICBkZWxldGUgaW5zdGFuY2UuZGlzYWJsZUxvYWRpbmc7XG4gICAgZGVsZXRlIGluc3RhbmNlLnNob3dWYWxpZGF0aW9uTWVzc2FnZTtcbiAgICBkZWxldGUgaW5zdGFuY2UucmVzZXRWYWxpZGF0aW9uTWVzc2FnZTtcbiAgICBkZWxldGUgaW5zdGFuY2UuY2xvc2U7XG4gICAgZGVsZXRlIGluc3RhbmNlLmNsb3NlUG9wdXA7XG4gICAgZGVsZXRlIGluc3RhbmNlLmNsb3NlTW9kYWw7XG4gICAgZGVsZXRlIGluc3RhbmNlLmNsb3NlVG9hc3Q7XG4gICAgZGVsZXRlIGluc3RhbmNlLnJlamVjdFByb21pc2U7XG4gICAgZGVsZXRlIGluc3RhbmNlLnVwZGF0ZTtcbiAgICBkZWxldGUgaW5zdGFuY2UuX2Rlc3Ryb3k7XG4gIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IG9ialxuICogQHBhcmFtIHtTd2VldEFsZXJ0fSBpbnN0YW5jZVxuICovXG5jb25zdCB1bnNldFdlYWtNYXBzID0gKG9iaiwgaW5zdGFuY2UpID0+IHtcbiAgZm9yIChjb25zdCBpIGluIG9iaikge1xuICAgIG9ialtpXS5kZWxldGUoaW5zdGFuY2UpO1xuICB9XG59O1xuXG52YXIgaW5zdGFuY2VNZXRob2RzID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIF9kZXN0cm95OiBfZGVzdHJveSxcbiAgY2xvc2U6IGNsb3NlLFxuICBjbG9zZU1vZGFsOiBjbG9zZSxcbiAgY2xvc2VQb3B1cDogY2xvc2UsXG4gIGNsb3NlVG9hc3Q6IGNsb3NlLFxuICBkaXNhYmxlQnV0dG9uczogZGlzYWJsZUJ1dHRvbnMsXG4gIGRpc2FibGVJbnB1dDogZGlzYWJsZUlucHV0LFxuICBkaXNhYmxlTG9hZGluZzogaGlkZUxvYWRpbmcsXG4gIGVuYWJsZUJ1dHRvbnM6IGVuYWJsZUJ1dHRvbnMsXG4gIGVuYWJsZUlucHV0OiBlbmFibGVJbnB1dCxcbiAgZ2V0SW5wdXQ6IGdldElucHV0LFxuICBoYW5kbGVBd2FpdGluZ1Byb21pc2U6IGhhbmRsZUF3YWl0aW5nUHJvbWlzZSxcbiAgaGlkZUxvYWRpbmc6IGhpZGVMb2FkaW5nLFxuICByZWplY3RQcm9taXNlOiByZWplY3RQcm9taXNlLFxuICByZXNldFZhbGlkYXRpb25NZXNzYWdlOiByZXNldFZhbGlkYXRpb25NZXNzYWdlLFxuICBzaG93VmFsaWRhdGlvbk1lc3NhZ2U6IHNob3dWYWxpZGF0aW9uTWVzc2FnZSxcbiAgdXBkYXRlOiB1cGRhdGVcbn0pO1xuXG4vKipcbiAqIEBwYXJhbSB7U3dlZXRBbGVydE9wdGlvbnN9IGlubmVyUGFyYW1zXG4gKiBAcGFyYW0ge0RvbUNhY2hlfSBkb21DYWNoZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZGlzbWlzc1dpdGhcbiAqL1xuY29uc3QgaGFuZGxlUG9wdXBDbGljayA9IChpbm5lclBhcmFtcywgZG9tQ2FjaGUsIGRpc21pc3NXaXRoKSA9PiB7XG4gIGlmIChpbm5lclBhcmFtcy50b2FzdCkge1xuICAgIGhhbmRsZVRvYXN0Q2xpY2soaW5uZXJQYXJhbXMsIGRvbUNhY2hlLCBkaXNtaXNzV2l0aCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gSWdub3JlIGNsaWNrIGV2ZW50cyB0aGF0IGhhZCBtb3VzZWRvd24gb24gdGhlIHBvcHVwIGJ1dCBtb3VzZXVwIG9uIHRoZSBjb250YWluZXJcbiAgICAvLyBUaGlzIGNhbiBoYXBwZW4gd2hlbiB0aGUgdXNlciBkcmFncyBhIHNsaWRlclxuICAgIGhhbmRsZU1vZGFsTW91c2Vkb3duKGRvbUNhY2hlKTtcblxuICAgIC8vIElnbm9yZSBjbGljayBldmVudHMgdGhhdCBoYWQgbW91c2Vkb3duIG9uIHRoZSBjb250YWluZXIgYnV0IG1vdXNldXAgb24gdGhlIHBvcHVwXG4gICAgaGFuZGxlQ29udGFpbmVyTW91c2Vkb3duKGRvbUNhY2hlKTtcbiAgICBoYW5kbGVNb2RhbENsaWNrKGlubmVyUGFyYW1zLCBkb21DYWNoZSwgZGlzbWlzc1dpdGgpO1xuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7U3dlZXRBbGVydE9wdGlvbnN9IGlubmVyUGFyYW1zXG4gKiBAcGFyYW0ge0RvbUNhY2hlfSBkb21DYWNoZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZGlzbWlzc1dpdGhcbiAqL1xuY29uc3QgaGFuZGxlVG9hc3RDbGljayA9IChpbm5lclBhcmFtcywgZG9tQ2FjaGUsIGRpc21pc3NXaXRoKSA9PiB7XG4gIC8vIENsb3NpbmcgdG9hc3QgYnkgaW50ZXJuYWwgY2xpY2tcbiAgZG9tQ2FjaGUucG9wdXAub25jbGljayA9ICgpID0+IHtcbiAgICBpZiAoaW5uZXJQYXJhbXMgJiYgKGlzQW55QnV0dG9uU2hvd24oaW5uZXJQYXJhbXMpIHx8IGlubmVyUGFyYW1zLnRpbWVyIHx8IGlubmVyUGFyYW1zLmlucHV0KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkaXNtaXNzV2l0aChEaXNtaXNzUmVhc29uLmNsb3NlKTtcbiAgfTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtTd2VldEFsZXJ0T3B0aW9uc30gaW5uZXJQYXJhbXNcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5jb25zdCBpc0FueUJ1dHRvblNob3duID0gaW5uZXJQYXJhbXMgPT4ge1xuICByZXR1cm4gISEoaW5uZXJQYXJhbXMuc2hvd0NvbmZpcm1CdXR0b24gfHwgaW5uZXJQYXJhbXMuc2hvd0RlbnlCdXR0b24gfHwgaW5uZXJQYXJhbXMuc2hvd0NhbmNlbEJ1dHRvbiB8fCBpbm5lclBhcmFtcy5zaG93Q2xvc2VCdXR0b24pO1xufTtcbmxldCBpZ25vcmVPdXRzaWRlQ2xpY2sgPSBmYWxzZTtcblxuLyoqXG4gKiBAcGFyYW0ge0RvbUNhY2hlfSBkb21DYWNoZVxuICovXG5jb25zdCBoYW5kbGVNb2RhbE1vdXNlZG93biA9IGRvbUNhY2hlID0+IHtcbiAgZG9tQ2FjaGUucG9wdXAub25tb3VzZWRvd24gPSAoKSA9PiB7XG4gICAgZG9tQ2FjaGUuY29udGFpbmVyLm9ubW91c2V1cCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICBkb21DYWNoZS5jb250YWluZXIub25tb3VzZXVwID0gKCkgPT4ge307XG4gICAgICAvLyBXZSBvbmx5IGNoZWNrIGlmIHRoZSBtb3VzZXVwIHRhcmdldCBpcyB0aGUgY29udGFpbmVyIGJlY2F1c2UgdXN1YWxseSBpdCBkb2Vzbid0XG4gICAgICAvLyBoYXZlIGFueSBvdGhlciBkaXJlY3QgY2hpbGRyZW4gYXNpZGUgb2YgdGhlIHBvcHVwXG4gICAgICBpZiAoZS50YXJnZXQgPT09IGRvbUNhY2hlLmNvbnRhaW5lcikge1xuICAgICAgICBpZ25vcmVPdXRzaWRlQ2xpY2sgPSB0cnVlO1xuICAgICAgfVxuICAgIH07XG4gIH07XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7RG9tQ2FjaGV9IGRvbUNhY2hlXG4gKi9cbmNvbnN0IGhhbmRsZUNvbnRhaW5lck1vdXNlZG93biA9IGRvbUNhY2hlID0+IHtcbiAgZG9tQ2FjaGUuY29udGFpbmVyLm9ubW91c2Vkb3duID0gZSA9PiB7XG4gICAgLy8gcHJldmVudCB0aGUgbW9kYWwgdGV4dCBmcm9tIGJlaW5nIHNlbGVjdGVkIG9uIGRvdWJsZSBjbGljayBvbiB0aGUgY29udGFpbmVyIChhbGxvd091dHNpZGVDbGljazogZmFsc2UpXG4gICAgaWYgKGUudGFyZ2V0ID09PSBkb21DYWNoZS5jb250YWluZXIpIHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gICAgZG9tQ2FjaGUucG9wdXAub25tb3VzZXVwID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIGRvbUNhY2hlLnBvcHVwLm9ubW91c2V1cCA9ICgpID0+IHt9O1xuICAgICAgLy8gV2UgYWxzbyBuZWVkIHRvIGNoZWNrIGlmIHRoZSBtb3VzZXVwIHRhcmdldCBpcyBhIGNoaWxkIG9mIHRoZSBwb3B1cFxuICAgICAgaWYgKGUudGFyZ2V0ID09PSBkb21DYWNoZS5wb3B1cCB8fCBlLnRhcmdldCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50ICYmIGRvbUNhY2hlLnBvcHVwLmNvbnRhaW5zKGUudGFyZ2V0KSkge1xuICAgICAgICBpZ25vcmVPdXRzaWRlQ2xpY2sgPSB0cnVlO1xuICAgICAgfVxuICAgIH07XG4gIH07XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7U3dlZXRBbGVydE9wdGlvbnN9IGlubmVyUGFyYW1zXG4gKiBAcGFyYW0ge0RvbUNhY2hlfSBkb21DYWNoZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZGlzbWlzc1dpdGhcbiAqL1xuY29uc3QgaGFuZGxlTW9kYWxDbGljayA9IChpbm5lclBhcmFtcywgZG9tQ2FjaGUsIGRpc21pc3NXaXRoKSA9PiB7XG4gIGRvbUNhY2hlLmNvbnRhaW5lci5vbmNsaWNrID0gZSA9PiB7XG4gICAgaWYgKGlnbm9yZU91dHNpZGVDbGljaykge1xuICAgICAgaWdub3JlT3V0c2lkZUNsaWNrID0gZmFsc2U7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChlLnRhcmdldCA9PT0gZG9tQ2FjaGUuY29udGFpbmVyICYmIGNhbGxJZkZ1bmN0aW9uKGlubmVyUGFyYW1zLmFsbG93T3V0c2lkZUNsaWNrKSkge1xuICAgICAgZGlzbWlzc1dpdGgoRGlzbWlzc1JlYXNvbi5iYWNrZHJvcCk7XG4gICAgfVxuICB9O1xufTtcblxuY29uc3QgaXNKcXVlcnlFbGVtZW50ID0gZWxlbSA9PiB0eXBlb2YgZWxlbSA9PT0gJ29iamVjdCcgJiYgZWxlbS5qcXVlcnk7XG5jb25zdCBpc0VsZW1lbnQgPSBlbGVtID0+IGVsZW0gaW5zdGFuY2VvZiBFbGVtZW50IHx8IGlzSnF1ZXJ5RWxlbWVudChlbGVtKTtcbmNvbnN0IGFyZ3NUb1BhcmFtcyA9IGFyZ3MgPT4ge1xuICBjb25zdCBwYXJhbXMgPSB7fTtcbiAgaWYgKHR5cGVvZiBhcmdzWzBdID09PSAnb2JqZWN0JyAmJiAhaXNFbGVtZW50KGFyZ3NbMF0pKSB7XG4gICAgT2JqZWN0LmFzc2lnbihwYXJhbXMsIGFyZ3NbMF0pO1xuICB9IGVsc2Uge1xuICAgIFsndGl0bGUnLCAnaHRtbCcsICdpY29uJ10uZm9yRWFjaCgobmFtZSwgaW5kZXgpID0+IHtcbiAgICAgIGNvbnN0IGFyZyA9IGFyZ3NbaW5kZXhdO1xuICAgICAgaWYgKHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnIHx8IGlzRWxlbWVudChhcmcpKSB7XG4gICAgICAgIHBhcmFtc1tuYW1lXSA9IGFyZztcbiAgICAgIH0gZWxzZSBpZiAoYXJnICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZXJyb3IoYFVuZXhwZWN0ZWQgdHlwZSBvZiAke25hbWV9ISBFeHBlY3RlZCBcInN0cmluZ1wiIG9yIFwiRWxlbWVudFwiLCBnb3QgJHt0eXBlb2YgYXJnfWApO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHJldHVybiBwYXJhbXM7XG59O1xuXG4vKipcbiAqIE1haW4gbWV0aG9kIHRvIGNyZWF0ZSBhIG5ldyBTd2VldEFsZXJ0MiBwb3B1cFxuICpcbiAqIEBwYXJhbSAgey4uLlN3ZWV0QWxlcnRPcHRpb25zfSBhcmdzXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxTd2VldEFsZXJ0UmVzdWx0Pn1cbiAqL1xuZnVuY3Rpb24gZmlyZSgpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuICByZXR1cm4gbmV3IHRoaXMoLi4uYXJncyk7XG59XG5cbi8qKlxuICogUmV0dXJucyBhbiBleHRlbmRlZCB2ZXJzaW9uIG9mIGBTd2FsYCBjb250YWluaW5nIGBwYXJhbXNgIGFzIGRlZmF1bHRzLlxuICogVXNlZnVsIGZvciByZXVzaW5nIFN3YWwgY29uZmlndXJhdGlvbi5cbiAqXG4gKiBGb3IgZXhhbXBsZTpcbiAqXG4gKiBCZWZvcmU6XG4gKiBjb25zdCB0ZXh0UHJvbXB0T3B0aW9ucyA9IHsgaW5wdXQ6ICd0ZXh0Jywgc2hvd0NhbmNlbEJ1dHRvbjogdHJ1ZSB9XG4gKiBjb25zdCB7dmFsdWU6IGZpcnN0TmFtZX0gPSBhd2FpdCBTd2FsLmZpcmUoeyAuLi50ZXh0UHJvbXB0T3B0aW9ucywgdGl0bGU6ICdXaGF0IGlzIHlvdXIgZmlyc3QgbmFtZT8nIH0pXG4gKiBjb25zdCB7dmFsdWU6IGxhc3ROYW1lfSA9IGF3YWl0IFN3YWwuZmlyZSh7IC4uLnRleHRQcm9tcHRPcHRpb25zLCB0aXRsZTogJ1doYXQgaXMgeW91ciBsYXN0IG5hbWU/JyB9KVxuICpcbiAqIEFmdGVyOlxuICogY29uc3QgVGV4dFByb21wdCA9IFN3YWwubWl4aW4oeyBpbnB1dDogJ3RleHQnLCBzaG93Q2FuY2VsQnV0dG9uOiB0cnVlIH0pXG4gKiBjb25zdCB7dmFsdWU6IGZpcnN0TmFtZX0gPSBhd2FpdCBUZXh0UHJvbXB0KCdXaGF0IGlzIHlvdXIgZmlyc3QgbmFtZT8nKVxuICogY29uc3Qge3ZhbHVlOiBsYXN0TmFtZX0gPSBhd2FpdCBUZXh0UHJvbXB0KCdXaGF0IGlzIHlvdXIgbGFzdCBuYW1lPycpXG4gKlxuICogQHBhcmFtIHtTd2VldEFsZXJ0T3B0aW9uc30gbWl4aW5QYXJhbXNcbiAqIEByZXR1cm5zIHtTd2VldEFsZXJ0fVxuICovXG5mdW5jdGlvbiBtaXhpbihtaXhpblBhcmFtcykge1xuICBjbGFzcyBNaXhpblN3YWwgZXh0ZW5kcyB0aGlzIHtcbiAgICBfbWFpbihwYXJhbXMsIHByaW9yaXR5TWl4aW5QYXJhbXMpIHtcbiAgICAgIHJldHVybiBzdXBlci5fbWFpbihwYXJhbXMsIE9iamVjdC5hc3NpZ24oe30sIG1peGluUGFyYW1zLCBwcmlvcml0eU1peGluUGFyYW1zKSk7XG4gICAgfVxuICB9XG4gIC8vIEB0cy1pZ25vcmVcbiAgcmV0dXJuIE1peGluU3dhbDtcbn1cblxuLyoqXG4gKiBJZiBgdGltZXJgIHBhcmFtZXRlciBpcyBzZXQsIHJldHVybnMgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBvZiB0aW1lciByZW1haW5lZC5cbiAqIE90aGVyd2lzZSwgcmV0dXJucyB1bmRlZmluZWQuXG4gKlxuICogQHJldHVybnMge251bWJlciB8IHVuZGVmaW5lZH1cbiAqL1xuY29uc3QgZ2V0VGltZXJMZWZ0ID0gKCkgPT4ge1xuICByZXR1cm4gZ2xvYmFsU3RhdGUudGltZW91dCAmJiBnbG9iYWxTdGF0ZS50aW1lb3V0LmdldFRpbWVyTGVmdCgpO1xufTtcblxuLyoqXG4gKiBTdG9wIHRpbWVyLiBSZXR1cm5zIG51bWJlciBvZiBtaWxsaXNlY29uZHMgb2YgdGltZXIgcmVtYWluZWQuXG4gKiBJZiBgdGltZXJgIHBhcmFtZXRlciBpc24ndCBzZXQsIHJldHVybnMgdW5kZWZpbmVkLlxuICpcbiAqIEByZXR1cm5zIHtudW1iZXIgfCB1bmRlZmluZWR9XG4gKi9cbmNvbnN0IHN0b3BUaW1lciA9ICgpID0+IHtcbiAgaWYgKGdsb2JhbFN0YXRlLnRpbWVvdXQpIHtcbiAgICBzdG9wVGltZXJQcm9ncmVzc0JhcigpO1xuICAgIHJldHVybiBnbG9iYWxTdGF0ZS50aW1lb3V0LnN0b3AoKTtcbiAgfVxufTtcblxuLyoqXG4gKiBSZXN1bWUgdGltZXIuIFJldHVybnMgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBvZiB0aW1lciByZW1haW5lZC5cbiAqIElmIGB0aW1lcmAgcGFyYW1ldGVyIGlzbid0IHNldCwgcmV0dXJucyB1bmRlZmluZWQuXG4gKlxuICogQHJldHVybnMge251bWJlciB8IHVuZGVmaW5lZH1cbiAqL1xuY29uc3QgcmVzdW1lVGltZXIgPSAoKSA9PiB7XG4gIGlmIChnbG9iYWxTdGF0ZS50aW1lb3V0KSB7XG4gICAgY29uc3QgcmVtYWluaW5nID0gZ2xvYmFsU3RhdGUudGltZW91dC5zdGFydCgpO1xuICAgIGFuaW1hdGVUaW1lclByb2dyZXNzQmFyKHJlbWFpbmluZyk7XG4gICAgcmV0dXJuIHJlbWFpbmluZztcbiAgfVxufTtcblxuLyoqXG4gKiBSZXN1bWUgdGltZXIuIFJldHVybnMgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBvZiB0aW1lciByZW1haW5lZC5cbiAqIElmIGB0aW1lcmAgcGFyYW1ldGVyIGlzbid0IHNldCwgcmV0dXJucyB1bmRlZmluZWQuXG4gKlxuICogQHJldHVybnMge251bWJlciB8IHVuZGVmaW5lZH1cbiAqL1xuY29uc3QgdG9nZ2xlVGltZXIgPSAoKSA9PiB7XG4gIGNvbnN0IHRpbWVyID0gZ2xvYmFsU3RhdGUudGltZW91dDtcbiAgcmV0dXJuIHRpbWVyICYmICh0aW1lci5ydW5uaW5nID8gc3RvcFRpbWVyKCkgOiByZXN1bWVUaW1lcigpKTtcbn07XG5cbi8qKlxuICogSW5jcmVhc2UgdGltZXIuIFJldHVybnMgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBvZiBhbiB1cGRhdGVkIHRpbWVyLlxuICogSWYgYHRpbWVyYCBwYXJhbWV0ZXIgaXNuJ3Qgc2V0LCByZXR1cm5zIHVuZGVmaW5lZC5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gbXNcbiAqIEByZXR1cm5zIHtudW1iZXIgfCB1bmRlZmluZWR9XG4gKi9cbmNvbnN0IGluY3JlYXNlVGltZXIgPSBtcyA9PiB7XG4gIGlmIChnbG9iYWxTdGF0ZS50aW1lb3V0KSB7XG4gICAgY29uc3QgcmVtYWluaW5nID0gZ2xvYmFsU3RhdGUudGltZW91dC5pbmNyZWFzZShtcyk7XG4gICAgYW5pbWF0ZVRpbWVyUHJvZ3Jlc3NCYXIocmVtYWluaW5nLCB0cnVlKTtcbiAgICByZXR1cm4gcmVtYWluaW5nO1xuICB9XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIHRpbWVyIGlzIHJ1bm5pbmcuIFJldHVybnMgdHJ1ZSBpZiB0aW1lciBpcyBydW5uaW5nXG4gKiBvciBmYWxzZSBpZiB0aW1lciBpcyBwYXVzZWQgb3Igc3RvcHBlZC5cbiAqIElmIGB0aW1lcmAgcGFyYW1ldGVyIGlzbid0IHNldCwgcmV0dXJucyB1bmRlZmluZWRcbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuY29uc3QgaXNUaW1lclJ1bm5pbmcgPSAoKSA9PiB7XG4gIHJldHVybiAhIShnbG9iYWxTdGF0ZS50aW1lb3V0ICYmIGdsb2JhbFN0YXRlLnRpbWVvdXQuaXNSdW5uaW5nKCkpO1xufTtcblxubGV0IGJvZHlDbGlja0xpc3RlbmVyQWRkZWQgPSBmYWxzZTtcbmNvbnN0IGNsaWNrSGFuZGxlcnMgPSB7fTtcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gYXR0clxuICovXG5mdW5jdGlvbiBiaW5kQ2xpY2tIYW5kbGVyKCkge1xuICBsZXQgYXR0ciA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogJ2RhdGEtc3dhbC10ZW1wbGF0ZSc7XG4gIGNsaWNrSGFuZGxlcnNbYXR0cl0gPSB0aGlzO1xuICBpZiAoIWJvZHlDbGlja0xpc3RlbmVyQWRkZWQpIHtcbiAgICBkb2N1bWVudC5ib2R5LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgYm9keUNsaWNrTGlzdGVuZXIpO1xuICAgIGJvZHlDbGlja0xpc3RlbmVyQWRkZWQgPSB0cnVlO1xuICB9XG59XG5jb25zdCBib2R5Q2xpY2tMaXN0ZW5lciA9IGV2ZW50ID0+IHtcbiAgZm9yIChsZXQgZWwgPSBldmVudC50YXJnZXQ7IGVsICYmIGVsICE9PSBkb2N1bWVudDsgZWwgPSBlbC5wYXJlbnROb2RlKSB7XG4gICAgZm9yIChjb25zdCBhdHRyIGluIGNsaWNrSGFuZGxlcnMpIHtcbiAgICAgIGNvbnN0IHRlbXBsYXRlID0gZWwuZ2V0QXR0cmlidXRlKGF0dHIpO1xuICAgICAgaWYgKHRlbXBsYXRlKSB7XG4gICAgICAgIGNsaWNrSGFuZGxlcnNbYXR0cl0uZmlyZSh7XG4gICAgICAgICAgdGVtcGxhdGVcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbi8vIFNvdXJjZTogaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vbXVkZ2UvNTgzMDM4Mj9wZXJtYWxpbmtfY29tbWVudF9pZD0yNjkxOTU3I2dpc3Rjb21tZW50LTI2OTE5NTdcblxuY2xhc3MgRXZlbnRFbWl0dGVyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgLyoqIEB0eXBlIHtFdmVudHN9ICovXG4gICAgdGhpcy5ldmVudHMgPSB7fTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lXG4gICAqIEByZXR1cm5zIHtFdmVudEhhbmRsZXJzfVxuICAgKi9cbiAgX2dldEhhbmRsZXJzQnlFdmVudE5hbWUoZXZlbnROYW1lKSB7XG4gICAgaWYgKHR5cGVvZiB0aGlzLmV2ZW50c1tldmVudE5hbWVdID09PSAndW5kZWZpbmVkJykge1xuICAgICAgLy8gbm90IFNldCBiZWNhdXNlIHdlIG5lZWQgdG8ga2VlcCB0aGUgRklGTyBvcmRlclxuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3N3ZWV0YWxlcnQyL3N3ZWV0YWxlcnQyL3B1bGwvMjc2MyNkaXNjdXNzaW9uX3IxNzQ4OTkwMzM0XG4gICAgICB0aGlzLmV2ZW50c1tldmVudE5hbWVdID0gW107XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmV2ZW50c1tldmVudE5hbWVdO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWVcbiAgICogQHBhcmFtIHtFdmVudEhhbmRsZXJ9IGV2ZW50SGFuZGxlclxuICAgKi9cbiAgb24oZXZlbnROYW1lLCBldmVudEhhbmRsZXIpIHtcbiAgICBjb25zdCBjdXJyZW50SGFuZGxlcnMgPSB0aGlzLl9nZXRIYW5kbGVyc0J5RXZlbnROYW1lKGV2ZW50TmFtZSk7XG4gICAgaWYgKCFjdXJyZW50SGFuZGxlcnMuaW5jbHVkZXMoZXZlbnRIYW5kbGVyKSkge1xuICAgICAgY3VycmVudEhhbmRsZXJzLnB1c2goZXZlbnRIYW5kbGVyKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZVxuICAgKiBAcGFyYW0ge0V2ZW50SGFuZGxlcn0gZXZlbnRIYW5kbGVyXG4gICAqL1xuICBvbmNlKGV2ZW50TmFtZSwgZXZlbnRIYW5kbGVyKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcmdzXG4gICAgICovXG4gICAgY29uc3Qgb25jZUZuID0gZnVuY3Rpb24gKCkge1xuICAgICAgX3RoaXMucmVtb3ZlTGlzdGVuZXIoZXZlbnROYW1lLCBvbmNlRm4pO1xuICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICB9XG4gICAgICBldmVudEhhbmRsZXIuYXBwbHkoX3RoaXMsIGFyZ3MpO1xuICAgIH07XG4gICAgdGhpcy5vbihldmVudE5hbWUsIG9uY2VGbik7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZVxuICAgKiBAcGFyYW0ge0FycmF5fSBhcmdzXG4gICAqL1xuICBlbWl0KGV2ZW50TmFtZSkge1xuICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMiA+IDEgPyBfbGVuMiAtIDEgOiAwKSwgX2tleTIgPSAxOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICBhcmdzW19rZXkyIC0gMV0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgIH1cbiAgICB0aGlzLl9nZXRIYW5kbGVyc0J5RXZlbnROYW1lKGV2ZW50TmFtZSkuZm9yRWFjaChcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0V2ZW50SGFuZGxlcn0gZXZlbnRIYW5kbGVyXG4gICAgICovXG4gICAgZXZlbnRIYW5kbGVyID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGV2ZW50SGFuZGxlci5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWVcbiAgICogQHBhcmFtIHtFdmVudEhhbmRsZXJ9IGV2ZW50SGFuZGxlclxuICAgKi9cbiAgcmVtb3ZlTGlzdGVuZXIoZXZlbnROYW1lLCBldmVudEhhbmRsZXIpIHtcbiAgICBjb25zdCBjdXJyZW50SGFuZGxlcnMgPSB0aGlzLl9nZXRIYW5kbGVyc0J5RXZlbnROYW1lKGV2ZW50TmFtZSk7XG4gICAgY29uc3QgaW5kZXggPSBjdXJyZW50SGFuZGxlcnMuaW5kZXhPZihldmVudEhhbmRsZXIpO1xuICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICBjdXJyZW50SGFuZGxlcnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZVxuICAgKi9cbiAgcmVtb3ZlQWxsTGlzdGVuZXJzKGV2ZW50TmFtZSkge1xuICAgIGlmICh0aGlzLmV2ZW50c1tldmVudE5hbWVdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9zd2VldGFsZXJ0Mi9zd2VldGFsZXJ0Mi9wdWxsLzI3NjMjZGlzY3Vzc2lvbl9yMTc0OTIzOTIyMlxuICAgICAgdGhpcy5ldmVudHNbZXZlbnROYW1lXS5sZW5ndGggPSAwO1xuICAgIH1cbiAgfVxuICByZXNldCgpIHtcbiAgICB0aGlzLmV2ZW50cyA9IHt9O1xuICB9XG59XG5cbmdsb2JhbFN0YXRlLmV2ZW50RW1pdHRlciA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lXG4gKiBAcGFyYW0ge0V2ZW50SGFuZGxlcn0gZXZlbnRIYW5kbGVyXG4gKi9cbmNvbnN0IG9uID0gKGV2ZW50TmFtZSwgZXZlbnRIYW5kbGVyKSA9PiB7XG4gIGdsb2JhbFN0YXRlLmV2ZW50RW1pdHRlci5vbihldmVudE5hbWUsIGV2ZW50SGFuZGxlcik7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWVcbiAqIEBwYXJhbSB7RXZlbnRIYW5kbGVyfSBldmVudEhhbmRsZXJcbiAqL1xuY29uc3Qgb25jZSA9IChldmVudE5hbWUsIGV2ZW50SGFuZGxlcikgPT4ge1xuICBnbG9iYWxTdGF0ZS5ldmVudEVtaXR0ZXIub25jZShldmVudE5hbWUsIGV2ZW50SGFuZGxlcik7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBbZXZlbnROYW1lXVxuICogQHBhcmFtIHtFdmVudEhhbmRsZXJ9IFtldmVudEhhbmRsZXJdXG4gKi9cbmNvbnN0IG9mZiA9IChldmVudE5hbWUsIGV2ZW50SGFuZGxlcikgPT4ge1xuICAvLyBSZW1vdmUgYWxsIGhhbmRsZXJzIGZvciBhbGwgZXZlbnRzXG4gIGlmICghZXZlbnROYW1lKSB7XG4gICAgZ2xvYmFsU3RhdGUuZXZlbnRFbWl0dGVyLnJlc2V0KCk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChldmVudEhhbmRsZXIpIHtcbiAgICAvLyBSZW1vdmUgYSBzcGVjaWZpYyBoYW5kbGVyXG4gICAgZ2xvYmFsU3RhdGUuZXZlbnRFbWl0dGVyLnJlbW92ZUxpc3RlbmVyKGV2ZW50TmFtZSwgZXZlbnRIYW5kbGVyKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBSZW1vdmUgYWxsIGhhbmRsZXJzIGZvciBhIHNwZWNpZmljIGV2ZW50XG4gICAgZ2xvYmFsU3RhdGUuZXZlbnRFbWl0dGVyLnJlbW92ZUFsbExpc3RlbmVycyhldmVudE5hbWUpO1xuICB9XG59O1xuXG52YXIgc3RhdGljTWV0aG9kcyA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgX19wcm90b19fOiBudWxsLFxuICBhcmdzVG9QYXJhbXM6IGFyZ3NUb1BhcmFtcyxcbiAgYmluZENsaWNrSGFuZGxlcjogYmluZENsaWNrSGFuZGxlcixcbiAgY2xpY2tDYW5jZWw6IGNsaWNrQ2FuY2VsLFxuICBjbGlja0NvbmZpcm06IGNsaWNrQ29uZmlybSxcbiAgY2xpY2tEZW55OiBjbGlja0RlbnksXG4gIGVuYWJsZUxvYWRpbmc6IHNob3dMb2FkaW5nLFxuICBmaXJlOiBmaXJlLFxuICBnZXRBY3Rpb25zOiBnZXRBY3Rpb25zLFxuICBnZXRDYW5jZWxCdXR0b246IGdldENhbmNlbEJ1dHRvbixcbiAgZ2V0Q2xvc2VCdXR0b246IGdldENsb3NlQnV0dG9uLFxuICBnZXRDb25maXJtQnV0dG9uOiBnZXRDb25maXJtQnV0dG9uLFxuICBnZXRDb250YWluZXI6IGdldENvbnRhaW5lcixcbiAgZ2V0RGVueUJ1dHRvbjogZ2V0RGVueUJ1dHRvbixcbiAgZ2V0Rm9jdXNhYmxlRWxlbWVudHM6IGdldEZvY3VzYWJsZUVsZW1lbnRzLFxuICBnZXRGb290ZXI6IGdldEZvb3RlcixcbiAgZ2V0SHRtbENvbnRhaW5lcjogZ2V0SHRtbENvbnRhaW5lcixcbiAgZ2V0SWNvbjogZ2V0SWNvbixcbiAgZ2V0SWNvbkNvbnRlbnQ6IGdldEljb25Db250ZW50LFxuICBnZXRJbWFnZTogZ2V0SW1hZ2UsXG4gIGdldElucHV0TGFiZWw6IGdldElucHV0TGFiZWwsXG4gIGdldExvYWRlcjogZ2V0TG9hZGVyLFxuICBnZXRQb3B1cDogZ2V0UG9wdXAsXG4gIGdldFByb2dyZXNzU3RlcHM6IGdldFByb2dyZXNzU3RlcHMsXG4gIGdldFRpbWVyTGVmdDogZ2V0VGltZXJMZWZ0LFxuICBnZXRUaW1lclByb2dyZXNzQmFyOiBnZXRUaW1lclByb2dyZXNzQmFyLFxuICBnZXRUaXRsZTogZ2V0VGl0bGUsXG4gIGdldFZhbGlkYXRpb25NZXNzYWdlOiBnZXRWYWxpZGF0aW9uTWVzc2FnZSxcbiAgaW5jcmVhc2VUaW1lcjogaW5jcmVhc2VUaW1lcixcbiAgaXNEZXByZWNhdGVkUGFyYW1ldGVyOiBpc0RlcHJlY2F0ZWRQYXJhbWV0ZXIsXG4gIGlzTG9hZGluZzogaXNMb2FkaW5nLFxuICBpc1RpbWVyUnVubmluZzogaXNUaW1lclJ1bm5pbmcsXG4gIGlzVXBkYXRhYmxlUGFyYW1ldGVyOiBpc1VwZGF0YWJsZVBhcmFtZXRlcixcbiAgaXNWYWxpZFBhcmFtZXRlcjogaXNWYWxpZFBhcmFtZXRlcixcbiAgaXNWaXNpYmxlOiBpc1Zpc2libGUsXG4gIG1peGluOiBtaXhpbixcbiAgb2ZmOiBvZmYsXG4gIG9uOiBvbixcbiAgb25jZTogb25jZSxcbiAgcmVzdW1lVGltZXI6IHJlc3VtZVRpbWVyLFxuICBzaG93TG9hZGluZzogc2hvd0xvYWRpbmcsXG4gIHN0b3BUaW1lcjogc3RvcFRpbWVyLFxuICB0b2dnbGVUaW1lcjogdG9nZ2xlVGltZXJcbn0pO1xuXG5jbGFzcyBUaW1lciB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKiBAcGFyYW0ge251bWJlcn0gZGVsYXlcbiAgICovXG4gIGNvbnN0cnVjdG9yKGNhbGxiYWNrLCBkZWxheSkge1xuICAgIHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICB0aGlzLnJlbWFpbmluZyA9IGRlbGF5O1xuICAgIHRoaXMucnVubmluZyA9IGZhbHNlO1xuICAgIHRoaXMuc3RhcnQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgKi9cbiAgc3RhcnQoKSB7XG4gICAgaWYgKCF0aGlzLnJ1bm5pbmcpIHtcbiAgICAgIHRoaXMucnVubmluZyA9IHRydWU7XG4gICAgICB0aGlzLnN0YXJ0ZWQgPSBuZXcgRGF0ZSgpO1xuICAgICAgdGhpcy5pZCA9IHNldFRpbWVvdXQodGhpcy5jYWxsYmFjaywgdGhpcy5yZW1haW5pbmcpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5yZW1haW5pbmc7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybnMge251bWJlcn1cbiAgICovXG4gIHN0b3AoKSB7XG4gICAgaWYgKHRoaXMuc3RhcnRlZCAmJiB0aGlzLnJ1bm5pbmcpIHtcbiAgICAgIHRoaXMucnVubmluZyA9IGZhbHNlO1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuaWQpO1xuICAgICAgdGhpcy5yZW1haW5pbmcgLT0gbmV3IERhdGUoKS5nZXRUaW1lKCkgLSB0aGlzLnN0YXJ0ZWQuZ2V0VGltZSgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5yZW1haW5pbmc7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IG5cbiAgICogQHJldHVybnMge251bWJlcn1cbiAgICovXG4gIGluY3JlYXNlKG4pIHtcbiAgICBjb25zdCBydW5uaW5nID0gdGhpcy5ydW5uaW5nO1xuICAgIGlmIChydW5uaW5nKSB7XG4gICAgICB0aGlzLnN0b3AoKTtcbiAgICB9XG4gICAgdGhpcy5yZW1haW5pbmcgKz0gbjtcbiAgICBpZiAocnVubmluZykge1xuICAgICAgdGhpcy5zdGFydCgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5yZW1haW5pbmc7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybnMge251bWJlcn1cbiAgICovXG4gIGdldFRpbWVyTGVmdCgpIHtcbiAgICBpZiAodGhpcy5ydW5uaW5nKSB7XG4gICAgICB0aGlzLnN0b3AoKTtcbiAgICAgIHRoaXMuc3RhcnQoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucmVtYWluaW5nO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgaXNSdW5uaW5nKCkge1xuICAgIHJldHVybiB0aGlzLnJ1bm5pbmc7XG4gIH1cbn1cblxuY29uc3Qgc3dhbFN0cmluZ1BhcmFtcyA9IFsnc3dhbC10aXRsZScsICdzd2FsLWh0bWwnLCAnc3dhbC1mb290ZXInXTtcblxuLyoqXG4gKiBAcGFyYW0ge1N3ZWV0QWxlcnRPcHRpb25zfSBwYXJhbXNcbiAqIEByZXR1cm5zIHtTd2VldEFsZXJ0T3B0aW9uc31cbiAqL1xuY29uc3QgZ2V0VGVtcGxhdGVQYXJhbXMgPSBwYXJhbXMgPT4ge1xuICBjb25zdCB0ZW1wbGF0ZSA9IHR5cGVvZiBwYXJhbXMudGVtcGxhdGUgPT09ICdzdHJpbmcnID8gKC8qKiBAdHlwZSB7SFRNTFRlbXBsYXRlRWxlbWVudH0gKi9kb2N1bWVudC5xdWVyeVNlbGVjdG9yKHBhcmFtcy50ZW1wbGF0ZSkpIDogcGFyYW1zLnRlbXBsYXRlO1xuICBpZiAoIXRlbXBsYXRlKSB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG4gIC8qKiBAdHlwZSB7RG9jdW1lbnRGcmFnbWVudH0gKi9cbiAgY29uc3QgdGVtcGxhdGVDb250ZW50ID0gdGVtcGxhdGUuY29udGVudDtcbiAgc2hvd1dhcm5pbmdzRm9yRWxlbWVudHModGVtcGxhdGVDb250ZW50KTtcbiAgY29uc3QgcmVzdWx0ID0gT2JqZWN0LmFzc2lnbihnZXRTd2FsUGFyYW1zKHRlbXBsYXRlQ29udGVudCksIGdldFN3YWxGdW5jdGlvblBhcmFtcyh0ZW1wbGF0ZUNvbnRlbnQpLCBnZXRTd2FsQnV0dG9ucyh0ZW1wbGF0ZUNvbnRlbnQpLCBnZXRTd2FsSW1hZ2UodGVtcGxhdGVDb250ZW50KSwgZ2V0U3dhbEljb24odGVtcGxhdGVDb250ZW50KSwgZ2V0U3dhbElucHV0KHRlbXBsYXRlQ29udGVudCksIGdldFN3YWxTdHJpbmdQYXJhbXModGVtcGxhdGVDb250ZW50LCBzd2FsU3RyaW5nUGFyYW1zKSk7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7RG9jdW1lbnRGcmFnbWVudH0gdGVtcGxhdGVDb250ZW50XG4gKiBAcmV0dXJucyB7UmVjb3JkPHN0cmluZywgYW55Pn1cbiAqL1xuY29uc3QgZ2V0U3dhbFBhcmFtcyA9IHRlbXBsYXRlQ29udGVudCA9PiB7XG4gIC8qKiBAdHlwZSB7UmVjb3JkPHN0cmluZywgYW55Pn0gKi9cbiAgY29uc3QgcmVzdWx0ID0ge307XG4gIC8qKiBAdHlwZSB7SFRNTEVsZW1lbnRbXX0gKi9cbiAgY29uc3Qgc3dhbFBhcmFtcyA9IEFycmF5LmZyb20odGVtcGxhdGVDb250ZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ3N3YWwtcGFyYW0nKSk7XG4gIHN3YWxQYXJhbXMuZm9yRWFjaChwYXJhbSA9PiB7XG4gICAgc2hvd1dhcm5pbmdzRm9yQXR0cmlidXRlcyhwYXJhbSwgWyduYW1lJywgJ3ZhbHVlJ10pO1xuICAgIGNvbnN0IHBhcmFtTmFtZSA9IC8qKiBAdHlwZSB7a2V5b2YgU3dlZXRBbGVydE9wdGlvbnN9ICovcGFyYW0uZ2V0QXR0cmlidXRlKCduYW1lJyk7XG4gICAgY29uc3QgdmFsdWUgPSBwYXJhbS5nZXRBdHRyaWJ1dGUoJ3ZhbHVlJyk7XG4gICAgaWYgKCFwYXJhbU5hbWUgfHwgIXZhbHVlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0eXBlb2YgZGVmYXVsdFBhcmFtc1twYXJhbU5hbWVdID09PSAnYm9vbGVhbicpIHtcbiAgICAgIHJlc3VsdFtwYXJhbU5hbWVdID0gdmFsdWUgIT09ICdmYWxzZSc7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZGVmYXVsdFBhcmFtc1twYXJhbU5hbWVdID09PSAnb2JqZWN0Jykge1xuICAgICAgcmVzdWx0W3BhcmFtTmFtZV0gPSBKU09OLnBhcnNlKHZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0W3BhcmFtTmFtZV0gPSB2YWx1ZTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0RvY3VtZW50RnJhZ21lbnR9IHRlbXBsYXRlQ29udGVudFxuICogQHJldHVybnMge1JlY29yZDxzdHJpbmcsIGFueT59XG4gKi9cbmNvbnN0IGdldFN3YWxGdW5jdGlvblBhcmFtcyA9IHRlbXBsYXRlQ29udGVudCA9PiB7XG4gIC8qKiBAdHlwZSB7UmVjb3JkPHN0cmluZywgYW55Pn0gKi9cbiAgY29uc3QgcmVzdWx0ID0ge307XG4gIC8qKiBAdHlwZSB7SFRNTEVsZW1lbnRbXX0gKi9cbiAgY29uc3Qgc3dhbEZ1bmN0aW9ucyA9IEFycmF5LmZyb20odGVtcGxhdGVDb250ZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ3N3YWwtZnVuY3Rpb24tcGFyYW0nKSk7XG4gIHN3YWxGdW5jdGlvbnMuZm9yRWFjaChwYXJhbSA9PiB7XG4gICAgY29uc3QgcGFyYW1OYW1lID0gLyoqIEB0eXBlIHtrZXlvZiBTd2VldEFsZXJ0T3B0aW9uc30gKi9wYXJhbS5nZXRBdHRyaWJ1dGUoJ25hbWUnKTtcbiAgICBjb25zdCB2YWx1ZSA9IHBhcmFtLmdldEF0dHJpYnV0ZSgndmFsdWUnKTtcbiAgICBpZiAoIXBhcmFtTmFtZSB8fCAhdmFsdWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmVzdWx0W3BhcmFtTmFtZV0gPSBuZXcgRnVuY3Rpb24oYHJldHVybiAke3ZhbHVlfWApKCk7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0RvY3VtZW50RnJhZ21lbnR9IHRlbXBsYXRlQ29udGVudFxuICogQHJldHVybnMge1JlY29yZDxzdHJpbmcsIGFueT59XG4gKi9cbmNvbnN0IGdldFN3YWxCdXR0b25zID0gdGVtcGxhdGVDb250ZW50ID0+IHtcbiAgLyoqIEB0eXBlIHtSZWNvcmQ8c3RyaW5nLCBhbnk+fSAqL1xuICBjb25zdCByZXN1bHQgPSB7fTtcbiAgLyoqIEB0eXBlIHtIVE1MRWxlbWVudFtdfSAqL1xuICBjb25zdCBzd2FsQnV0dG9ucyA9IEFycmF5LmZyb20odGVtcGxhdGVDb250ZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ3N3YWwtYnV0dG9uJykpO1xuICBzd2FsQnV0dG9ucy5mb3JFYWNoKGJ1dHRvbiA9PiB7XG4gICAgc2hvd1dhcm5pbmdzRm9yQXR0cmlidXRlcyhidXR0b24sIFsndHlwZScsICdjb2xvcicsICdhcmlhLWxhYmVsJ10pO1xuICAgIGNvbnN0IHR5cGUgPSBidXR0b24uZ2V0QXR0cmlidXRlKCd0eXBlJyk7XG4gICAgaWYgKCF0eXBlIHx8ICFbJ2NvbmZpcm0nLCAnY2FuY2VsJywgJ2RlbnknXS5pbmNsdWRlcyh0eXBlKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZXN1bHRbYCR7dHlwZX1CdXR0b25UZXh0YF0gPSBidXR0b24uaW5uZXJIVE1MO1xuICAgIHJlc3VsdFtgc2hvdyR7Y2FwaXRhbGl6ZUZpcnN0TGV0dGVyKHR5cGUpfUJ1dHRvbmBdID0gdHJ1ZTtcbiAgICBpZiAoYnV0dG9uLmhhc0F0dHJpYnV0ZSgnY29sb3InKSkge1xuICAgICAgcmVzdWx0W2Ake3R5cGV9QnV0dG9uQ29sb3JgXSA9IGJ1dHRvbi5nZXRBdHRyaWJ1dGUoJ2NvbG9yJyk7XG4gICAgfVxuICAgIGlmIChidXR0b24uaGFzQXR0cmlidXRlKCdhcmlhLWxhYmVsJykpIHtcbiAgICAgIHJlc3VsdFtgJHt0eXBlfUJ1dHRvbkFyaWFMYWJlbGBdID0gYnV0dG9uLmdldEF0dHJpYnV0ZSgnYXJpYS1sYWJlbCcpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7RG9jdW1lbnRGcmFnbWVudH0gdGVtcGxhdGVDb250ZW50XG4gKiBAcmV0dXJucyB7UGljazxTd2VldEFsZXJ0T3B0aW9ucywgJ2ltYWdlVXJsJyB8ICdpbWFnZVdpZHRoJyB8ICdpbWFnZUhlaWdodCcgfCAnaW1hZ2VBbHQnPn1cbiAqL1xuY29uc3QgZ2V0U3dhbEltYWdlID0gdGVtcGxhdGVDb250ZW50ID0+IHtcbiAgY29uc3QgcmVzdWx0ID0ge307XG4gIC8qKiBAdHlwZSB7SFRNTEVsZW1lbnQgfCBudWxsfSAqL1xuICBjb25zdCBpbWFnZSA9IHRlbXBsYXRlQ29udGVudC5xdWVyeVNlbGVjdG9yKCdzd2FsLWltYWdlJyk7XG4gIGlmIChpbWFnZSkge1xuICAgIHNob3dXYXJuaW5nc0ZvckF0dHJpYnV0ZXMoaW1hZ2UsIFsnc3JjJywgJ3dpZHRoJywgJ2hlaWdodCcsICdhbHQnXSk7XG4gICAgaWYgKGltYWdlLmhhc0F0dHJpYnV0ZSgnc3JjJykpIHtcbiAgICAgIHJlc3VsdC5pbWFnZVVybCA9IGltYWdlLmdldEF0dHJpYnV0ZSgnc3JjJykgfHwgdW5kZWZpbmVkO1xuICAgIH1cbiAgICBpZiAoaW1hZ2UuaGFzQXR0cmlidXRlKCd3aWR0aCcpKSB7XG4gICAgICByZXN1bHQuaW1hZ2VXaWR0aCA9IGltYWdlLmdldEF0dHJpYnV0ZSgnd2lkdGgnKSB8fCB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGlmIChpbWFnZS5oYXNBdHRyaWJ1dGUoJ2hlaWdodCcpKSB7XG4gICAgICByZXN1bHQuaW1hZ2VIZWlnaHQgPSBpbWFnZS5nZXRBdHRyaWJ1dGUoJ2hlaWdodCcpIHx8IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgaWYgKGltYWdlLmhhc0F0dHJpYnV0ZSgnYWx0JykpIHtcbiAgICAgIHJlc3VsdC5pbWFnZUFsdCA9IGltYWdlLmdldEF0dHJpYnV0ZSgnYWx0JykgfHwgdW5kZWZpbmVkO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0RvY3VtZW50RnJhZ21lbnR9IHRlbXBsYXRlQ29udGVudFxuICogQHJldHVybnMge1JlY29yZDxzdHJpbmcsIGFueT59XG4gKi9cbmNvbnN0IGdldFN3YWxJY29uID0gdGVtcGxhdGVDb250ZW50ID0+IHtcbiAgY29uc3QgcmVzdWx0ID0ge307XG4gIC8qKiBAdHlwZSB7SFRNTEVsZW1lbnQgfCBudWxsfSAqL1xuICBjb25zdCBpY29uID0gdGVtcGxhdGVDb250ZW50LnF1ZXJ5U2VsZWN0b3IoJ3N3YWwtaWNvbicpO1xuICBpZiAoaWNvbikge1xuICAgIHNob3dXYXJuaW5nc0ZvckF0dHJpYnV0ZXMoaWNvbiwgWyd0eXBlJywgJ2NvbG9yJ10pO1xuICAgIGlmIChpY29uLmhhc0F0dHJpYnV0ZSgndHlwZScpKSB7XG4gICAgICByZXN1bHQuaWNvbiA9IGljb24uZ2V0QXR0cmlidXRlKCd0eXBlJyk7XG4gICAgfVxuICAgIGlmIChpY29uLmhhc0F0dHJpYnV0ZSgnY29sb3InKSkge1xuICAgICAgcmVzdWx0Lmljb25Db2xvciA9IGljb24uZ2V0QXR0cmlidXRlKCdjb2xvcicpO1xuICAgIH1cbiAgICByZXN1bHQuaWNvbkh0bWwgPSBpY29uLmlubmVySFRNTDtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0RvY3VtZW50RnJhZ21lbnR9IHRlbXBsYXRlQ29udGVudFxuICogQHJldHVybnMge1JlY29yZDxzdHJpbmcsIGFueT59XG4gKi9cbmNvbnN0IGdldFN3YWxJbnB1dCA9IHRlbXBsYXRlQ29udGVudCA9PiB7XG4gIC8qKiBAdHlwZSB7UmVjb3JkPHN0cmluZywgYW55Pn0gKi9cbiAgY29uc3QgcmVzdWx0ID0ge307XG4gIC8qKiBAdHlwZSB7SFRNTEVsZW1lbnQgfCBudWxsfSAqL1xuICBjb25zdCBpbnB1dCA9IHRlbXBsYXRlQ29udGVudC5xdWVyeVNlbGVjdG9yKCdzd2FsLWlucHV0Jyk7XG4gIGlmIChpbnB1dCkge1xuICAgIHNob3dXYXJuaW5nc0ZvckF0dHJpYnV0ZXMoaW5wdXQsIFsndHlwZScsICdsYWJlbCcsICdwbGFjZWhvbGRlcicsICd2YWx1ZSddKTtcbiAgICByZXN1bHQuaW5wdXQgPSBpbnB1dC5nZXRBdHRyaWJ1dGUoJ3R5cGUnKSB8fCAndGV4dCc7XG4gICAgaWYgKGlucHV0Lmhhc0F0dHJpYnV0ZSgnbGFiZWwnKSkge1xuICAgICAgcmVzdWx0LmlucHV0TGFiZWwgPSBpbnB1dC5nZXRBdHRyaWJ1dGUoJ2xhYmVsJyk7XG4gICAgfVxuICAgIGlmIChpbnB1dC5oYXNBdHRyaWJ1dGUoJ3BsYWNlaG9sZGVyJykpIHtcbiAgICAgIHJlc3VsdC5pbnB1dFBsYWNlaG9sZGVyID0gaW5wdXQuZ2V0QXR0cmlidXRlKCdwbGFjZWhvbGRlcicpO1xuICAgIH1cbiAgICBpZiAoaW5wdXQuaGFzQXR0cmlidXRlKCd2YWx1ZScpKSB7XG4gICAgICByZXN1bHQuaW5wdXRWYWx1ZSA9IGlucHV0LmdldEF0dHJpYnV0ZSgndmFsdWUnKTtcbiAgICB9XG4gIH1cbiAgLyoqIEB0eXBlIHtIVE1MRWxlbWVudFtdfSAqL1xuICBjb25zdCBpbnB1dE9wdGlvbnMgPSBBcnJheS5mcm9tKHRlbXBsYXRlQ29udGVudC5xdWVyeVNlbGVjdG9yQWxsKCdzd2FsLWlucHV0LW9wdGlvbicpKTtcbiAgaWYgKGlucHV0T3B0aW9ucy5sZW5ndGgpIHtcbiAgICByZXN1bHQuaW5wdXRPcHRpb25zID0ge307XG4gICAgaW5wdXRPcHRpb25zLmZvckVhY2gob3B0aW9uID0+IHtcbiAgICAgIHNob3dXYXJuaW5nc0ZvckF0dHJpYnV0ZXMob3B0aW9uLCBbJ3ZhbHVlJ10pO1xuICAgICAgY29uc3Qgb3B0aW9uVmFsdWUgPSBvcHRpb24uZ2V0QXR0cmlidXRlKCd2YWx1ZScpO1xuICAgICAgaWYgKCFvcHRpb25WYWx1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBvcHRpb25OYW1lID0gb3B0aW9uLmlubmVySFRNTDtcbiAgICAgIHJlc3VsdC5pbnB1dE9wdGlvbnNbb3B0aW9uVmFsdWVdID0gb3B0aW9uTmFtZTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0RvY3VtZW50RnJhZ21lbnR9IHRlbXBsYXRlQ29udGVudFxuICogQHBhcmFtIHtzdHJpbmdbXX0gcGFyYW1OYW1lc1xuICogQHJldHVybnMge1JlY29yZDxzdHJpbmcsIGFueT59XG4gKi9cbmNvbnN0IGdldFN3YWxTdHJpbmdQYXJhbXMgPSAodGVtcGxhdGVDb250ZW50LCBwYXJhbU5hbWVzKSA9PiB7XG4gIC8qKiBAdHlwZSB7UmVjb3JkPHN0cmluZywgYW55Pn0gKi9cbiAgY29uc3QgcmVzdWx0ID0ge307XG4gIGZvciAoY29uc3QgaSBpbiBwYXJhbU5hbWVzKSB7XG4gICAgY29uc3QgcGFyYW1OYW1lID0gcGFyYW1OYW1lc1tpXTtcbiAgICAvKiogQHR5cGUge0hUTUxFbGVtZW50IHwgbnVsbH0gKi9cbiAgICBjb25zdCB0YWcgPSB0ZW1wbGF0ZUNvbnRlbnQucXVlcnlTZWxlY3RvcihwYXJhbU5hbWUpO1xuICAgIGlmICh0YWcpIHtcbiAgICAgIHNob3dXYXJuaW5nc0ZvckF0dHJpYnV0ZXModGFnLCBbXSk7XG4gICAgICByZXN1bHRbcGFyYW1OYW1lLnJlcGxhY2UoL15zd2FsLS8sICcnKV0gPSB0YWcuaW5uZXJIVE1MLnRyaW0oKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtEb2N1bWVudEZyYWdtZW50fSB0ZW1wbGF0ZUNvbnRlbnRcbiAqL1xuY29uc3Qgc2hvd1dhcm5pbmdzRm9yRWxlbWVudHMgPSB0ZW1wbGF0ZUNvbnRlbnQgPT4ge1xuICBjb25zdCBhbGxvd2VkRWxlbWVudHMgPSBzd2FsU3RyaW5nUGFyYW1zLmNvbmNhdChbJ3N3YWwtcGFyYW0nLCAnc3dhbC1mdW5jdGlvbi1wYXJhbScsICdzd2FsLWJ1dHRvbicsICdzd2FsLWltYWdlJywgJ3N3YWwtaWNvbicsICdzd2FsLWlucHV0JywgJ3N3YWwtaW5wdXQtb3B0aW9uJ10pO1xuICBBcnJheS5mcm9tKHRlbXBsYXRlQ29udGVudC5jaGlsZHJlbikuZm9yRWFjaChlbCA9PiB7XG4gICAgY29uc3QgdGFnTmFtZSA9IGVsLnRhZ05hbWUudG9Mb3dlckNhc2UoKTtcbiAgICBpZiAoIWFsbG93ZWRFbGVtZW50cy5pbmNsdWRlcyh0YWdOYW1lKSkge1xuICAgICAgd2FybihgVW5yZWNvZ25pemVkIGVsZW1lbnQgPCR7dGFnTmFtZX0+YCk7XG4gICAgfVxuICB9KTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxcbiAqIEBwYXJhbSB7c3RyaW5nW119IGFsbG93ZWRBdHRyaWJ1dGVzXG4gKi9cbmNvbnN0IHNob3dXYXJuaW5nc0ZvckF0dHJpYnV0ZXMgPSAoZWwsIGFsbG93ZWRBdHRyaWJ1dGVzKSA9PiB7XG4gIEFycmF5LmZyb20oZWwuYXR0cmlidXRlcykuZm9yRWFjaChhdHRyaWJ1dGUgPT4ge1xuICAgIGlmIChhbGxvd2VkQXR0cmlidXRlcy5pbmRleE9mKGF0dHJpYnV0ZS5uYW1lKSA9PT0gLTEpIHtcbiAgICAgIHdhcm4oW2BVbnJlY29nbml6ZWQgYXR0cmlidXRlIFwiJHthdHRyaWJ1dGUubmFtZX1cIiBvbiA8JHtlbC50YWdOYW1lLnRvTG93ZXJDYXNlKCl9Pi5gLCBgJHthbGxvd2VkQXR0cmlidXRlcy5sZW5ndGggPyBgQWxsb3dlZCBhdHRyaWJ1dGVzIGFyZTogJHthbGxvd2VkQXR0cmlidXRlcy5qb2luKCcsICcpfWAgOiAnVG8gc2V0IHRoZSB2YWx1ZSwgdXNlIEhUTUwgd2l0aGluIHRoZSBlbGVtZW50Lid9YF0pO1xuICAgIH1cbiAgfSk7XG59O1xuXG5jb25zdCBTSE9XX0NMQVNTX1RJTUVPVVQgPSAxMDtcblxuLyoqXG4gKiBPcGVuIHBvcHVwLCBhZGQgbmVjZXNzYXJ5IGNsYXNzZXMgYW5kIHN0eWxlcywgZml4IHNjcm9sbGJhclxuICpcbiAqIEBwYXJhbSB7U3dlZXRBbGVydE9wdGlvbnN9IHBhcmFtc1xuICovXG5jb25zdCBvcGVuUG9wdXAgPSBwYXJhbXMgPT4ge1xuICBjb25zdCBjb250YWluZXIgPSBnZXRDb250YWluZXIoKTtcbiAgY29uc3QgcG9wdXAgPSBnZXRQb3B1cCgpO1xuICBpZiAodHlwZW9mIHBhcmFtcy53aWxsT3BlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHBhcmFtcy53aWxsT3Blbihwb3B1cCk7XG4gIH1cbiAgZ2xvYmFsU3RhdGUuZXZlbnRFbWl0dGVyLmVtaXQoJ3dpbGxPcGVuJywgcG9wdXApO1xuICBjb25zdCBib2R5U3R5bGVzID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZG9jdW1lbnQuYm9keSk7XG4gIGNvbnN0IGluaXRpYWxCb2R5T3ZlcmZsb3cgPSBib2R5U3R5bGVzLm92ZXJmbG93WTtcbiAgYWRkQ2xhc3Nlcyhjb250YWluZXIsIHBvcHVwLCBwYXJhbXMpO1xuXG4gIC8vIHNjcm9sbGluZyBpcyAnaGlkZGVuJyB1bnRpbCBhbmltYXRpb24gaXMgZG9uZSwgYWZ0ZXIgdGhhdCAnYXV0bydcbiAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgc2V0U2Nyb2xsaW5nVmlzaWJpbGl0eShjb250YWluZXIsIHBvcHVwKTtcbiAgfSwgU0hPV19DTEFTU19USU1FT1VUKTtcbiAgaWYgKGlzTW9kYWwoKSkge1xuICAgIGZpeFNjcm9sbENvbnRhaW5lcihjb250YWluZXIsIHBhcmFtcy5zY3JvbGxiYXJQYWRkaW5nLCBpbml0aWFsQm9keU92ZXJmbG93KTtcbiAgICBzZXRBcmlhSGlkZGVuKCk7XG4gIH1cbiAgaWYgKCFpc1RvYXN0KCkgJiYgIWdsb2JhbFN0YXRlLnByZXZpb3VzQWN0aXZlRWxlbWVudCkge1xuICAgIGdsb2JhbFN0YXRlLnByZXZpb3VzQWN0aXZlRWxlbWVudCA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG4gIH1cbiAgaWYgKHR5cGVvZiBwYXJhbXMuZGlkT3BlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHNldFRpbWVvdXQoKCkgPT4gcGFyYW1zLmRpZE9wZW4ocG9wdXApKTtcbiAgfVxuICBnbG9iYWxTdGF0ZS5ldmVudEVtaXR0ZXIuZW1pdCgnZGlkT3BlbicsIHBvcHVwKTtcbiAgcmVtb3ZlQ2xhc3MoY29udGFpbmVyLCBzd2FsQ2xhc3Nlc1snbm8tdHJhbnNpdGlvbiddKTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtBbmltYXRpb25FdmVudH0gZXZlbnRcbiAqL1xuY29uc3Qgc3dhbE9wZW5BbmltYXRpb25GaW5pc2hlZCA9IGV2ZW50ID0+IHtcbiAgY29uc3QgcG9wdXAgPSBnZXRQb3B1cCgpO1xuICBpZiAoZXZlbnQudGFyZ2V0ICE9PSBwb3B1cCB8fCAhYW5pbWF0aW9uRW5kRXZlbnQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgY29udGFpbmVyID0gZ2V0Q29udGFpbmVyKCk7XG4gIHBvcHVwLnJlbW92ZUV2ZW50TGlzdGVuZXIoYW5pbWF0aW9uRW5kRXZlbnQsIHN3YWxPcGVuQW5pbWF0aW9uRmluaXNoZWQpO1xuICBjb250YWluZXIuc3R5bGUub3ZlcmZsb3dZID0gJ2F1dG8nO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBjb250YWluZXJcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHBvcHVwXG4gKi9cbmNvbnN0IHNldFNjcm9sbGluZ1Zpc2liaWxpdHkgPSAoY29udGFpbmVyLCBwb3B1cCkgPT4ge1xuICBpZiAoYW5pbWF0aW9uRW5kRXZlbnQgJiYgaGFzQ3NzQW5pbWF0aW9uKHBvcHVwKSkge1xuICAgIGNvbnRhaW5lci5zdHlsZS5vdmVyZmxvd1kgPSAnaGlkZGVuJztcbiAgICBwb3B1cC5hZGRFdmVudExpc3RlbmVyKGFuaW1hdGlvbkVuZEV2ZW50LCBzd2FsT3BlbkFuaW1hdGlvbkZpbmlzaGVkKTtcbiAgfSBlbHNlIHtcbiAgICBjb250YWluZXIuc3R5bGUub3ZlcmZsb3dZID0gJ2F1dG8nO1xuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGNvbnRhaW5lclxuICogQHBhcmFtIHtib29sZWFufSBzY3JvbGxiYXJQYWRkaW5nXG4gKiBAcGFyYW0ge3N0cmluZ30gaW5pdGlhbEJvZHlPdmVyZmxvd1xuICovXG5jb25zdCBmaXhTY3JvbGxDb250YWluZXIgPSAoY29udGFpbmVyLCBzY3JvbGxiYXJQYWRkaW5nLCBpbml0aWFsQm9keU92ZXJmbG93KSA9PiB7XG4gIGlPU2ZpeCgpO1xuICBpZiAoc2Nyb2xsYmFyUGFkZGluZyAmJiBpbml0aWFsQm9keU92ZXJmbG93ICE9PSAnaGlkZGVuJykge1xuICAgIHJlcGxhY2VTY3JvbGxiYXJXaXRoUGFkZGluZyhpbml0aWFsQm9keU92ZXJmbG93KTtcbiAgfVxuXG4gIC8vIHN3ZWV0YWxlcnQyL2lzc3Vlcy8xMjQ3XG4gIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgIGNvbnRhaW5lci5zY3JvbGxUb3AgPSAwO1xuICB9KTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gY29udGFpbmVyXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBwb3B1cFxuICogQHBhcmFtIHtTd2VldEFsZXJ0T3B0aW9uc30gcGFyYW1zXG4gKi9cbmNvbnN0IGFkZENsYXNzZXMgPSAoY29udGFpbmVyLCBwb3B1cCwgcGFyYW1zKSA9PiB7XG4gIGFkZENsYXNzKGNvbnRhaW5lciwgcGFyYW1zLnNob3dDbGFzcy5iYWNrZHJvcCk7XG4gIGlmIChwYXJhbXMuYW5pbWF0aW9uKSB7XG4gICAgLy8gdGhpcyB3b3JrYXJvdW5kIHdpdGggb3BhY2l0eSBpcyBuZWVkZWQgZm9yIGh0dHBzOi8vZ2l0aHViLmNvbS9zd2VldGFsZXJ0Mi9zd2VldGFsZXJ0Mi9pc3N1ZXMvMjA1OVxuICAgIHBvcHVwLnN0eWxlLnNldFByb3BlcnR5KCdvcGFjaXR5JywgJzAnLCAnaW1wb3J0YW50Jyk7XG4gICAgc2hvdyhwb3B1cCwgJ2dyaWQnKTtcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIC8vIEFuaW1hdGUgcG9wdXAgcmlnaHQgYWZ0ZXIgc2hvd2luZyBpdFxuICAgICAgYWRkQ2xhc3MocG9wdXAsIHBhcmFtcy5zaG93Q2xhc3MucG9wdXApO1xuICAgICAgLy8gYW5kIHJlbW92ZSB0aGUgb3BhY2l0eSB3b3JrYXJvdW5kXG4gICAgICBwb3B1cC5zdHlsZS5yZW1vdmVQcm9wZXJ0eSgnb3BhY2l0eScpO1xuICAgIH0sIFNIT1dfQ0xBU1NfVElNRU9VVCk7IC8vIDEwbXMgaW4gb3JkZXIgdG8gZml4ICMyMDYyXG4gIH0gZWxzZSB7XG4gICAgc2hvdyhwb3B1cCwgJ2dyaWQnKTtcbiAgfVxuICBhZGRDbGFzcyhbZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCBkb2N1bWVudC5ib2R5XSwgc3dhbENsYXNzZXMuc2hvd24pO1xuICBpZiAocGFyYW1zLmhlaWdodEF1dG8gJiYgcGFyYW1zLmJhY2tkcm9wICYmICFwYXJhbXMudG9hc3QpIHtcbiAgICBhZGRDbGFzcyhbZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCBkb2N1bWVudC5ib2R5XSwgc3dhbENsYXNzZXNbJ2hlaWdodC1hdXRvJ10pO1xuICB9XG59O1xuXG52YXIgZGVmYXVsdElucHV0VmFsaWRhdG9ycyA9IHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmdcbiAgICogQHBhcmFtIHtzdHJpbmd9IFt2YWxpZGF0aW9uTWVzc2FnZV1cbiAgICogQHJldHVybnMge1Byb21pc2U8c3RyaW5nIHwgdm9pZD59XG4gICAqL1xuICBlbWFpbDogKHN0cmluZywgdmFsaWRhdGlvbk1lc3NhZ2UpID0+IHtcbiAgICByZXR1cm4gL15bYS16QS1aMC05LitfJy1dK0BbYS16QS1aMC05Li1dK1xcLlthLXpBLVowLTktXSskLy50ZXN0KHN0cmluZykgPyBQcm9taXNlLnJlc29sdmUoKSA6IFByb21pc2UucmVzb2x2ZSh2YWxpZGF0aW9uTWVzc2FnZSB8fCAnSW52YWxpZCBlbWFpbCBhZGRyZXNzJyk7XG4gIH0sXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbdmFsaWRhdGlvbk1lc3NhZ2VdXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPHN0cmluZyB8IHZvaWQ+fVxuICAgKi9cbiAgdXJsOiAoc3RyaW5nLCB2YWxpZGF0aW9uTWVzc2FnZSkgPT4ge1xuICAgIC8vIHRha2VuIGZyb20gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzM4MDk0MzUgd2l0aCBhIHNtYWxsIGNoYW5nZSBmcm9tICMxMzA2IGFuZCAjMjAxM1xuICAgIHJldHVybiAvXmh0dHBzPzpcXC9cXC8od3d3XFwuKT9bLWEtekEtWjAtOUA6JS5fK34jPV17MSwyNTZ9XFwuW2Etel17Miw2M31cXGIoWy1hLXpBLVowLTlAOiVfKy5+Iz8mLz1dKikkLy50ZXN0KHN0cmluZykgPyBQcm9taXNlLnJlc29sdmUoKSA6IFByb21pc2UucmVzb2x2ZSh2YWxpZGF0aW9uTWVzc2FnZSB8fCAnSW52YWxpZCBVUkwnKTtcbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge1N3ZWV0QWxlcnRPcHRpb25zfSBwYXJhbXNcbiAqL1xuZnVuY3Rpb24gc2V0RGVmYXVsdElucHV0VmFsaWRhdG9ycyhwYXJhbXMpIHtcbiAgLy8gVXNlIGRlZmF1bHQgYGlucHV0VmFsaWRhdG9yYCBmb3Igc3VwcG9ydGVkIGlucHV0IHR5cGVzIGlmIG5vdCBwcm92aWRlZFxuICBpZiAocGFyYW1zLmlucHV0VmFsaWRhdG9yKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChwYXJhbXMuaW5wdXQgPT09ICdlbWFpbCcpIHtcbiAgICBwYXJhbXMuaW5wdXRWYWxpZGF0b3IgPSBkZWZhdWx0SW5wdXRWYWxpZGF0b3JzWydlbWFpbCddO1xuICB9XG4gIGlmIChwYXJhbXMuaW5wdXQgPT09ICd1cmwnKSB7XG4gICAgcGFyYW1zLmlucHV0VmFsaWRhdG9yID0gZGVmYXVsdElucHV0VmFsaWRhdG9yc1sndXJsJ107XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge1N3ZWV0QWxlcnRPcHRpb25zfSBwYXJhbXNcbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVDdXN0b21UYXJnZXRFbGVtZW50KHBhcmFtcykge1xuICAvLyBEZXRlcm1pbmUgaWYgdGhlIGN1c3RvbSB0YXJnZXQgZWxlbWVudCBpcyB2YWxpZFxuICBpZiAoIXBhcmFtcy50YXJnZXQgfHwgdHlwZW9mIHBhcmFtcy50YXJnZXQgPT09ICdzdHJpbmcnICYmICFkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHBhcmFtcy50YXJnZXQpIHx8IHR5cGVvZiBwYXJhbXMudGFyZ2V0ICE9PSAnc3RyaW5nJyAmJiAhcGFyYW1zLnRhcmdldC5hcHBlbmRDaGlsZCkge1xuICAgIHdhcm4oJ1RhcmdldCBwYXJhbWV0ZXIgaXMgbm90IHZhbGlkLCBkZWZhdWx0aW5nIHRvIFwiYm9keVwiJyk7XG4gICAgcGFyYW1zLnRhcmdldCA9ICdib2R5JztcbiAgfVxufVxuXG4vKipcbiAqIFNldCB0eXBlLCB0ZXh0IGFuZCBhY3Rpb25zIG9uIHBvcHVwXG4gKlxuICogQHBhcmFtIHtTd2VldEFsZXJ0T3B0aW9uc30gcGFyYW1zXG4gKi9cbmZ1bmN0aW9uIHNldFBhcmFtZXRlcnMocGFyYW1zKSB7XG4gIHNldERlZmF1bHRJbnB1dFZhbGlkYXRvcnMocGFyYW1zKTtcblxuICAvLyBzaG93TG9hZGVyT25Db25maXJtICYmIHByZUNvbmZpcm1cbiAgaWYgKHBhcmFtcy5zaG93TG9hZGVyT25Db25maXJtICYmICFwYXJhbXMucHJlQ29uZmlybSkge1xuICAgIHdhcm4oJ3Nob3dMb2FkZXJPbkNvbmZpcm0gaXMgc2V0IHRvIHRydWUsIGJ1dCBwcmVDb25maXJtIGlzIG5vdCBkZWZpbmVkLlxcbicgKyAnc2hvd0xvYWRlck9uQ29uZmlybSBzaG91bGQgYmUgdXNlZCB0b2dldGhlciB3aXRoIHByZUNvbmZpcm0sIHNlZSB1c2FnZSBleGFtcGxlOlxcbicgKyAnaHR0cHM6Ly9zd2VldGFsZXJ0Mi5naXRodWIuaW8vI2FqYXgtcmVxdWVzdCcpO1xuICB9XG4gIHZhbGlkYXRlQ3VzdG9tVGFyZ2V0RWxlbWVudChwYXJhbXMpO1xuXG4gIC8vIFJlcGxhY2UgbmV3bGluZXMgd2l0aCA8YnI+IGluIHRpdGxlXG4gIGlmICh0eXBlb2YgcGFyYW1zLnRpdGxlID09PSAnc3RyaW5nJykge1xuICAgIHBhcmFtcy50aXRsZSA9IHBhcmFtcy50aXRsZS5zcGxpdCgnXFxuJykuam9pbignPGJyIC8+Jyk7XG4gIH1cbiAgaW5pdChwYXJhbXMpO1xufVxuXG4vKiogQHR5cGUge1N3ZWV0QWxlcnR9ICovXG5sZXQgY3VycmVudEluc3RhbmNlO1xudmFyIF9wcm9taXNlID0gLyojX19QVVJFX18qL25ldyBXZWFrTWFwKCk7XG5jbGFzcyBTd2VldEFsZXJ0IHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7Li4uYW55fSBhcmdzXG4gICAqIEB0aGlzIHtTd2VldEFsZXJ0fVxuICAgKi9cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgLyoqXG4gICAgICogQHR5cGUge1Byb21pc2U8U3dlZXRBbGVydFJlc3VsdD59XG4gICAgICovXG4gICAgX2NsYXNzUHJpdmF0ZUZpZWxkSW5pdFNwZWModGhpcywgX3Byb21pc2UsIHZvaWQgMCk7XG4gICAgLy8gUHJldmVudCBydW4gaW4gTm9kZSBlbnZcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY3VycmVudEluc3RhbmNlID0gdGhpcztcblxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuICAgIGNvbnN0IG91dGVyUGFyYW1zID0gT2JqZWN0LmZyZWV6ZSh0aGlzLmNvbnN0cnVjdG9yLmFyZ3NUb1BhcmFtcyhhcmdzKSk7XG5cbiAgICAvKiogQHR5cGUge1JlYWRvbmx5PFN3ZWV0QWxlcnRPcHRpb25zPn0gKi9cbiAgICB0aGlzLnBhcmFtcyA9IG91dGVyUGFyYW1zO1xuXG4gICAgLyoqIEB0eXBlIHtib29sZWFufSAqL1xuICAgIHRoaXMuaXNBd2FpdGluZ1Byb21pc2UgPSBmYWxzZTtcbiAgICBfY2xhc3NQcml2YXRlRmllbGRTZXQyKF9wcm9taXNlLCB0aGlzLCB0aGlzLl9tYWluKGN1cnJlbnRJbnN0YW5jZS5wYXJhbXMpKTtcbiAgfVxuICBfbWFpbih1c2VyUGFyYW1zKSB7XG4gICAgbGV0IG1peGluUGFyYW1zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICBzaG93V2FybmluZ3NGb3JQYXJhbXMoT2JqZWN0LmFzc2lnbih7fSwgbWl4aW5QYXJhbXMsIHVzZXJQYXJhbXMpKTtcbiAgICBpZiAoZ2xvYmFsU3RhdGUuY3VycmVudEluc3RhbmNlKSB7XG4gICAgICBjb25zdCBzd2FsUHJvbWlzZVJlc29sdmUgPSBwcml2YXRlTWV0aG9kcy5zd2FsUHJvbWlzZVJlc29sdmUuZ2V0KGdsb2JhbFN0YXRlLmN1cnJlbnRJbnN0YW5jZSk7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGlzQXdhaXRpbmdQcm9taXNlXG4gICAgICB9ID0gZ2xvYmFsU3RhdGUuY3VycmVudEluc3RhbmNlO1xuICAgICAgZ2xvYmFsU3RhdGUuY3VycmVudEluc3RhbmNlLl9kZXN0cm95KCk7XG4gICAgICBpZiAoIWlzQXdhaXRpbmdQcm9taXNlKSB7XG4gICAgICAgIHN3YWxQcm9taXNlUmVzb2x2ZSh7XG4gICAgICAgICAgaXNEaXNtaXNzZWQ6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoaXNNb2RhbCgpKSB7XG4gICAgICAgIHVuc2V0QXJpYUhpZGRlbigpO1xuICAgICAgfVxuICAgIH1cbiAgICBnbG9iYWxTdGF0ZS5jdXJyZW50SW5zdGFuY2UgPSBjdXJyZW50SW5zdGFuY2U7XG4gICAgY29uc3QgaW5uZXJQYXJhbXMgPSBwcmVwYXJlUGFyYW1zKHVzZXJQYXJhbXMsIG1peGluUGFyYW1zKTtcbiAgICBzZXRQYXJhbWV0ZXJzKGlubmVyUGFyYW1zKTtcbiAgICBPYmplY3QuZnJlZXplKGlubmVyUGFyYW1zKTtcblxuICAgIC8vIGNsZWFyIHRoZSBwcmV2aW91cyB0aW1lclxuICAgIGlmIChnbG9iYWxTdGF0ZS50aW1lb3V0KSB7XG4gICAgICBnbG9iYWxTdGF0ZS50aW1lb3V0LnN0b3AoKTtcbiAgICAgIGRlbGV0ZSBnbG9iYWxTdGF0ZS50aW1lb3V0O1xuICAgIH1cblxuICAgIC8vIGNsZWFyIHRoZSByZXN0b3JlIGZvY3VzIHRpbWVvdXRcbiAgICBjbGVhclRpbWVvdXQoZ2xvYmFsU3RhdGUucmVzdG9yZUZvY3VzVGltZW91dCk7XG4gICAgY29uc3QgZG9tQ2FjaGUgPSBwb3B1bGF0ZURvbUNhY2hlKGN1cnJlbnRJbnN0YW5jZSk7XG4gICAgcmVuZGVyKGN1cnJlbnRJbnN0YW5jZSwgaW5uZXJQYXJhbXMpO1xuICAgIHByaXZhdGVQcm9wcy5pbm5lclBhcmFtcy5zZXQoY3VycmVudEluc3RhbmNlLCBpbm5lclBhcmFtcyk7XG4gICAgcmV0dXJuIHN3YWxQcm9taXNlKGN1cnJlbnRJbnN0YW5jZSwgZG9tQ2FjaGUsIGlubmVyUGFyYW1zKTtcbiAgfVxuXG4gIC8vIGBjYXRjaGAgY2Fubm90IGJlIHRoZSBuYW1lIG9mIGEgbW9kdWxlIGV4cG9ydCwgc28gd2UgZGVmaW5lIG91ciB0aGVuYWJsZSBtZXRob2RzIGhlcmUgaW5zdGVhZFxuICB0aGVuKG9uRnVsZmlsbGVkKSB7XG4gICAgcmV0dXJuIF9jbGFzc1ByaXZhdGVGaWVsZEdldDIoX3Byb21pc2UsIHRoaXMpLnRoZW4ob25GdWxmaWxsZWQpO1xuICB9XG4gIGZpbmFsbHkob25GaW5hbGx5KSB7XG4gICAgcmV0dXJuIF9jbGFzc1ByaXZhdGVGaWVsZEdldDIoX3Byb21pc2UsIHRoaXMpLmZpbmFsbHkob25GaW5hbGx5KTtcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7U3dlZXRBbGVydH0gaW5zdGFuY2VcbiAqIEBwYXJhbSB7RG9tQ2FjaGV9IGRvbUNhY2hlXG4gKiBAcGFyYW0ge1N3ZWV0QWxlcnRPcHRpb25zfSBpbm5lclBhcmFtc1xuICogQHJldHVybnMge1Byb21pc2V9XG4gKi9cbmNvbnN0IHN3YWxQcm9taXNlID0gKGluc3RhbmNlLCBkb21DYWNoZSwgaW5uZXJQYXJhbXMpID0+IHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAvLyBmdW5jdGlvbnMgdG8gaGFuZGxlIGFsbCBjbG9zaW5ncy9kaXNtaXNzYWxzXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtEaXNtaXNzUmVhc29ufSBkaXNtaXNzXG4gICAgICovXG4gICAgY29uc3QgZGlzbWlzc1dpdGggPSBkaXNtaXNzID0+IHtcbiAgICAgIGluc3RhbmNlLmNsb3NlKHtcbiAgICAgICAgaXNEaXNtaXNzZWQ6IHRydWUsXG4gICAgICAgIGRpc21pc3NcbiAgICAgIH0pO1xuICAgIH07XG4gICAgcHJpdmF0ZU1ldGhvZHMuc3dhbFByb21pc2VSZXNvbHZlLnNldChpbnN0YW5jZSwgcmVzb2x2ZSk7XG4gICAgcHJpdmF0ZU1ldGhvZHMuc3dhbFByb21pc2VSZWplY3Quc2V0KGluc3RhbmNlLCByZWplY3QpO1xuICAgIGRvbUNhY2hlLmNvbmZpcm1CdXR0b24ub25jbGljayA9ICgpID0+IHtcbiAgICAgIGhhbmRsZUNvbmZpcm1CdXR0b25DbGljayhpbnN0YW5jZSk7XG4gICAgfTtcbiAgICBkb21DYWNoZS5kZW55QnV0dG9uLm9uY2xpY2sgPSAoKSA9PiB7XG4gICAgICBoYW5kbGVEZW55QnV0dG9uQ2xpY2soaW5zdGFuY2UpO1xuICAgIH07XG4gICAgZG9tQ2FjaGUuY2FuY2VsQnV0dG9uLm9uY2xpY2sgPSAoKSA9PiB7XG4gICAgICBoYW5kbGVDYW5jZWxCdXR0b25DbGljayhpbnN0YW5jZSwgZGlzbWlzc1dpdGgpO1xuICAgIH07XG4gICAgZG9tQ2FjaGUuY2xvc2VCdXR0b24ub25jbGljayA9ICgpID0+IHtcbiAgICAgIGRpc21pc3NXaXRoKERpc21pc3NSZWFzb24uY2xvc2UpO1xuICAgIH07XG4gICAgaGFuZGxlUG9wdXBDbGljayhpbm5lclBhcmFtcywgZG9tQ2FjaGUsIGRpc21pc3NXaXRoKTtcbiAgICBhZGRLZXlkb3duSGFuZGxlcihnbG9iYWxTdGF0ZSwgaW5uZXJQYXJhbXMsIGRpc21pc3NXaXRoKTtcbiAgICBoYW5kbGVJbnB1dE9wdGlvbnNBbmRWYWx1ZShpbnN0YW5jZSwgaW5uZXJQYXJhbXMpO1xuICAgIG9wZW5Qb3B1cChpbm5lclBhcmFtcyk7XG4gICAgc2V0dXBUaW1lcihnbG9iYWxTdGF0ZSwgaW5uZXJQYXJhbXMsIGRpc21pc3NXaXRoKTtcbiAgICBpbml0Rm9jdXMoZG9tQ2FjaGUsIGlubmVyUGFyYW1zKTtcblxuICAgIC8vIFNjcm9sbCBjb250YWluZXIgdG8gdG9wIG9uIG9wZW4gKCMxMjQ3LCAjMTk0NilcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGRvbUNhY2hlLmNvbnRhaW5lci5zY3JvbGxUb3AgPSAwO1xuICAgIH0pO1xuICB9KTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtTd2VldEFsZXJ0T3B0aW9uc30gdXNlclBhcmFtc1xuICogQHBhcmFtIHtTd2VldEFsZXJ0T3B0aW9uc30gbWl4aW5QYXJhbXNcbiAqIEByZXR1cm5zIHtTd2VldEFsZXJ0T3B0aW9uc31cbiAqL1xuY29uc3QgcHJlcGFyZVBhcmFtcyA9ICh1c2VyUGFyYW1zLCBtaXhpblBhcmFtcykgPT4ge1xuICBjb25zdCB0ZW1wbGF0ZVBhcmFtcyA9IGdldFRlbXBsYXRlUGFyYW1zKHVzZXJQYXJhbXMpO1xuICBjb25zdCBwYXJhbXMgPSBPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0UGFyYW1zLCBtaXhpblBhcmFtcywgdGVtcGxhdGVQYXJhbXMsIHVzZXJQYXJhbXMpOyAvLyBwcmVjZWRlbmNlIGlzIGRlc2NyaWJlZCBpbiAjMjEzMVxuICBwYXJhbXMuc2hvd0NsYXNzID0gT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdFBhcmFtcy5zaG93Q2xhc3MsIHBhcmFtcy5zaG93Q2xhc3MpO1xuICBwYXJhbXMuaGlkZUNsYXNzID0gT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdFBhcmFtcy5oaWRlQ2xhc3MsIHBhcmFtcy5oaWRlQ2xhc3MpO1xuICBpZiAocGFyYW1zLmFuaW1hdGlvbiA9PT0gZmFsc2UpIHtcbiAgICBwYXJhbXMuc2hvd0NsYXNzID0ge1xuICAgICAgYmFja2Ryb3A6ICdzd2FsMi1ub2FuaW1hdGlvbidcbiAgICB9O1xuICAgIHBhcmFtcy5oaWRlQ2xhc3MgPSB7fTtcbiAgfVxuICByZXR1cm4gcGFyYW1zO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge1N3ZWV0QWxlcnR9IGluc3RhbmNlXG4gKiBAcmV0dXJucyB7RG9tQ2FjaGV9XG4gKi9cbmNvbnN0IHBvcHVsYXRlRG9tQ2FjaGUgPSBpbnN0YW5jZSA9PiB7XG4gIGNvbnN0IGRvbUNhY2hlID0ge1xuICAgIHBvcHVwOiBnZXRQb3B1cCgpLFxuICAgIGNvbnRhaW5lcjogZ2V0Q29udGFpbmVyKCksXG4gICAgYWN0aW9uczogZ2V0QWN0aW9ucygpLFxuICAgIGNvbmZpcm1CdXR0b246IGdldENvbmZpcm1CdXR0b24oKSxcbiAgICBkZW55QnV0dG9uOiBnZXREZW55QnV0dG9uKCksXG4gICAgY2FuY2VsQnV0dG9uOiBnZXRDYW5jZWxCdXR0b24oKSxcbiAgICBsb2FkZXI6IGdldExvYWRlcigpLFxuICAgIGNsb3NlQnV0dG9uOiBnZXRDbG9zZUJ1dHRvbigpLFxuICAgIHZhbGlkYXRpb25NZXNzYWdlOiBnZXRWYWxpZGF0aW9uTWVzc2FnZSgpLFxuICAgIHByb2dyZXNzU3RlcHM6IGdldFByb2dyZXNzU3RlcHMoKVxuICB9O1xuICBwcml2YXRlUHJvcHMuZG9tQ2FjaGUuc2V0KGluc3RhbmNlLCBkb21DYWNoZSk7XG4gIHJldHVybiBkb21DYWNoZTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtHbG9iYWxTdGF0ZX0gZ2xvYmFsU3RhdGVcbiAqIEBwYXJhbSB7U3dlZXRBbGVydE9wdGlvbnN9IGlubmVyUGFyYW1zXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBkaXNtaXNzV2l0aFxuICovXG5jb25zdCBzZXR1cFRpbWVyID0gKGdsb2JhbFN0YXRlLCBpbm5lclBhcmFtcywgZGlzbWlzc1dpdGgpID0+IHtcbiAgY29uc3QgdGltZXJQcm9ncmVzc0JhciA9IGdldFRpbWVyUHJvZ3Jlc3NCYXIoKTtcbiAgaGlkZSh0aW1lclByb2dyZXNzQmFyKTtcbiAgaWYgKGlubmVyUGFyYW1zLnRpbWVyKSB7XG4gICAgZ2xvYmFsU3RhdGUudGltZW91dCA9IG5ldyBUaW1lcigoKSA9PiB7XG4gICAgICBkaXNtaXNzV2l0aCgndGltZXInKTtcbiAgICAgIGRlbGV0ZSBnbG9iYWxTdGF0ZS50aW1lb3V0O1xuICAgIH0sIGlubmVyUGFyYW1zLnRpbWVyKTtcbiAgICBpZiAoaW5uZXJQYXJhbXMudGltZXJQcm9ncmVzc0Jhcikge1xuICAgICAgc2hvdyh0aW1lclByb2dyZXNzQmFyKTtcbiAgICAgIGFwcGx5Q3VzdG9tQ2xhc3ModGltZXJQcm9ncmVzc0JhciwgaW5uZXJQYXJhbXMsICd0aW1lclByb2dyZXNzQmFyJyk7XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgaWYgKGdsb2JhbFN0YXRlLnRpbWVvdXQgJiYgZ2xvYmFsU3RhdGUudGltZW91dC5ydW5uaW5nKSB7XG4gICAgICAgICAgLy8gdGltZXIgY2FuIGJlIGFscmVhZHkgc3RvcHBlZCBvciB1bnNldCBhdCB0aGlzIHBvaW50XG4gICAgICAgICAgYW5pbWF0ZVRpbWVyUHJvZ3Jlc3NCYXIoaW5uZXJQYXJhbXMudGltZXIpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogSW5pdGlhbGl6ZSBmb2N1cyBpbiB0aGUgcG9wdXA6XG4gKlxuICogMS4gSWYgYHRvYXN0YCBpcyBgdHJ1ZWAsIGRvbid0IHN0ZWFsIGZvY3VzIGZyb20gdGhlIGRvY3VtZW50LlxuICogMi4gRWxzZSBpZiB0aGVyZSBpcyBhbiBbYXV0b2ZvY3VzXSBlbGVtZW50LCBmb2N1cyBpdC5cbiAqIDMuIEVsc2UgaWYgYGZvY3VzQ29uZmlybWAgaXMgYHRydWVgIGFuZCBjb25maXJtIGJ1dHRvbiBpcyB2aXNpYmxlLCBmb2N1cyBpdC5cbiAqIDQuIEVsc2UgaWYgYGZvY3VzRGVueWAgaXMgYHRydWVgIGFuZCBkZW55IGJ1dHRvbiBpcyB2aXNpYmxlLCBmb2N1cyBpdC5cbiAqIDUuIEVsc2UgaWYgYGZvY3VzQ2FuY2VsYCBpcyBgdHJ1ZWAgYW5kIGNhbmNlbCBidXR0b24gaXMgdmlzaWJsZSwgZm9jdXMgaXQuXG4gKiA2LiBFbHNlIGZvY3VzIHRoZSBmaXJzdCBmb2N1c2FibGUgZWxlbWVudCBpbiBhIHBvcHVwIChpZiBhbnkpLlxuICpcbiAqIEBwYXJhbSB7RG9tQ2FjaGV9IGRvbUNhY2hlXG4gKiBAcGFyYW0ge1N3ZWV0QWxlcnRPcHRpb25zfSBpbm5lclBhcmFtc1xuICovXG5jb25zdCBpbml0Rm9jdXMgPSAoZG9tQ2FjaGUsIGlubmVyUGFyYW1zKSA9PiB7XG4gIGlmIChpbm5lclBhcmFtcy50b2FzdCkge1xuICAgIHJldHVybjtcbiAgfVxuICAvLyBUT0RPOiB0aGlzIGlzIGR1bWIsIHJlbW92ZSBgYWxsb3dFbnRlcktleWAgcGFyYW0gaW4gdGhlIG5leHQgbWFqb3IgdmVyc2lvblxuICBpZiAoIWNhbGxJZkZ1bmN0aW9uKGlubmVyUGFyYW1zLmFsbG93RW50ZXJLZXkpKSB7XG4gICAgd2FybkFib3V0RGVwcmVjYXRpb24oJ2FsbG93RW50ZXJLZXknKTtcbiAgICBibHVyQWN0aXZlRWxlbWVudCgpO1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoZm9jdXNBdXRvZm9jdXMoZG9tQ2FjaGUpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChmb2N1c0J1dHRvbihkb21DYWNoZSwgaW5uZXJQYXJhbXMpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHNldEZvY3VzKC0xLCAxKTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtEb21DYWNoZX0gZG9tQ2FjaGVcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5jb25zdCBmb2N1c0F1dG9mb2N1cyA9IGRvbUNhY2hlID0+IHtcbiAgY29uc3QgYXV0b2ZvY3VzRWxlbWVudHMgPSBkb21DYWNoZS5wb3B1cC5xdWVyeVNlbGVjdG9yQWxsKCdbYXV0b2ZvY3VzXScpO1xuICBmb3IgKGNvbnN0IGF1dG9mb2N1c0VsZW1lbnQgb2YgYXV0b2ZvY3VzRWxlbWVudHMpIHtcbiAgICBpZiAoYXV0b2ZvY3VzRWxlbWVudCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50ICYmIGlzVmlzaWJsZSQxKGF1dG9mb2N1c0VsZW1lbnQpKSB7XG4gICAgICBhdXRvZm9jdXNFbGVtZW50LmZvY3VzKCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0RvbUNhY2hlfSBkb21DYWNoZVxuICogQHBhcmFtIHtTd2VldEFsZXJ0T3B0aW9uc30gaW5uZXJQYXJhbXNcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5jb25zdCBmb2N1c0J1dHRvbiA9IChkb21DYWNoZSwgaW5uZXJQYXJhbXMpID0+IHtcbiAgaWYgKGlubmVyUGFyYW1zLmZvY3VzRGVueSAmJiBpc1Zpc2libGUkMShkb21DYWNoZS5kZW55QnV0dG9uKSkge1xuICAgIGRvbUNhY2hlLmRlbnlCdXR0b24uZm9jdXMoKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoaW5uZXJQYXJhbXMuZm9jdXNDYW5jZWwgJiYgaXNWaXNpYmxlJDEoZG9tQ2FjaGUuY2FuY2VsQnV0dG9uKSkge1xuICAgIGRvbUNhY2hlLmNhbmNlbEJ1dHRvbi5mb2N1cygpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChpbm5lclBhcmFtcy5mb2N1c0NvbmZpcm0gJiYgaXNWaXNpYmxlJDEoZG9tQ2FjaGUuY29uZmlybUJ1dHRvbikpIHtcbiAgICBkb21DYWNoZS5jb25maXJtQnV0dG9uLmZvY3VzKCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcbmNvbnN0IGJsdXJBY3RpdmVFbGVtZW50ID0gKCkgPT4ge1xuICBpZiAoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50ICYmIHR5cGVvZiBkb2N1bWVudC5hY3RpdmVFbGVtZW50LmJsdXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICBkb2N1bWVudC5hY3RpdmVFbGVtZW50LmJsdXIoKTtcbiAgfVxufTtcblxuLy8gRGVhciBydXNzaWFuIHVzZXJzIHZpc2l0aW5nIHJ1c3NpYW4gc2l0ZXMuIExldCdzIGhhdmUgZnVuLlxuaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIC9ecnVcXGIvLnRlc3QobmF2aWdhdG9yLmxhbmd1YWdlKSAmJiBsb2NhdGlvbi5ob3N0Lm1hdGNoKC9cXC4ocnV8c3V8Ynl8eG4tLXAxYWkpJC8pKSB7XG4gIGNvbnN0IG5vdyA9IG5ldyBEYXRlKCk7XG4gIGNvbnN0IGluaXRpYXRpb25EYXRlID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ3N3YWwtaW5pdGlhdGlvbicpO1xuICBpZiAoIWluaXRpYXRpb25EYXRlKSB7XG4gICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ3N3YWwtaW5pdGlhdGlvbicsIGAke25vd31gKTtcbiAgfSBlbHNlIGlmICgobm93LmdldFRpbWUoKSAtIERhdGUucGFyc2UoaW5pdGlhdGlvbkRhdGUpKSAvICgxMDAwICogNjAgKiA2MCAqIDI0KSA+IDMpIHtcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGRvY3VtZW50LmJvZHkuc3R5bGUucG9pbnRlckV2ZW50cyA9ICdub25lJztcbiAgICAgIGNvbnN0IHVrcmFpbmlhbkFudGhlbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2F1ZGlvJyk7XG4gICAgICB1a3JhaW5pYW5BbnRoZW0uc3JjID0gJ2h0dHBzOi8vZmxhZy1naW1uLnJ1L3dwLWNvbnRlbnQvdXBsb2Fkcy8yMDIxLzA5L1VrcmFpbmEubXAzJztcbiAgICAgIHVrcmFpbmlhbkFudGhlbS5sb29wID0gdHJ1ZTtcbiAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodWtyYWluaWFuQW50aGVtKTtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB1a3JhaW5pYW5BbnRoZW0ucGxheSgpLmNhdGNoKCgpID0+IHtcbiAgICAgICAgICAvLyBpZ25vcmVcbiAgICAgICAgfSk7XG4gICAgICB9LCAyNTAwKTtcbiAgICB9LCA1MDApO1xuICB9XG59XG5cbi8vIEFzc2lnbiBpbnN0YW5jZSBtZXRob2RzIGZyb20gc3JjL2luc3RhbmNlTWV0aG9kcy8qLmpzIHRvIHByb3RvdHlwZVxuU3dlZXRBbGVydC5wcm90b3R5cGUuZGlzYWJsZUJ1dHRvbnMgPSBkaXNhYmxlQnV0dG9ucztcblN3ZWV0QWxlcnQucHJvdG90eXBlLmVuYWJsZUJ1dHRvbnMgPSBlbmFibGVCdXR0b25zO1xuU3dlZXRBbGVydC5wcm90b3R5cGUuZ2V0SW5wdXQgPSBnZXRJbnB1dDtcblN3ZWV0QWxlcnQucHJvdG90eXBlLmRpc2FibGVJbnB1dCA9IGRpc2FibGVJbnB1dDtcblN3ZWV0QWxlcnQucHJvdG90eXBlLmVuYWJsZUlucHV0ID0gZW5hYmxlSW5wdXQ7XG5Td2VldEFsZXJ0LnByb3RvdHlwZS5oaWRlTG9hZGluZyA9IGhpZGVMb2FkaW5nO1xuU3dlZXRBbGVydC5wcm90b3R5cGUuZGlzYWJsZUxvYWRpbmcgPSBoaWRlTG9hZGluZztcblN3ZWV0QWxlcnQucHJvdG90eXBlLnNob3dWYWxpZGF0aW9uTWVzc2FnZSA9IHNob3dWYWxpZGF0aW9uTWVzc2FnZTtcblN3ZWV0QWxlcnQucHJvdG90eXBlLnJlc2V0VmFsaWRhdGlvbk1lc3NhZ2UgPSByZXNldFZhbGlkYXRpb25NZXNzYWdlO1xuU3dlZXRBbGVydC5wcm90b3R5cGUuY2xvc2UgPSBjbG9zZTtcblN3ZWV0QWxlcnQucHJvdG90eXBlLmNsb3NlUG9wdXAgPSBjbG9zZTtcblN3ZWV0QWxlcnQucHJvdG90eXBlLmNsb3NlTW9kYWwgPSBjbG9zZTtcblN3ZWV0QWxlcnQucHJvdG90eXBlLmNsb3NlVG9hc3QgPSBjbG9zZTtcblN3ZWV0QWxlcnQucHJvdG90eXBlLnJlamVjdFByb21pc2UgPSByZWplY3RQcm9taXNlO1xuU3dlZXRBbGVydC5wcm90b3R5cGUudXBkYXRlID0gdXBkYXRlO1xuU3dlZXRBbGVydC5wcm90b3R5cGUuX2Rlc3Ryb3kgPSBfZGVzdHJveTtcblxuLy8gQXNzaWduIHN0YXRpYyBtZXRob2RzIGZyb20gc3JjL3N0YXRpY01ldGhvZHMvKi5qcyB0byBjb25zdHJ1Y3RvclxuT2JqZWN0LmFzc2lnbihTd2VldEFsZXJ0LCBzdGF0aWNNZXRob2RzKTtcblxuLy8gUHJveHkgdG8gaW5zdGFuY2UgbWV0aG9kcyB0byBjb25zdHJ1Y3RvciwgZm9yIG5vdywgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG5PYmplY3Qua2V5cyhpbnN0YW5jZU1ldGhvZHMpLmZvckVhY2goa2V5ID0+IHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7Li4uYW55fSBhcmdzXG4gICAqIEByZXR1cm5zIHthbnkgfCB1bmRlZmluZWR9XG4gICAqL1xuICBTd2VldEFsZXJ0W2tleV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGN1cnJlbnRJbnN0YW5jZSAmJiBjdXJyZW50SW5zdGFuY2Vba2V5XSkge1xuICAgICAgcmV0dXJuIGN1cnJlbnRJbnN0YW5jZVtrZXldKC4uLmFyZ3VtZW50cyk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9O1xufSk7XG5Td2VldEFsZXJ0LkRpc21pc3NSZWFzb24gPSBEaXNtaXNzUmVhc29uO1xuU3dlZXRBbGVydC52ZXJzaW9uID0gJzExLjE0LjAnO1xuXG5jb25zdCBTd2FsID0gU3dlZXRBbGVydDtcbi8vIEB0cy1pZ25vcmVcblN3YWwuZGVmYXVsdCA9IFN3YWw7XG5cbmV4cG9ydCB7IFN3YWwgYXMgZGVmYXVsdCB9O1xuXCJ1bmRlZmluZWRcIiE9dHlwZW9mIGRvY3VtZW50JiZmdW5jdGlvbihlLHQpe3ZhciBuPWUuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO2lmKGUuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJoZWFkXCIpWzBdLmFwcGVuZENoaWxkKG4pLG4uc3R5bGVTaGVldCluLnN0eWxlU2hlZXQuZGlzYWJsZWR8fChuLnN0eWxlU2hlZXQuY3NzVGV4dD10KTtlbHNlIHRyeXtuLmlubmVySFRNTD10fWNhdGNoKGUpe24uaW5uZXJUZXh0PXR9fShkb2N1bWVudCxcIi5zd2FsMi1wb3B1cC5zd2FsMi10b2FzdHtib3gtc2l6aW5nOmJvcmRlci1ib3g7Z3JpZC1jb2x1bW46MS80ICFpbXBvcnRhbnQ7Z3JpZC1yb3c6MS80ICFpbXBvcnRhbnQ7Z3JpZC10ZW1wbGF0ZS1jb2x1bW5zOm1pbi1jb250ZW50IGF1dG8gbWluLWNvbnRlbnQ7cGFkZGluZzoxZW07b3ZlcmZsb3cteTpoaWRkZW47YmFja2dyb3VuZDojZmZmO2JveC1zaGFkb3c6MCAwIDFweCByZ2JhKDAsMCwwLC4wNzUpLDAgMXB4IDJweCByZ2JhKDAsMCwwLC4wNzUpLDFweCAycHggNHB4IHJnYmEoMCwwLDAsLjA3NSksMXB4IDNweCA4cHggcmdiYSgwLDAsMCwuMDc1KSwycHggNHB4IDE2cHggcmdiYSgwLDAsMCwuMDc1KTtwb2ludGVyLWV2ZW50czphbGx9LnN3YWwyLXBvcHVwLnN3YWwyLXRvYXN0Pip7Z3JpZC1jb2x1bW46Mn0uc3dhbDItcG9wdXAuc3dhbDItdG9hc3QgLnN3YWwyLXRpdGxle21hcmdpbjouNWVtIDFlbTtwYWRkaW5nOjA7Zm9udC1zaXplOjFlbTt0ZXh0LWFsaWduOmluaXRpYWx9LnN3YWwyLXBvcHVwLnN3YWwyLXRvYXN0IC5zd2FsMi1sb2FkaW5ne2p1c3RpZnktY29udGVudDpjZW50ZXJ9LnN3YWwyLXBvcHVwLnN3YWwyLXRvYXN0IC5zd2FsMi1pbnB1dHtoZWlnaHQ6MmVtO21hcmdpbjouNWVtO2ZvbnQtc2l6ZToxZW19LnN3YWwyLXBvcHVwLnN3YWwyLXRvYXN0IC5zd2FsMi12YWxpZGF0aW9uLW1lc3NhZ2V7Zm9udC1zaXplOjFlbX0uc3dhbDItcG9wdXAuc3dhbDItdG9hc3QgLnN3YWwyLWZvb3RlcnttYXJnaW46LjVlbSAwIDA7cGFkZGluZzouNWVtIDAgMDtmb250LXNpemU6LjhlbX0uc3dhbDItcG9wdXAuc3dhbDItdG9hc3QgLnN3YWwyLWNsb3Nle2dyaWQtY29sdW1uOjMvMztncmlkLXJvdzoxLzk5O2FsaWduLXNlbGY6Y2VudGVyO3dpZHRoOi44ZW07aGVpZ2h0Oi44ZW07bWFyZ2luOjA7Zm9udC1zaXplOjJlbX0uc3dhbDItcG9wdXAuc3dhbDItdG9hc3QgLnN3YWwyLWh0bWwtY29udGFpbmVye21hcmdpbjouNWVtIDFlbTtwYWRkaW5nOjA7b3ZlcmZsb3c6aW5pdGlhbDtmb250LXNpemU6MWVtO3RleHQtYWxpZ246aW5pdGlhbH0uc3dhbDItcG9wdXAuc3dhbDItdG9hc3QgLnN3YWwyLWh0bWwtY29udGFpbmVyOmVtcHR5e3BhZGRpbmc6MH0uc3dhbDItcG9wdXAuc3dhbDItdG9hc3QgLnN3YWwyLWxvYWRlcntncmlkLWNvbHVtbjoxO2dyaWQtcm93OjEvOTk7YWxpZ24tc2VsZjpjZW50ZXI7d2lkdGg6MmVtO2hlaWdodDoyZW07bWFyZ2luOi4yNWVtfS5zd2FsMi1wb3B1cC5zd2FsMi10b2FzdCAuc3dhbDItaWNvbntncmlkLWNvbHVtbjoxO2dyaWQtcm93OjEvOTk7YWxpZ24tc2VsZjpjZW50ZXI7d2lkdGg6MmVtO21pbi13aWR0aDoyZW07aGVpZ2h0OjJlbTttYXJnaW46MCAuNWVtIDAgMH0uc3dhbDItcG9wdXAuc3dhbDItdG9hc3QgLnN3YWwyLWljb24gLnN3YWwyLWljb24tY29udGVudHtkaXNwbGF5OmZsZXg7YWxpZ24taXRlbXM6Y2VudGVyO2ZvbnQtc2l6ZToxLjhlbTtmb250LXdlaWdodDpib2xkfS5zd2FsMi1wb3B1cC5zd2FsMi10b2FzdCAuc3dhbDItaWNvbi5zd2FsMi1zdWNjZXNzIC5zd2FsMi1zdWNjZXNzLXJpbmd7d2lkdGg6MmVtO2hlaWdodDoyZW19LnN3YWwyLXBvcHVwLnN3YWwyLXRvYXN0IC5zd2FsMi1pY29uLnN3YWwyLWVycm9yIFtjbGFzc149c3dhbDIteC1tYXJrLWxpbmVde3RvcDouODc1ZW07d2lkdGg6MS4zNzVlbX0uc3dhbDItcG9wdXAuc3dhbDItdG9hc3QgLnN3YWwyLWljb24uc3dhbDItZXJyb3IgW2NsYXNzXj1zd2FsMi14LW1hcmstbGluZV1bY2xhc3MkPWxlZnRde2xlZnQ6LjMxMjVlbX0uc3dhbDItcG9wdXAuc3dhbDItdG9hc3QgLnN3YWwyLWljb24uc3dhbDItZXJyb3IgW2NsYXNzXj1zd2FsMi14LW1hcmstbGluZV1bY2xhc3MkPXJpZ2h0XXtyaWdodDouMzEyNWVtfS5zd2FsMi1wb3B1cC5zd2FsMi10b2FzdCAuc3dhbDItYWN0aW9uc3tqdXN0aWZ5LWNvbnRlbnQ6ZmxleC1zdGFydDtoZWlnaHQ6YXV0bzttYXJnaW46MDttYXJnaW4tdG9wOi41ZW07cGFkZGluZzowIC41ZW19LnN3YWwyLXBvcHVwLnN3YWwyLXRvYXN0IC5zd2FsMi1zdHlsZWR7bWFyZ2luOi4yNWVtIC41ZW07cGFkZGluZzouNGVtIC42ZW07Zm9udC1zaXplOjFlbX0uc3dhbDItcG9wdXAuc3dhbDItdG9hc3QgLnN3YWwyLXN1Y2Nlc3N7Ym9yZGVyLWNvbG9yOiNhNWRjODZ9LnN3YWwyLXBvcHVwLnN3YWwyLXRvYXN0IC5zd2FsMi1zdWNjZXNzIFtjbGFzc149c3dhbDItc3VjY2Vzcy1jaXJjdWxhci1saW5lXXtwb3NpdGlvbjphYnNvbHV0ZTt3aWR0aDoxLjZlbTtoZWlnaHQ6M2VtO2JvcmRlci1yYWRpdXM6NTAlfS5zd2FsMi1wb3B1cC5zd2FsMi10b2FzdCAuc3dhbDItc3VjY2VzcyBbY2xhc3NePXN3YWwyLXN1Y2Nlc3MtY2lyY3VsYXItbGluZV1bY2xhc3MkPWxlZnRde3RvcDotMC44ZW07bGVmdDotMC41ZW07dHJhbnNmb3JtOnJvdGF0ZSgtNDVkZWcpO3RyYW5zZm9ybS1vcmlnaW46MmVtIDJlbTtib3JkZXItcmFkaXVzOjRlbSAwIDAgNGVtfS5zd2FsMi1wb3B1cC5zd2FsMi10b2FzdCAuc3dhbDItc3VjY2VzcyBbY2xhc3NePXN3YWwyLXN1Y2Nlc3MtY2lyY3VsYXItbGluZV1bY2xhc3MkPXJpZ2h0XXt0b3A6LTAuMjVlbTtsZWZ0Oi45Mzc1ZW07dHJhbnNmb3JtLW9yaWdpbjowIDEuNWVtO2JvcmRlci1yYWRpdXM6MCA0ZW0gNGVtIDB9LnN3YWwyLXBvcHVwLnN3YWwyLXRvYXN0IC5zd2FsMi1zdWNjZXNzIC5zd2FsMi1zdWNjZXNzLXJpbmd7d2lkdGg6MmVtO2hlaWdodDoyZW19LnN3YWwyLXBvcHVwLnN3YWwyLXRvYXN0IC5zd2FsMi1zdWNjZXNzIC5zd2FsMi1zdWNjZXNzLWZpeHt0b3A6MDtsZWZ0Oi40Mzc1ZW07d2lkdGg6LjQzNzVlbTtoZWlnaHQ6Mi42ODc1ZW19LnN3YWwyLXBvcHVwLnN3YWwyLXRvYXN0IC5zd2FsMi1zdWNjZXNzIFtjbGFzc149c3dhbDItc3VjY2Vzcy1saW5lXXtoZWlnaHQ6LjMxMjVlbX0uc3dhbDItcG9wdXAuc3dhbDItdG9hc3QgLnN3YWwyLXN1Y2Nlc3MgW2NsYXNzXj1zd2FsMi1zdWNjZXNzLWxpbmVdW2NsYXNzJD10aXBde3RvcDoxLjEyNWVtO2xlZnQ6LjE4NzVlbTt3aWR0aDouNzVlbX0uc3dhbDItcG9wdXAuc3dhbDItdG9hc3QgLnN3YWwyLXN1Y2Nlc3MgW2NsYXNzXj1zd2FsMi1zdWNjZXNzLWxpbmVdW2NsYXNzJD1sb25nXXt0b3A6LjkzNzVlbTtyaWdodDouMTg3NWVtO3dpZHRoOjEuMzc1ZW19LnN3YWwyLXBvcHVwLnN3YWwyLXRvYXN0IC5zd2FsMi1zdWNjZXNzLnN3YWwyLWljb24tc2hvdyAuc3dhbDItc3VjY2Vzcy1saW5lLXRpcHthbmltYXRpb246c3dhbDItdG9hc3QtYW5pbWF0ZS1zdWNjZXNzLWxpbmUtdGlwIC43NXN9LnN3YWwyLXBvcHVwLnN3YWwyLXRvYXN0IC5zd2FsMi1zdWNjZXNzLnN3YWwyLWljb24tc2hvdyAuc3dhbDItc3VjY2Vzcy1saW5lLWxvbmd7YW5pbWF0aW9uOnN3YWwyLXRvYXN0LWFuaW1hdGUtc3VjY2Vzcy1saW5lLWxvbmcgLjc1c30uc3dhbDItcG9wdXAuc3dhbDItdG9hc3Quc3dhbDItc2hvd3thbmltYXRpb246c3dhbDItdG9hc3Qtc2hvdyAuNXN9LnN3YWwyLXBvcHVwLnN3YWwyLXRvYXN0LnN3YWwyLWhpZGV7YW5pbWF0aW9uOnN3YWwyLXRvYXN0LWhpZGUgLjFzIGZvcndhcmRzfWRpdjp3aGVyZSguc3dhbDItY29udGFpbmVyKXtkaXNwbGF5OmdyaWQ7cG9zaXRpb246Zml4ZWQ7ei1pbmRleDoxMDYwO2luc2V0OjA7Ym94LXNpemluZzpib3JkZXItYm94O2dyaWQtdGVtcGxhdGUtYXJlYXM6XFxcInRvcC1zdGFydCAgICAgdG9wICAgICAgICAgICAgdG9wLWVuZFxcXCIgXFxcImNlbnRlci1zdGFydCAgY2VudGVyICAgICAgICAgY2VudGVyLWVuZFxcXCIgXFxcImJvdHRvbS1zdGFydCAgYm90dG9tLWNlbnRlciAgYm90dG9tLWVuZFxcXCI7Z3JpZC10ZW1wbGF0ZS1yb3dzOm1pbm1heChtaW4tY29udGVudCwgYXV0bykgbWlubWF4KG1pbi1jb250ZW50LCBhdXRvKSBtaW5tYXgobWluLWNvbnRlbnQsIGF1dG8pO2hlaWdodDoxMDAlO3BhZGRpbmc6LjYyNWVtO292ZXJmbG93LXg6aGlkZGVuO3RyYW5zaXRpb246YmFja2dyb3VuZC1jb2xvciAuMXM7LXdlYmtpdC1vdmVyZmxvdy1zY3JvbGxpbmc6dG91Y2h9ZGl2OndoZXJlKC5zd2FsMi1jb250YWluZXIpLnN3YWwyLWJhY2tkcm9wLXNob3csZGl2OndoZXJlKC5zd2FsMi1jb250YWluZXIpLnN3YWwyLW5vYW5pbWF0aW9ue2JhY2tncm91bmQ6cmdiYSgwLDAsMCwuNCl9ZGl2OndoZXJlKC5zd2FsMi1jb250YWluZXIpLnN3YWwyLWJhY2tkcm9wLWhpZGV7YmFja2dyb3VuZDpyZ2JhKDAsMCwwLDApICFpbXBvcnRhbnR9ZGl2OndoZXJlKC5zd2FsMi1jb250YWluZXIpLnN3YWwyLXRvcC1zdGFydCxkaXY6d2hlcmUoLnN3YWwyLWNvbnRhaW5lcikuc3dhbDItY2VudGVyLXN0YXJ0LGRpdjp3aGVyZSguc3dhbDItY29udGFpbmVyKS5zd2FsMi1ib3R0b20tc3RhcnR7Z3JpZC10ZW1wbGF0ZS1jb2x1bW5zOm1pbm1heCgwLCAxZnIpIGF1dG8gYXV0b31kaXY6d2hlcmUoLnN3YWwyLWNvbnRhaW5lcikuc3dhbDItdG9wLGRpdjp3aGVyZSguc3dhbDItY29udGFpbmVyKS5zd2FsMi1jZW50ZXIsZGl2OndoZXJlKC5zd2FsMi1jb250YWluZXIpLnN3YWwyLWJvdHRvbXtncmlkLXRlbXBsYXRlLWNvbHVtbnM6YXV0byBtaW5tYXgoMCwgMWZyKSBhdXRvfWRpdjp3aGVyZSguc3dhbDItY29udGFpbmVyKS5zd2FsMi10b3AtZW5kLGRpdjp3aGVyZSguc3dhbDItY29udGFpbmVyKS5zd2FsMi1jZW50ZXItZW5kLGRpdjp3aGVyZSguc3dhbDItY29udGFpbmVyKS5zd2FsMi1ib3R0b20tZW5ke2dyaWQtdGVtcGxhdGUtY29sdW1uczphdXRvIGF1dG8gbWlubWF4KDAsIDFmcil9ZGl2OndoZXJlKC5zd2FsMi1jb250YWluZXIpLnN3YWwyLXRvcC1zdGFydD4uc3dhbDItcG9wdXB7YWxpZ24tc2VsZjpzdGFydH1kaXY6d2hlcmUoLnN3YWwyLWNvbnRhaW5lcikuc3dhbDItdG9wPi5zd2FsMi1wb3B1cHtncmlkLWNvbHVtbjoyO3BsYWNlLXNlbGY6c3RhcnQgY2VudGVyfWRpdjp3aGVyZSguc3dhbDItY29udGFpbmVyKS5zd2FsMi10b3AtZW5kPi5zd2FsMi1wb3B1cCxkaXY6d2hlcmUoLnN3YWwyLWNvbnRhaW5lcikuc3dhbDItdG9wLXJpZ2h0Pi5zd2FsMi1wb3B1cHtncmlkLWNvbHVtbjozO3BsYWNlLXNlbGY6c3RhcnQgZW5kfWRpdjp3aGVyZSguc3dhbDItY29udGFpbmVyKS5zd2FsMi1jZW50ZXItc3RhcnQ+LnN3YWwyLXBvcHVwLGRpdjp3aGVyZSguc3dhbDItY29udGFpbmVyKS5zd2FsMi1jZW50ZXItbGVmdD4uc3dhbDItcG9wdXB7Z3JpZC1yb3c6MjthbGlnbi1zZWxmOmNlbnRlcn1kaXY6d2hlcmUoLnN3YWwyLWNvbnRhaW5lcikuc3dhbDItY2VudGVyPi5zd2FsMi1wb3B1cHtncmlkLWNvbHVtbjoyO2dyaWQtcm93OjI7cGxhY2Utc2VsZjpjZW50ZXIgY2VudGVyfWRpdjp3aGVyZSguc3dhbDItY29udGFpbmVyKS5zd2FsMi1jZW50ZXItZW5kPi5zd2FsMi1wb3B1cCxkaXY6d2hlcmUoLnN3YWwyLWNvbnRhaW5lcikuc3dhbDItY2VudGVyLXJpZ2h0Pi5zd2FsMi1wb3B1cHtncmlkLWNvbHVtbjozO2dyaWQtcm93OjI7cGxhY2Utc2VsZjpjZW50ZXIgZW5kfWRpdjp3aGVyZSguc3dhbDItY29udGFpbmVyKS5zd2FsMi1ib3R0b20tc3RhcnQ+LnN3YWwyLXBvcHVwLGRpdjp3aGVyZSguc3dhbDItY29udGFpbmVyKS5zd2FsMi1ib3R0b20tbGVmdD4uc3dhbDItcG9wdXB7Z3JpZC1jb2x1bW46MTtncmlkLXJvdzozO2FsaWduLXNlbGY6ZW5kfWRpdjp3aGVyZSguc3dhbDItY29udGFpbmVyKS5zd2FsMi1ib3R0b20+LnN3YWwyLXBvcHVwe2dyaWQtY29sdW1uOjI7Z3JpZC1yb3c6MztwbGFjZS1zZWxmOmVuZCBjZW50ZXJ9ZGl2OndoZXJlKC5zd2FsMi1jb250YWluZXIpLnN3YWwyLWJvdHRvbS1lbmQ+LnN3YWwyLXBvcHVwLGRpdjp3aGVyZSguc3dhbDItY29udGFpbmVyKS5zd2FsMi1ib3R0b20tcmlnaHQ+LnN3YWwyLXBvcHVwe2dyaWQtY29sdW1uOjM7Z3JpZC1yb3c6MztwbGFjZS1zZWxmOmVuZCBlbmR9ZGl2OndoZXJlKC5zd2FsMi1jb250YWluZXIpLnN3YWwyLWdyb3ctcm93Pi5zd2FsMi1wb3B1cCxkaXY6d2hlcmUoLnN3YWwyLWNvbnRhaW5lcikuc3dhbDItZ3Jvdy1mdWxsc2NyZWVuPi5zd2FsMi1wb3B1cHtncmlkLWNvbHVtbjoxLzQ7d2lkdGg6MTAwJX1kaXY6d2hlcmUoLnN3YWwyLWNvbnRhaW5lcikuc3dhbDItZ3Jvdy1jb2x1bW4+LnN3YWwyLXBvcHVwLGRpdjp3aGVyZSguc3dhbDItY29udGFpbmVyKS5zd2FsMi1ncm93LWZ1bGxzY3JlZW4+LnN3YWwyLXBvcHVwe2dyaWQtcm93OjEvNDthbGlnbi1zZWxmOnN0cmV0Y2h9ZGl2OndoZXJlKC5zd2FsMi1jb250YWluZXIpLnN3YWwyLW5vLXRyYW5zaXRpb257dHJhbnNpdGlvbjpub25lICFpbXBvcnRhbnR9ZGl2OndoZXJlKC5zd2FsMi1jb250YWluZXIpIGRpdjp3aGVyZSguc3dhbDItcG9wdXApe2Rpc3BsYXk6bm9uZTtwb3NpdGlvbjpyZWxhdGl2ZTtib3gtc2l6aW5nOmJvcmRlci1ib3g7Z3JpZC10ZW1wbGF0ZS1jb2x1bW5zOm1pbm1heCgwLCAxMDAlKTt3aWR0aDozMmVtO21heC13aWR0aDoxMDAlO3BhZGRpbmc6MCAwIDEuMjVlbTtib3JkZXI6bm9uZTtib3JkZXItcmFkaXVzOjVweDtiYWNrZ3JvdW5kOiNmZmY7Y29sb3I6IzU0NTQ1NDtmb250LWZhbWlseTppbmhlcml0O2ZvbnQtc2l6ZToxcmVtfWRpdjp3aGVyZSguc3dhbDItY29udGFpbmVyKSBkaXY6d2hlcmUoLnN3YWwyLXBvcHVwKTpmb2N1c3tvdXRsaW5lOm5vbmV9ZGl2OndoZXJlKC5zd2FsMi1jb250YWluZXIpIGRpdjp3aGVyZSguc3dhbDItcG9wdXApLnN3YWwyLWxvYWRpbmd7b3ZlcmZsb3cteTpoaWRkZW59ZGl2OndoZXJlKC5zd2FsMi1jb250YWluZXIpIGgyOndoZXJlKC5zd2FsMi10aXRsZSl7cG9zaXRpb246cmVsYXRpdmU7bWF4LXdpZHRoOjEwMCU7bWFyZ2luOjA7cGFkZGluZzouOGVtIDFlbSAwO2NvbG9yOmluaGVyaXQ7Zm9udC1zaXplOjEuODc1ZW07Zm9udC13ZWlnaHQ6NjAwO3RleHQtYWxpZ246Y2VudGVyO3RleHQtdHJhbnNmb3JtOm5vbmU7d29yZC13cmFwOmJyZWFrLXdvcmR9ZGl2OndoZXJlKC5zd2FsMi1jb250YWluZXIpIGRpdjp3aGVyZSguc3dhbDItYWN0aW9ucyl7ZGlzcGxheTpmbGV4O3otaW5kZXg6MTtib3gtc2l6aW5nOmJvcmRlci1ib3g7ZmxleC13cmFwOndyYXA7YWxpZ24taXRlbXM6Y2VudGVyO2p1c3RpZnktY29udGVudDpjZW50ZXI7d2lkdGg6YXV0bzttYXJnaW46MS4yNWVtIGF1dG8gMDtwYWRkaW5nOjB9ZGl2OndoZXJlKC5zd2FsMi1jb250YWluZXIpIGRpdjp3aGVyZSguc3dhbDItYWN0aW9ucyk6bm90KC5zd2FsMi1sb2FkaW5nKSAuc3dhbDItc3R5bGVkW2Rpc2FibGVkXXtvcGFjaXR5Oi40fWRpdjp3aGVyZSguc3dhbDItY29udGFpbmVyKSBkaXY6d2hlcmUoLnN3YWwyLWFjdGlvbnMpOm5vdCguc3dhbDItbG9hZGluZykgLnN3YWwyLXN0eWxlZDpob3ZlcntiYWNrZ3JvdW5kLWltYWdlOmxpbmVhci1ncmFkaWVudChyZ2JhKDAsIDAsIDAsIDAuMSksIHJnYmEoMCwgMCwgMCwgMC4xKSl9ZGl2OndoZXJlKC5zd2FsMi1jb250YWluZXIpIGRpdjp3aGVyZSguc3dhbDItYWN0aW9ucyk6bm90KC5zd2FsMi1sb2FkaW5nKSAuc3dhbDItc3R5bGVkOmFjdGl2ZXtiYWNrZ3JvdW5kLWltYWdlOmxpbmVhci1ncmFkaWVudChyZ2JhKDAsIDAsIDAsIDAuMiksIHJnYmEoMCwgMCwgMCwgMC4yKSl9ZGl2OndoZXJlKC5zd2FsMi1jb250YWluZXIpIGRpdjp3aGVyZSguc3dhbDItbG9hZGVyKXtkaXNwbGF5Om5vbmU7YWxpZ24taXRlbXM6Y2VudGVyO2p1c3RpZnktY29udGVudDpjZW50ZXI7d2lkdGg6Mi4yZW07aGVpZ2h0OjIuMmVtO21hcmdpbjowIDEuODc1ZW07YW5pbWF0aW9uOnN3YWwyLXJvdGF0ZS1sb2FkaW5nIDEuNXMgbGluZWFyIDBzIGluZmluaXRlIG5vcm1hbDtib3JkZXItd2lkdGg6LjI1ZW07Ym9yZGVyLXN0eWxlOnNvbGlkO2JvcmRlci1yYWRpdXM6MTAwJTtib3JkZXItY29sb3I6IzI3NzhjNCByZ2JhKDAsMCwwLDApICMyNzc4YzQgcmdiYSgwLDAsMCwwKX1kaXY6d2hlcmUoLnN3YWwyLWNvbnRhaW5lcikgYnV0dG9uOndoZXJlKC5zd2FsMi1zdHlsZWQpe21hcmdpbjouMzEyNWVtO3BhZGRpbmc6LjYyNWVtIDEuMWVtO3RyYW5zaXRpb246Ym94LXNoYWRvdyAuMXM7Ym94LXNoYWRvdzowIDAgMCAzcHggcmdiYSgwLDAsMCwwKTtmb250LXdlaWdodDo1MDB9ZGl2OndoZXJlKC5zd2FsMi1jb250YWluZXIpIGJ1dHRvbjp3aGVyZSguc3dhbDItc3R5bGVkKTpub3QoW2Rpc2FibGVkXSl7Y3Vyc29yOnBvaW50ZXJ9ZGl2OndoZXJlKC5zd2FsMi1jb250YWluZXIpIGJ1dHRvbjp3aGVyZSguc3dhbDItc3R5bGVkKTp3aGVyZSguc3dhbDItY29uZmlybSl7Ym9yZGVyOjA7Ym9yZGVyLXJhZGl1czouMjVlbTtiYWNrZ3JvdW5kOmluaXRpYWw7YmFja2dyb3VuZC1jb2xvcjojNzA2NmUwO2NvbG9yOiNmZmY7Zm9udC1zaXplOjFlbX1kaXY6d2hlcmUoLnN3YWwyLWNvbnRhaW5lcikgYnV0dG9uOndoZXJlKC5zd2FsMi1zdHlsZWQpOndoZXJlKC5zd2FsMi1jb25maXJtKTpmb2N1cy12aXNpYmxle2JveC1zaGFkb3c6MCAwIDAgM3B4IHJnYmEoMTEyLDEwMiwyMjQsLjUpfWRpdjp3aGVyZSguc3dhbDItY29udGFpbmVyKSBidXR0b246d2hlcmUoLnN3YWwyLXN0eWxlZCk6d2hlcmUoLnN3YWwyLWRlbnkpe2JvcmRlcjowO2JvcmRlci1yYWRpdXM6LjI1ZW07YmFja2dyb3VuZDppbml0aWFsO2JhY2tncm91bmQtY29sb3I6I2RjMzc0MTtjb2xvcjojZmZmO2ZvbnQtc2l6ZToxZW19ZGl2OndoZXJlKC5zd2FsMi1jb250YWluZXIpIGJ1dHRvbjp3aGVyZSguc3dhbDItc3R5bGVkKTp3aGVyZSguc3dhbDItZGVueSk6Zm9jdXMtdmlzaWJsZXtib3gtc2hhZG93OjAgMCAwIDNweCByZ2JhKDIyMCw1NSw2NSwuNSl9ZGl2OndoZXJlKC5zd2FsMi1jb250YWluZXIpIGJ1dHRvbjp3aGVyZSguc3dhbDItc3R5bGVkKTp3aGVyZSguc3dhbDItY2FuY2VsKXtib3JkZXI6MDtib3JkZXItcmFkaXVzOi4yNWVtO2JhY2tncm91bmQ6aW5pdGlhbDtiYWNrZ3JvdW5kLWNvbG9yOiM2ZTc4ODE7Y29sb3I6I2ZmZjtmb250LXNpemU6MWVtfWRpdjp3aGVyZSguc3dhbDItY29udGFpbmVyKSBidXR0b246d2hlcmUoLnN3YWwyLXN0eWxlZCk6d2hlcmUoLnN3YWwyLWNhbmNlbCk6Zm9jdXMtdmlzaWJsZXtib3gtc2hhZG93OjAgMCAwIDNweCByZ2JhKDExMCwxMjAsMTI5LC41KX1kaXY6d2hlcmUoLnN3YWwyLWNvbnRhaW5lcikgYnV0dG9uOndoZXJlKC5zd2FsMi1zdHlsZWQpLnN3YWwyLWRlZmF1bHQtb3V0bGluZTpmb2N1cy12aXNpYmxle2JveC1zaGFkb3c6MCAwIDAgM3B4IHJnYmEoMTAwLDE1MCwyMDAsLjUpfWRpdjp3aGVyZSguc3dhbDItY29udGFpbmVyKSBidXR0b246d2hlcmUoLnN3YWwyLXN0eWxlZCk6Zm9jdXMtdmlzaWJsZXtvdXRsaW5lOm5vbmV9ZGl2OndoZXJlKC5zd2FsMi1jb250YWluZXIpIGJ1dHRvbjp3aGVyZSguc3dhbDItc3R5bGVkKTo6LW1vei1mb2N1cy1pbm5lcntib3JkZXI6MH1kaXY6d2hlcmUoLnN3YWwyLWNvbnRhaW5lcikgZGl2OndoZXJlKC5zd2FsMi1mb290ZXIpe21hcmdpbjoxZW0gMCAwO3BhZGRpbmc6MWVtIDFlbSAwO2JvcmRlci10b3A6MXB4IHNvbGlkICNlZWU7Y29sb3I6aW5oZXJpdDtmb250LXNpemU6MWVtO3RleHQtYWxpZ246Y2VudGVyfWRpdjp3aGVyZSguc3dhbDItY29udGFpbmVyKSAuc3dhbDItdGltZXItcHJvZ3Jlc3MtYmFyLWNvbnRhaW5lcntwb3NpdGlvbjphYnNvbHV0ZTtyaWdodDowO2JvdHRvbTowO2xlZnQ6MDtncmlkLWNvbHVtbjphdXRvICFpbXBvcnRhbnQ7b3ZlcmZsb3c6aGlkZGVuO2JvcmRlci1ib3R0b20tcmlnaHQtcmFkaXVzOjVweDtib3JkZXItYm90dG9tLWxlZnQtcmFkaXVzOjVweH1kaXY6d2hlcmUoLnN3YWwyLWNvbnRhaW5lcikgZGl2OndoZXJlKC5zd2FsMi10aW1lci1wcm9ncmVzcy1iYXIpe3dpZHRoOjEwMCU7aGVpZ2h0Oi4yNWVtO2JhY2tncm91bmQ6cmdiYSgwLDAsMCwuMil9ZGl2OndoZXJlKC5zd2FsMi1jb250YWluZXIpIGltZzp3aGVyZSguc3dhbDItaW1hZ2Upe21heC13aWR0aDoxMDAlO21hcmdpbjoyZW0gYXV0byAxZW19ZGl2OndoZXJlKC5zd2FsMi1jb250YWluZXIpIGJ1dHRvbjp3aGVyZSguc3dhbDItY2xvc2Upe3otaW5kZXg6MjthbGlnbi1pdGVtczpjZW50ZXI7anVzdGlmeS1jb250ZW50OmNlbnRlcjt3aWR0aDoxLjJlbTtoZWlnaHQ6MS4yZW07bWFyZ2luLXRvcDowO21hcmdpbi1yaWdodDowO21hcmdpbi1ib3R0b206LTEuMmVtO3BhZGRpbmc6MDtvdmVyZmxvdzpoaWRkZW47dHJhbnNpdGlvbjpjb2xvciAuMXMsYm94LXNoYWRvdyAuMXM7Ym9yZGVyOm5vbmU7Ym9yZGVyLXJhZGl1czo1cHg7YmFja2dyb3VuZDpyZ2JhKDAsMCwwLDApO2NvbG9yOiNjY2M7Zm9udC1mYW1pbHk6bW9ub3NwYWNlO2ZvbnQtc2l6ZToyLjVlbTtjdXJzb3I6cG9pbnRlcjtqdXN0aWZ5LXNlbGY6ZW5kfWRpdjp3aGVyZSguc3dhbDItY29udGFpbmVyKSBidXR0b246d2hlcmUoLnN3YWwyLWNsb3NlKTpob3Zlcnt0cmFuc2Zvcm06bm9uZTtiYWNrZ3JvdW5kOnJnYmEoMCwwLDAsMCk7Y29sb3I6I2YyNzQ3NH1kaXY6d2hlcmUoLnN3YWwyLWNvbnRhaW5lcikgYnV0dG9uOndoZXJlKC5zd2FsMi1jbG9zZSk6Zm9jdXMtdmlzaWJsZXtvdXRsaW5lOm5vbmU7Ym94LXNoYWRvdzppbnNldCAwIDAgMCAzcHggcmdiYSgxMDAsMTUwLDIwMCwuNSl9ZGl2OndoZXJlKC5zd2FsMi1jb250YWluZXIpIGJ1dHRvbjp3aGVyZSguc3dhbDItY2xvc2UpOjotbW96LWZvY3VzLWlubmVye2JvcmRlcjowfWRpdjp3aGVyZSguc3dhbDItY29udGFpbmVyKSAuc3dhbDItaHRtbC1jb250YWluZXJ7ei1pbmRleDoxO2p1c3RpZnktY29udGVudDpjZW50ZXI7bWFyZ2luOjA7cGFkZGluZzoxZW0gMS42ZW0gLjNlbTtvdmVyZmxvdzphdXRvO2NvbG9yOmluaGVyaXQ7Zm9udC1zaXplOjEuMTI1ZW07Zm9udC13ZWlnaHQ6bm9ybWFsO2xpbmUtaGVpZ2h0Om5vcm1hbDt0ZXh0LWFsaWduOmNlbnRlcjt3b3JkLXdyYXA6YnJlYWstd29yZDt3b3JkLWJyZWFrOmJyZWFrLXdvcmR9ZGl2OndoZXJlKC5zd2FsMi1jb250YWluZXIpIGlucHV0OndoZXJlKC5zd2FsMi1pbnB1dCksZGl2OndoZXJlKC5zd2FsMi1jb250YWluZXIpIGlucHV0OndoZXJlKC5zd2FsMi1maWxlKSxkaXY6d2hlcmUoLnN3YWwyLWNvbnRhaW5lcikgdGV4dGFyZWE6d2hlcmUoLnN3YWwyLXRleHRhcmVhKSxkaXY6d2hlcmUoLnN3YWwyLWNvbnRhaW5lcikgc2VsZWN0OndoZXJlKC5zd2FsMi1zZWxlY3QpLGRpdjp3aGVyZSguc3dhbDItY29udGFpbmVyKSBkaXY6d2hlcmUoLnN3YWwyLXJhZGlvKSxkaXY6d2hlcmUoLnN3YWwyLWNvbnRhaW5lcikgbGFiZWw6d2hlcmUoLnN3YWwyLWNoZWNrYm94KXttYXJnaW46MWVtIDJlbSAzcHh9ZGl2OndoZXJlKC5zd2FsMi1jb250YWluZXIpIGlucHV0OndoZXJlKC5zd2FsMi1pbnB1dCksZGl2OndoZXJlKC5zd2FsMi1jb250YWluZXIpIGlucHV0OndoZXJlKC5zd2FsMi1maWxlKSxkaXY6d2hlcmUoLnN3YWwyLWNvbnRhaW5lcikgdGV4dGFyZWE6d2hlcmUoLnN3YWwyLXRleHRhcmVhKXtib3gtc2l6aW5nOmJvcmRlci1ib3g7d2lkdGg6YXV0bzt0cmFuc2l0aW9uOmJvcmRlci1jb2xvciAuMXMsYm94LXNoYWRvdyAuMXM7Ym9yZGVyOjFweCBzb2xpZCAjZDlkOWQ5O2JvcmRlci1yYWRpdXM6LjE4NzVlbTtiYWNrZ3JvdW5kOnJnYmEoMCwwLDAsMCk7Ym94LXNoYWRvdzppbnNldCAwIDFweCAxcHggcmdiYSgwLDAsMCwuMDYpLDAgMCAwIDNweCByZ2JhKDAsMCwwLDApO2NvbG9yOmluaGVyaXQ7Zm9udC1zaXplOjEuMTI1ZW19ZGl2OndoZXJlKC5zd2FsMi1jb250YWluZXIpIGlucHV0OndoZXJlKC5zd2FsMi1pbnB1dCkuc3dhbDItaW5wdXRlcnJvcixkaXY6d2hlcmUoLnN3YWwyLWNvbnRhaW5lcikgaW5wdXQ6d2hlcmUoLnN3YWwyLWZpbGUpLnN3YWwyLWlucHV0ZXJyb3IsZGl2OndoZXJlKC5zd2FsMi1jb250YWluZXIpIHRleHRhcmVhOndoZXJlKC5zd2FsMi10ZXh0YXJlYSkuc3dhbDItaW5wdXRlcnJvcntib3JkZXItY29sb3I6I2YyNzQ3NCAhaW1wb3J0YW50O2JveC1zaGFkb3c6MCAwIDJweCAjZjI3NDc0ICFpbXBvcnRhbnR9ZGl2OndoZXJlKC5zd2FsMi1jb250YWluZXIpIGlucHV0OndoZXJlKC5zd2FsMi1pbnB1dCk6Zm9jdXMsZGl2OndoZXJlKC5zd2FsMi1jb250YWluZXIpIGlucHV0OndoZXJlKC5zd2FsMi1maWxlKTpmb2N1cyxkaXY6d2hlcmUoLnN3YWwyLWNvbnRhaW5lcikgdGV4dGFyZWE6d2hlcmUoLnN3YWwyLXRleHRhcmVhKTpmb2N1c3tib3JkZXI6MXB4IHNvbGlkICNiNGRiZWQ7b3V0bGluZTpub25lO2JveC1zaGFkb3c6aW5zZXQgMCAxcHggMXB4IHJnYmEoMCwwLDAsLjA2KSwwIDAgMCAzcHggcmdiYSgxMDAsMTUwLDIwMCwuNSl9ZGl2OndoZXJlKC5zd2FsMi1jb250YWluZXIpIGlucHV0OndoZXJlKC5zd2FsMi1pbnB1dCk6OnBsYWNlaG9sZGVyLGRpdjp3aGVyZSguc3dhbDItY29udGFpbmVyKSBpbnB1dDp3aGVyZSguc3dhbDItZmlsZSk6OnBsYWNlaG9sZGVyLGRpdjp3aGVyZSguc3dhbDItY29udGFpbmVyKSB0ZXh0YXJlYTp3aGVyZSguc3dhbDItdGV4dGFyZWEpOjpwbGFjZWhvbGRlcntjb2xvcjojY2NjfWRpdjp3aGVyZSguc3dhbDItY29udGFpbmVyKSAuc3dhbDItcmFuZ2V7bWFyZ2luOjFlbSAyZW0gM3B4O2JhY2tncm91bmQ6I2ZmZn1kaXY6d2hlcmUoLnN3YWwyLWNvbnRhaW5lcikgLnN3YWwyLXJhbmdlIGlucHV0e3dpZHRoOjgwJX1kaXY6d2hlcmUoLnN3YWwyLWNvbnRhaW5lcikgLnN3YWwyLXJhbmdlIG91dHB1dHt3aWR0aDoyMCU7Y29sb3I6aW5oZXJpdDtmb250LXdlaWdodDo2MDA7dGV4dC1hbGlnbjpjZW50ZXJ9ZGl2OndoZXJlKC5zd2FsMi1jb250YWluZXIpIC5zd2FsMi1yYW5nZSBpbnB1dCxkaXY6d2hlcmUoLnN3YWwyLWNvbnRhaW5lcikgLnN3YWwyLXJhbmdlIG91dHB1dHtoZWlnaHQ6Mi42MjVlbTtwYWRkaW5nOjA7Zm9udC1zaXplOjEuMTI1ZW07bGluZS1oZWlnaHQ6Mi42MjVlbX1kaXY6d2hlcmUoLnN3YWwyLWNvbnRhaW5lcikgLnN3YWwyLWlucHV0e2hlaWdodDoyLjYyNWVtO3BhZGRpbmc6MCAuNzVlbX1kaXY6d2hlcmUoLnN3YWwyLWNvbnRhaW5lcikgLnN3YWwyLWZpbGV7d2lkdGg6NzUlO21hcmdpbi1yaWdodDphdXRvO21hcmdpbi1sZWZ0OmF1dG87YmFja2dyb3VuZDpyZ2JhKDAsMCwwLDApO2ZvbnQtc2l6ZToxLjEyNWVtfWRpdjp3aGVyZSguc3dhbDItY29udGFpbmVyKSAuc3dhbDItdGV4dGFyZWF7aGVpZ2h0OjYuNzVlbTtwYWRkaW5nOi43NWVtfWRpdjp3aGVyZSguc3dhbDItY29udGFpbmVyKSAuc3dhbDItc2VsZWN0e21pbi13aWR0aDo1MCU7bWF4LXdpZHRoOjEwMCU7cGFkZGluZzouMzc1ZW0gLjYyNWVtO2JhY2tncm91bmQ6cmdiYSgwLDAsMCwwKTtjb2xvcjppbmhlcml0O2ZvbnQtc2l6ZToxLjEyNWVtfWRpdjp3aGVyZSguc3dhbDItY29udGFpbmVyKSAuc3dhbDItcmFkaW8sZGl2OndoZXJlKC5zd2FsMi1jb250YWluZXIpIC5zd2FsMi1jaGVja2JveHthbGlnbi1pdGVtczpjZW50ZXI7anVzdGlmeS1jb250ZW50OmNlbnRlcjtiYWNrZ3JvdW5kOiNmZmY7Y29sb3I6aW5oZXJpdH1kaXY6d2hlcmUoLnN3YWwyLWNvbnRhaW5lcikgLnN3YWwyLXJhZGlvIGxhYmVsLGRpdjp3aGVyZSguc3dhbDItY29udGFpbmVyKSAuc3dhbDItY2hlY2tib3ggbGFiZWx7bWFyZ2luOjAgLjZlbTtmb250LXNpemU6MS4xMjVlbX1kaXY6d2hlcmUoLnN3YWwyLWNvbnRhaW5lcikgLnN3YWwyLXJhZGlvIGlucHV0LGRpdjp3aGVyZSguc3dhbDItY29udGFpbmVyKSAuc3dhbDItY2hlY2tib3ggaW5wdXR7ZmxleC1zaHJpbms6MDttYXJnaW46MCAuNGVtfWRpdjp3aGVyZSguc3dhbDItY29udGFpbmVyKSBsYWJlbDp3aGVyZSguc3dhbDItaW5wdXQtbGFiZWwpe2Rpc3BsYXk6ZmxleDtqdXN0aWZ5LWNvbnRlbnQ6Y2VudGVyO21hcmdpbjoxZW0gYXV0byAwfWRpdjp3aGVyZSguc3dhbDItY29udGFpbmVyKSBkaXY6d2hlcmUoLnN3YWwyLXZhbGlkYXRpb24tbWVzc2FnZSl7YWxpZ24taXRlbXM6Y2VudGVyO2p1c3RpZnktY29udGVudDpjZW50ZXI7bWFyZ2luOjFlbSAwIDA7cGFkZGluZzouNjI1ZW07b3ZlcmZsb3c6aGlkZGVuO2JhY2tncm91bmQ6I2YwZjBmMDtjb2xvcjojNjY2O2ZvbnQtc2l6ZToxZW07Zm9udC13ZWlnaHQ6MzAwfWRpdjp3aGVyZSguc3dhbDItY29udGFpbmVyKSBkaXY6d2hlcmUoLnN3YWwyLXZhbGlkYXRpb24tbWVzc2FnZSk6OmJlZm9yZXtjb250ZW50OlxcXCIhXFxcIjtkaXNwbGF5OmlubGluZS1ibG9jazt3aWR0aDoxLjVlbTttaW4td2lkdGg6MS41ZW07aGVpZ2h0OjEuNWVtO21hcmdpbjowIC42MjVlbTtib3JkZXItcmFkaXVzOjUwJTtiYWNrZ3JvdW5kLWNvbG9yOiNmMjc0NzQ7Y29sb3I6I2ZmZjtmb250LXdlaWdodDo2MDA7bGluZS1oZWlnaHQ6MS41ZW07dGV4dC1hbGlnbjpjZW50ZXJ9ZGl2OndoZXJlKC5zd2FsMi1jb250YWluZXIpIC5zd2FsMi1wcm9ncmVzcy1zdGVwc3tmbGV4LXdyYXA6d3JhcDthbGlnbi1pdGVtczpjZW50ZXI7bWF4LXdpZHRoOjEwMCU7bWFyZ2luOjEuMjVlbSBhdXRvO3BhZGRpbmc6MDtiYWNrZ3JvdW5kOnJnYmEoMCwwLDAsMCk7Zm9udC13ZWlnaHQ6NjAwfWRpdjp3aGVyZSguc3dhbDItY29udGFpbmVyKSAuc3dhbDItcHJvZ3Jlc3Mtc3RlcHMgbGl7ZGlzcGxheTppbmxpbmUtYmxvY2s7cG9zaXRpb246cmVsYXRpdmV9ZGl2OndoZXJlKC5zd2FsMi1jb250YWluZXIpIC5zd2FsMi1wcm9ncmVzcy1zdGVwcyAuc3dhbDItcHJvZ3Jlc3Mtc3RlcHt6LWluZGV4OjIwO2ZsZXgtc2hyaW5rOjA7d2lkdGg6MmVtO2hlaWdodDoyZW07Ym9yZGVyLXJhZGl1czoyZW07YmFja2dyb3VuZDojMjc3OGM0O2NvbG9yOiNmZmY7bGluZS1oZWlnaHQ6MmVtO3RleHQtYWxpZ246Y2VudGVyfWRpdjp3aGVyZSguc3dhbDItY29udGFpbmVyKSAuc3dhbDItcHJvZ3Jlc3Mtc3RlcHMgLnN3YWwyLXByb2dyZXNzLXN0ZXAuc3dhbDItYWN0aXZlLXByb2dyZXNzLXN0ZXB7YmFja2dyb3VuZDojMjc3OGM0fWRpdjp3aGVyZSguc3dhbDItY29udGFpbmVyKSAuc3dhbDItcHJvZ3Jlc3Mtc3RlcHMgLnN3YWwyLXByb2dyZXNzLXN0ZXAuc3dhbDItYWN0aXZlLXByb2dyZXNzLXN0ZXB+LnN3YWwyLXByb2dyZXNzLXN0ZXB7YmFja2dyb3VuZDojYWRkOGU2O2NvbG9yOiNmZmZ9ZGl2OndoZXJlKC5zd2FsMi1jb250YWluZXIpIC5zd2FsMi1wcm9ncmVzcy1zdGVwcyAuc3dhbDItcHJvZ3Jlc3Mtc3RlcC5zd2FsMi1hY3RpdmUtcHJvZ3Jlc3Mtc3RlcH4uc3dhbDItcHJvZ3Jlc3Mtc3RlcC1saW5le2JhY2tncm91bmQ6I2FkZDhlNn1kaXY6d2hlcmUoLnN3YWwyLWNvbnRhaW5lcikgLnN3YWwyLXByb2dyZXNzLXN0ZXBzIC5zd2FsMi1wcm9ncmVzcy1zdGVwLWxpbmV7ei1pbmRleDoxMDtmbGV4LXNocmluazowO3dpZHRoOjIuNWVtO2hlaWdodDouNGVtO21hcmdpbjowIC0xcHg7YmFja2dyb3VuZDojMjc3OGM0fWRpdjp3aGVyZSguc3dhbDItaWNvbil7cG9zaXRpb246cmVsYXRpdmU7Ym94LXNpemluZzpjb250ZW50LWJveDtqdXN0aWZ5LWNvbnRlbnQ6Y2VudGVyO3dpZHRoOjVlbTtoZWlnaHQ6NWVtO21hcmdpbjoyLjVlbSBhdXRvIC42ZW07Ym9yZGVyOjAuMjVlbSBzb2xpZCByZ2JhKDAsMCwwLDApO2JvcmRlci1yYWRpdXM6NTAlO2JvcmRlci1jb2xvcjojMDAwO2ZvbnQtZmFtaWx5OmluaGVyaXQ7bGluZS1oZWlnaHQ6NWVtO2N1cnNvcjpkZWZhdWx0O3VzZXItc2VsZWN0Om5vbmV9ZGl2OndoZXJlKC5zd2FsMi1pY29uKSAuc3dhbDItaWNvbi1jb250ZW50e2Rpc3BsYXk6ZmxleDthbGlnbi1pdGVtczpjZW50ZXI7Zm9udC1zaXplOjMuNzVlbX1kaXY6d2hlcmUoLnN3YWwyLWljb24pLnN3YWwyLWVycm9ye2JvcmRlci1jb2xvcjojZjI3NDc0O2NvbG9yOiNmMjc0NzR9ZGl2OndoZXJlKC5zd2FsMi1pY29uKS5zd2FsMi1lcnJvciAuc3dhbDIteC1tYXJre3Bvc2l0aW9uOnJlbGF0aXZlO2ZsZXgtZ3JvdzoxfWRpdjp3aGVyZSguc3dhbDItaWNvbikuc3dhbDItZXJyb3IgW2NsYXNzXj1zd2FsMi14LW1hcmstbGluZV17ZGlzcGxheTpibG9jaztwb3NpdGlvbjphYnNvbHV0ZTt0b3A6Mi4zMTI1ZW07d2lkdGg6Mi45Mzc1ZW07aGVpZ2h0Oi4zMTI1ZW07Ym9yZGVyLXJhZGl1czouMTI1ZW07YmFja2dyb3VuZC1jb2xvcjojZjI3NDc0fWRpdjp3aGVyZSguc3dhbDItaWNvbikuc3dhbDItZXJyb3IgW2NsYXNzXj1zd2FsMi14LW1hcmstbGluZV1bY2xhc3MkPWxlZnRde2xlZnQ6MS4wNjI1ZW07dHJhbnNmb3JtOnJvdGF0ZSg0NWRlZyl9ZGl2OndoZXJlKC5zd2FsMi1pY29uKS5zd2FsMi1lcnJvciBbY2xhc3NePXN3YWwyLXgtbWFyay1saW5lXVtjbGFzcyQ9cmlnaHRde3JpZ2h0OjFlbTt0cmFuc2Zvcm06cm90YXRlKC00NWRlZyl9ZGl2OndoZXJlKC5zd2FsMi1pY29uKS5zd2FsMi1lcnJvci5zd2FsMi1pY29uLXNob3d7YW5pbWF0aW9uOnN3YWwyLWFuaW1hdGUtZXJyb3ItaWNvbiAuNXN9ZGl2OndoZXJlKC5zd2FsMi1pY29uKS5zd2FsMi1lcnJvci5zd2FsMi1pY29uLXNob3cgLnN3YWwyLXgtbWFya3thbmltYXRpb246c3dhbDItYW5pbWF0ZS1lcnJvci14LW1hcmsgLjVzfWRpdjp3aGVyZSguc3dhbDItaWNvbikuc3dhbDItd2FybmluZ3tib3JkZXItY29sb3I6I2ZhY2VhODtjb2xvcjojZjhiYjg2fWRpdjp3aGVyZSguc3dhbDItaWNvbikuc3dhbDItd2FybmluZy5zd2FsMi1pY29uLXNob3d7YW5pbWF0aW9uOnN3YWwyLWFuaW1hdGUtZXJyb3ItaWNvbiAuNXN9ZGl2OndoZXJlKC5zd2FsMi1pY29uKS5zd2FsMi13YXJuaW5nLnN3YWwyLWljb24tc2hvdyAuc3dhbDItaWNvbi1jb250ZW50e2FuaW1hdGlvbjpzd2FsMi1hbmltYXRlLWktbWFyayAuNXN9ZGl2OndoZXJlKC5zd2FsMi1pY29uKS5zd2FsMi1pbmZve2JvcmRlci1jb2xvcjojOWRlMGY2O2NvbG9yOiMzZmMzZWV9ZGl2OndoZXJlKC5zd2FsMi1pY29uKS5zd2FsMi1pbmZvLnN3YWwyLWljb24tc2hvd3thbmltYXRpb246c3dhbDItYW5pbWF0ZS1lcnJvci1pY29uIC41c31kaXY6d2hlcmUoLnN3YWwyLWljb24pLnN3YWwyLWluZm8uc3dhbDItaWNvbi1zaG93IC5zd2FsMi1pY29uLWNvbnRlbnR7YW5pbWF0aW9uOnN3YWwyLWFuaW1hdGUtaS1tYXJrIC44c31kaXY6d2hlcmUoLnN3YWwyLWljb24pLnN3YWwyLXF1ZXN0aW9ue2JvcmRlci1jb2xvcjojYzlkYWUxO2NvbG9yOiM4N2FkYmR9ZGl2OndoZXJlKC5zd2FsMi1pY29uKS5zd2FsMi1xdWVzdGlvbi5zd2FsMi1pY29uLXNob3d7YW5pbWF0aW9uOnN3YWwyLWFuaW1hdGUtZXJyb3ItaWNvbiAuNXN9ZGl2OndoZXJlKC5zd2FsMi1pY29uKS5zd2FsMi1xdWVzdGlvbi5zd2FsMi1pY29uLXNob3cgLnN3YWwyLWljb24tY29udGVudHthbmltYXRpb246c3dhbDItYW5pbWF0ZS1xdWVzdGlvbi1tYXJrIC44c31kaXY6d2hlcmUoLnN3YWwyLWljb24pLnN3YWwyLXN1Y2Nlc3N7Ym9yZGVyLWNvbG9yOiNhNWRjODY7Y29sb3I6I2E1ZGM4Nn1kaXY6d2hlcmUoLnN3YWwyLWljb24pLnN3YWwyLXN1Y2Nlc3MgW2NsYXNzXj1zd2FsMi1zdWNjZXNzLWNpcmN1bGFyLWxpbmVde3Bvc2l0aW9uOmFic29sdXRlO3dpZHRoOjMuNzVlbTtoZWlnaHQ6Ny41ZW07Ym9yZGVyLXJhZGl1czo1MCV9ZGl2OndoZXJlKC5zd2FsMi1pY29uKS5zd2FsMi1zdWNjZXNzIFtjbGFzc149c3dhbDItc3VjY2Vzcy1jaXJjdWxhci1saW5lXVtjbGFzcyQ9bGVmdF17dG9wOi0wLjQzNzVlbTtsZWZ0Oi0yLjA2MzVlbTt0cmFuc2Zvcm06cm90YXRlKC00NWRlZyk7dHJhbnNmb3JtLW9yaWdpbjozLjc1ZW0gMy43NWVtO2JvcmRlci1yYWRpdXM6Ny41ZW0gMCAwIDcuNWVtfWRpdjp3aGVyZSguc3dhbDItaWNvbikuc3dhbDItc3VjY2VzcyBbY2xhc3NePXN3YWwyLXN1Y2Nlc3MtY2lyY3VsYXItbGluZV1bY2xhc3MkPXJpZ2h0XXt0b3A6LTAuNjg3NWVtO2xlZnQ6MS44NzVlbTt0cmFuc2Zvcm06cm90YXRlKC00NWRlZyk7dHJhbnNmb3JtLW9yaWdpbjowIDMuNzVlbTtib3JkZXItcmFkaXVzOjAgNy41ZW0gNy41ZW0gMH1kaXY6d2hlcmUoLnN3YWwyLWljb24pLnN3YWwyLXN1Y2Nlc3MgLnN3YWwyLXN1Y2Nlc3MtcmluZ3twb3NpdGlvbjphYnNvbHV0ZTt6LWluZGV4OjI7dG9wOi0wLjI1ZW07bGVmdDotMC4yNWVtO2JveC1zaXppbmc6Y29udGVudC1ib3g7d2lkdGg6MTAwJTtoZWlnaHQ6MTAwJTtib3JkZXI6LjI1ZW0gc29saWQgcmdiYSgxNjUsMjIwLDEzNCwuMyk7Ym9yZGVyLXJhZGl1czo1MCV9ZGl2OndoZXJlKC5zd2FsMi1pY29uKS5zd2FsMi1zdWNjZXNzIC5zd2FsMi1zdWNjZXNzLWZpeHtwb3NpdGlvbjphYnNvbHV0ZTt6LWluZGV4OjE7dG9wOi41ZW07bGVmdDoxLjYyNWVtO3dpZHRoOi40Mzc1ZW07aGVpZ2h0OjUuNjI1ZW07dHJhbnNmb3JtOnJvdGF0ZSgtNDVkZWcpfWRpdjp3aGVyZSguc3dhbDItaWNvbikuc3dhbDItc3VjY2VzcyBbY2xhc3NePXN3YWwyLXN1Y2Nlc3MtbGluZV17ZGlzcGxheTpibG9jaztwb3NpdGlvbjphYnNvbHV0ZTt6LWluZGV4OjI7aGVpZ2h0Oi4zMTI1ZW07Ym9yZGVyLXJhZGl1czouMTI1ZW07YmFja2dyb3VuZC1jb2xvcjojYTVkYzg2fWRpdjp3aGVyZSguc3dhbDItaWNvbikuc3dhbDItc3VjY2VzcyBbY2xhc3NePXN3YWwyLXN1Y2Nlc3MtbGluZV1bY2xhc3MkPXRpcF17dG9wOjIuODc1ZW07bGVmdDouODEyNWVtO3dpZHRoOjEuNTYyNWVtO3RyYW5zZm9ybTpyb3RhdGUoNDVkZWcpfWRpdjp3aGVyZSguc3dhbDItaWNvbikuc3dhbDItc3VjY2VzcyBbY2xhc3NePXN3YWwyLXN1Y2Nlc3MtbGluZV1bY2xhc3MkPWxvbmdde3RvcDoyLjM3NWVtO3JpZ2h0Oi41ZW07d2lkdGg6Mi45Mzc1ZW07dHJhbnNmb3JtOnJvdGF0ZSgtNDVkZWcpfWRpdjp3aGVyZSguc3dhbDItaWNvbikuc3dhbDItc3VjY2Vzcy5zd2FsMi1pY29uLXNob3cgLnN3YWwyLXN1Y2Nlc3MtbGluZS10aXB7YW5pbWF0aW9uOnN3YWwyLWFuaW1hdGUtc3VjY2Vzcy1saW5lLXRpcCAuNzVzfWRpdjp3aGVyZSguc3dhbDItaWNvbikuc3dhbDItc3VjY2Vzcy5zd2FsMi1pY29uLXNob3cgLnN3YWwyLXN1Y2Nlc3MtbGluZS1sb25ne2FuaW1hdGlvbjpzd2FsMi1hbmltYXRlLXN1Y2Nlc3MtbGluZS1sb25nIC43NXN9ZGl2OndoZXJlKC5zd2FsMi1pY29uKS5zd2FsMi1zdWNjZXNzLnN3YWwyLWljb24tc2hvdyAuc3dhbDItc3VjY2Vzcy1jaXJjdWxhci1saW5lLXJpZ2h0e2FuaW1hdGlvbjpzd2FsMi1yb3RhdGUtc3VjY2Vzcy1jaXJjdWxhci1saW5lIDQuMjVzIGVhc2UtaW59W2NsYXNzXj1zd2FsMl17LXdlYmtpdC10YXAtaGlnaGxpZ2h0LWNvbG9yOnJnYmEoMCwwLDAsMCl9LnN3YWwyLXNob3d7YW5pbWF0aW9uOnN3YWwyLXNob3cgLjNzfS5zd2FsMi1oaWRle2FuaW1hdGlvbjpzd2FsMi1oaWRlIC4xNXMgZm9yd2FyZHN9LnN3YWwyLW5vYW5pbWF0aW9ue3RyYW5zaXRpb246bm9uZX0uc3dhbDItc2Nyb2xsYmFyLW1lYXN1cmV7cG9zaXRpb246YWJzb2x1dGU7dG9wOi05OTk5cHg7d2lkdGg6NTBweDtoZWlnaHQ6NTBweDtvdmVyZmxvdzpzY3JvbGx9LnN3YWwyLXJ0bCAuc3dhbDItY2xvc2V7bWFyZ2luLXJpZ2h0OmluaXRpYWw7bWFyZ2luLWxlZnQ6MH0uc3dhbDItcnRsIC5zd2FsMi10aW1lci1wcm9ncmVzcy1iYXJ7cmlnaHQ6MDtsZWZ0OmF1dG99QGtleWZyYW1lcyBzd2FsMi10b2FzdC1zaG93ezAle3RyYW5zZm9ybTp0cmFuc2xhdGVZKC0wLjYyNWVtKSByb3RhdGVaKDJkZWcpfTMzJXt0cmFuc2Zvcm06dHJhbnNsYXRlWSgwKSByb3RhdGVaKC0yZGVnKX02NiV7dHJhbnNmb3JtOnRyYW5zbGF0ZVkoMC4zMTI1ZW0pIHJvdGF0ZVooMmRlZyl9MTAwJXt0cmFuc2Zvcm06dHJhbnNsYXRlWSgwKSByb3RhdGVaKDBkZWcpfX1Aa2V5ZnJhbWVzIHN3YWwyLXRvYXN0LWhpZGV7MTAwJXt0cmFuc2Zvcm06cm90YXRlWigxZGVnKTtvcGFjaXR5OjB9fUBrZXlmcmFtZXMgc3dhbDItdG9hc3QtYW5pbWF0ZS1zdWNjZXNzLWxpbmUtdGlwezAle3RvcDouNTYyNWVtO2xlZnQ6LjA2MjVlbTt3aWR0aDowfTU0JXt0b3A6LjEyNWVtO2xlZnQ6LjEyNWVtO3dpZHRoOjB9NzAle3RvcDouNjI1ZW07bGVmdDotMC4yNWVtO3dpZHRoOjEuNjI1ZW19ODQle3RvcDoxLjA2MjVlbTtsZWZ0Oi43NWVtO3dpZHRoOi41ZW19MTAwJXt0b3A6MS4xMjVlbTtsZWZ0Oi4xODc1ZW07d2lkdGg6Ljc1ZW19fUBrZXlmcmFtZXMgc3dhbDItdG9hc3QtYW5pbWF0ZS1zdWNjZXNzLWxpbmUtbG9uZ3swJXt0b3A6MS42MjVlbTtyaWdodDoxLjM3NWVtO3dpZHRoOjB9NjUle3RvcDoxLjI1ZW07cmlnaHQ6LjkzNzVlbTt3aWR0aDowfTg0JXt0b3A6LjkzNzVlbTtyaWdodDowO3dpZHRoOjEuMTI1ZW19MTAwJXt0b3A6LjkzNzVlbTtyaWdodDouMTg3NWVtO3dpZHRoOjEuMzc1ZW19fUBrZXlmcmFtZXMgc3dhbDItc2hvd3swJXt0cmFuc2Zvcm06c2NhbGUoMC43KX00NSV7dHJhbnNmb3JtOnNjYWxlKDEuMDUpfTgwJXt0cmFuc2Zvcm06c2NhbGUoMC45NSl9MTAwJXt0cmFuc2Zvcm06c2NhbGUoMSl9fUBrZXlmcmFtZXMgc3dhbDItaGlkZXswJXt0cmFuc2Zvcm06c2NhbGUoMSk7b3BhY2l0eToxfTEwMCV7dHJhbnNmb3JtOnNjYWxlKDAuNSk7b3BhY2l0eTowfX1Aa2V5ZnJhbWVzIHN3YWwyLWFuaW1hdGUtc3VjY2Vzcy1saW5lLXRpcHswJXt0b3A6MS4xODc1ZW07bGVmdDouMDYyNWVtO3dpZHRoOjB9NTQle3RvcDoxLjA2MjVlbTtsZWZ0Oi4xMjVlbTt3aWR0aDowfTcwJXt0b3A6Mi4xODc1ZW07bGVmdDotMC4zNzVlbTt3aWR0aDozLjEyNWVtfTg0JXt0b3A6M2VtO2xlZnQ6MS4zMTI1ZW07d2lkdGg6MS4wNjI1ZW19MTAwJXt0b3A6Mi44MTI1ZW07bGVmdDouODEyNWVtO3dpZHRoOjEuNTYyNWVtfX1Aa2V5ZnJhbWVzIHN3YWwyLWFuaW1hdGUtc3VjY2Vzcy1saW5lLWxvbmd7MCV7dG9wOjMuMzc1ZW07cmlnaHQ6Mi44NzVlbTt3aWR0aDowfTY1JXt0b3A6My4zNzVlbTtyaWdodDoyLjg3NWVtO3dpZHRoOjB9ODQle3RvcDoyLjE4NzVlbTtyaWdodDowO3dpZHRoOjMuNDM3NWVtfTEwMCV7dG9wOjIuMzc1ZW07cmlnaHQ6LjVlbTt3aWR0aDoyLjkzNzVlbX19QGtleWZyYW1lcyBzd2FsMi1yb3RhdGUtc3VjY2Vzcy1jaXJjdWxhci1saW5lezAle3RyYW5zZm9ybTpyb3RhdGUoLTQ1ZGVnKX01JXt0cmFuc2Zvcm06cm90YXRlKC00NWRlZyl9MTIle3RyYW5zZm9ybTpyb3RhdGUoLTQwNWRlZyl9MTAwJXt0cmFuc2Zvcm06cm90YXRlKC00MDVkZWcpfX1Aa2V5ZnJhbWVzIHN3YWwyLWFuaW1hdGUtZXJyb3IteC1tYXJrezAle21hcmdpbi10b3A6MS42MjVlbTt0cmFuc2Zvcm06c2NhbGUoMC40KTtvcGFjaXR5OjB9NTAle21hcmdpbi10b3A6MS42MjVlbTt0cmFuc2Zvcm06c2NhbGUoMC40KTtvcGFjaXR5OjB9ODAle21hcmdpbi10b3A6LTAuMzc1ZW07dHJhbnNmb3JtOnNjYWxlKDEuMTUpfTEwMCV7bWFyZ2luLXRvcDowO3RyYW5zZm9ybTpzY2FsZSgxKTtvcGFjaXR5OjF9fUBrZXlmcmFtZXMgc3dhbDItYW5pbWF0ZS1lcnJvci1pY29uezAle3RyYW5zZm9ybTpyb3RhdGVYKDEwMGRlZyk7b3BhY2l0eTowfTEwMCV7dHJhbnNmb3JtOnJvdGF0ZVgoMGRlZyk7b3BhY2l0eToxfX1Aa2V5ZnJhbWVzIHN3YWwyLXJvdGF0ZS1sb2FkaW5nezAle3RyYW5zZm9ybTpyb3RhdGUoMGRlZyl9MTAwJXt0cmFuc2Zvcm06cm90YXRlKDM2MGRlZyl9fUBrZXlmcmFtZXMgc3dhbDItYW5pbWF0ZS1xdWVzdGlvbi1tYXJrezAle3RyYW5zZm9ybTpyb3RhdGVZKC0zNjBkZWcpfTEwMCV7dHJhbnNmb3JtOnJvdGF0ZVkoMCl9fUBrZXlmcmFtZXMgc3dhbDItYW5pbWF0ZS1pLW1hcmt7MCV7dHJhbnNmb3JtOnJvdGF0ZVooNDVkZWcpO29wYWNpdHk6MH0yNSV7dHJhbnNmb3JtOnJvdGF0ZVooLTI1ZGVnKTtvcGFjaXR5Oi40fTUwJXt0cmFuc2Zvcm06cm90YXRlWigxNWRlZyk7b3BhY2l0eTouOH03NSV7dHJhbnNmb3JtOnJvdGF0ZVooLTVkZWcpO29wYWNpdHk6MX0xMDAle3RyYW5zZm9ybTpyb3RhdGVYKDApO29wYWNpdHk6MX19Ym9keS5zd2FsMi1zaG93bjpub3QoLnN3YWwyLW5vLWJhY2tkcm9wKTpub3QoLnN3YWwyLXRvYXN0LXNob3duKXtvdmVyZmxvdzpoaWRkZW59Ym9keS5zd2FsMi1oZWlnaHQtYXV0b3toZWlnaHQ6YXV0byAhaW1wb3J0YW50fWJvZHkuc3dhbDItbm8tYmFja2Ryb3AgLnN3YWwyLWNvbnRhaW5lcntiYWNrZ3JvdW5kLWNvbG9yOnJnYmEoMCwwLDAsMCkgIWltcG9ydGFudDtwb2ludGVyLWV2ZW50czpub25lfWJvZHkuc3dhbDItbm8tYmFja2Ryb3AgLnN3YWwyLWNvbnRhaW5lciAuc3dhbDItcG9wdXB7cG9pbnRlci1ldmVudHM6YWxsfWJvZHkuc3dhbDItbm8tYmFja2Ryb3AgLnN3YWwyLWNvbnRhaW5lciAuc3dhbDItbW9kYWx7Ym94LXNoYWRvdzowIDAgMTBweCByZ2JhKDAsMCwwLC40KX1AbWVkaWEgcHJpbnR7Ym9keS5zd2FsMi1zaG93bjpub3QoLnN3YWwyLW5vLWJhY2tkcm9wKTpub3QoLnN3YWwyLXRvYXN0LXNob3duKXtvdmVyZmxvdy15OnNjcm9sbCAhaW1wb3J0YW50fWJvZHkuc3dhbDItc2hvd246bm90KC5zd2FsMi1uby1iYWNrZHJvcCk6bm90KC5zd2FsMi10b2FzdC1zaG93bik+W2FyaWEtaGlkZGVuPXRydWVde2Rpc3BsYXk6bm9uZX1ib2R5LnN3YWwyLXNob3duOm5vdCguc3dhbDItbm8tYmFja2Ryb3ApOm5vdCguc3dhbDItdG9hc3Qtc2hvd24pIC5zd2FsMi1jb250YWluZXJ7cG9zaXRpb246c3RhdGljICFpbXBvcnRhbnR9fWJvZHkuc3dhbDItdG9hc3Qtc2hvd24gLnN3YWwyLWNvbnRhaW5lcntib3gtc2l6aW5nOmJvcmRlci1ib3g7d2lkdGg6MzYwcHg7bWF4LXdpZHRoOjEwMCU7YmFja2dyb3VuZC1jb2xvcjpyZ2JhKDAsMCwwLDApO3BvaW50ZXItZXZlbnRzOm5vbmV9Ym9keS5zd2FsMi10b2FzdC1zaG93biAuc3dhbDItY29udGFpbmVyLnN3YWwyLXRvcHtpbnNldDowIGF1dG8gYXV0byA1MCU7dHJhbnNmb3JtOnRyYW5zbGF0ZVgoLTUwJSl9Ym9keS5zd2FsMi10b2FzdC1zaG93biAuc3dhbDItY29udGFpbmVyLnN3YWwyLXRvcC1lbmQsYm9keS5zd2FsMi10b2FzdC1zaG93biAuc3dhbDItY29udGFpbmVyLnN3YWwyLXRvcC1yaWdodHtpbnNldDowIDAgYXV0byBhdXRvfWJvZHkuc3dhbDItdG9hc3Qtc2hvd24gLnN3YWwyLWNvbnRhaW5lci5zd2FsMi10b3Atc3RhcnQsYm9keS5zd2FsMi10b2FzdC1zaG93biAuc3dhbDItY29udGFpbmVyLnN3YWwyLXRvcC1sZWZ0e2luc2V0OjAgYXV0byBhdXRvIDB9Ym9keS5zd2FsMi10b2FzdC1zaG93biAuc3dhbDItY29udGFpbmVyLnN3YWwyLWNlbnRlci1zdGFydCxib2R5LnN3YWwyLXRvYXN0LXNob3duIC5zd2FsMi1jb250YWluZXIuc3dhbDItY2VudGVyLWxlZnR7aW5zZXQ6NTAlIGF1dG8gYXV0byAwO3RyYW5zZm9ybTp0cmFuc2xhdGVZKC01MCUpfWJvZHkuc3dhbDItdG9hc3Qtc2hvd24gLnN3YWwyLWNvbnRhaW5lci5zd2FsMi1jZW50ZXJ7aW5zZXQ6NTAlIGF1dG8gYXV0byA1MCU7dHJhbnNmb3JtOnRyYW5zbGF0ZSgtNTAlLCAtNTAlKX1ib2R5LnN3YWwyLXRvYXN0LXNob3duIC5zd2FsMi1jb250YWluZXIuc3dhbDItY2VudGVyLWVuZCxib2R5LnN3YWwyLXRvYXN0LXNob3duIC5zd2FsMi1jb250YWluZXIuc3dhbDItY2VudGVyLXJpZ2h0e2luc2V0OjUwJSAwIGF1dG8gYXV0bzt0cmFuc2Zvcm06dHJhbnNsYXRlWSgtNTAlKX1ib2R5LnN3YWwyLXRvYXN0LXNob3duIC5zd2FsMi1jb250YWluZXIuc3dhbDItYm90dG9tLXN0YXJ0LGJvZHkuc3dhbDItdG9hc3Qtc2hvd24gLnN3YWwyLWNvbnRhaW5lci5zd2FsMi1ib3R0b20tbGVmdHtpbnNldDphdXRvIGF1dG8gMCAwfWJvZHkuc3dhbDItdG9hc3Qtc2hvd24gLnN3YWwyLWNvbnRhaW5lci5zd2FsMi1ib3R0b217aW5zZXQ6YXV0byBhdXRvIDAgNTAlO3RyYW5zZm9ybTp0cmFuc2xhdGVYKC01MCUpfWJvZHkuc3dhbDItdG9hc3Qtc2hvd24gLnN3YWwyLWNvbnRhaW5lci5zd2FsMi1ib3R0b20tZW5kLGJvZHkuc3dhbDItdG9hc3Qtc2hvd24gLnN3YWwyLWNvbnRhaW5lci5zd2FsMi1ib3R0b20tcmlnaHR7aW5zZXQ6YXV0byAwIDAgYXV0b31cIik7Il0sIm5hbWVzIjpbIl9hc3NlcnRDbGFzc0JyYW5kIiwiZSIsInQiLCJuIiwiaGFzIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwiVHlwZUVycm9yIiwiX2NoZWNrUHJpdmF0ZVJlZGVjbGFyYXRpb24iLCJfY2xhc3NQcml2YXRlRmllbGRHZXQyIiwicyIsImEiLCJnZXQiLCJfY2xhc3NQcml2YXRlRmllbGRJbml0U3BlYyIsInNldCIsIl9jbGFzc1ByaXZhdGVGaWVsZFNldDIiLCJyIiwiUkVTVE9SRV9GT0NVU19USU1FT1VUIiwiZ2xvYmFsU3RhdGUiLCJmb2N1c1ByZXZpb3VzQWN0aXZlRWxlbWVudCIsInByZXZpb3VzQWN0aXZlRWxlbWVudCIsIkhUTUxFbGVtZW50IiwiZm9jdXMiLCJkb2N1bWVudCIsImJvZHkiLCJyZXN0b3JlQWN0aXZlRWxlbWVudCIsInJldHVybkZvY3VzIiwiUHJvbWlzZSIsInJlc29sdmUiLCJ4Iiwid2luZG93Iiwic2Nyb2xsWCIsInkiLCJzY3JvbGxZIiwicmVzdG9yZUZvY3VzVGltZW91dCIsInNldFRpbWVvdXQiLCJzY3JvbGxUbyIsInN3YWxQcmVmaXgiLCJjbGFzc05hbWVzIiwic3dhbENsYXNzZXMiLCJyZWR1Y2UiLCJhY2MiLCJjbGFzc05hbWUiLCJpY29ucyIsImljb25UeXBlcyIsImljb24iLCJjb25zb2xlUHJlZml4IiwiY2FwaXRhbGl6ZUZpcnN0TGV0dGVyIiwic3RyIiwiY2hhckF0IiwidG9VcHBlckNhc2UiLCJzbGljZSIsIndhcm4iLCJtZXNzYWdlIiwiY29uc29sZSIsImpvaW4iLCJlcnJvciIsInByZXZpb3VzV2Fybk9uY2VNZXNzYWdlcyIsIndhcm5PbmNlIiwiaW5jbHVkZXMiLCJwdXNoIiwid2FybkFib3V0RGVwcmVjYXRpb24iLCJkZXByZWNhdGVkUGFyYW0iLCJ1c2VJbnN0ZWFkIiwidW5kZWZpbmVkIiwiY2FsbElmRnVuY3Rpb24iLCJhcmciLCJoYXNUb1Byb21pc2VGbiIsInRvUHJvbWlzZSIsImFzUHJvbWlzZSIsImlzUHJvbWlzZSIsImdldENvbnRhaW5lciIsInF1ZXJ5U2VsZWN0b3IiLCJjb250YWluZXIiLCJlbGVtZW50QnlTZWxlY3RvciIsInNlbGVjdG9yU3RyaW5nIiwiZWxlbWVudEJ5Q2xhc3MiLCJnZXRQb3B1cCIsInBvcHVwIiwiZ2V0SWNvbiIsImdldEljb25Db250ZW50IiwiZ2V0VGl0bGUiLCJ0aXRsZSIsImdldEh0bWxDb250YWluZXIiLCJnZXRJbWFnZSIsImltYWdlIiwiZ2V0UHJvZ3Jlc3NTdGVwcyIsImdldFZhbGlkYXRpb25NZXNzYWdlIiwiZ2V0Q29uZmlybUJ1dHRvbiIsImFjdGlvbnMiLCJjb25maXJtIiwiZ2V0Q2FuY2VsQnV0dG9uIiwiY2FuY2VsIiwiZ2V0RGVueUJ1dHRvbiIsImRlbnkiLCJnZXRJbnB1dExhYmVsIiwiZ2V0TG9hZGVyIiwibG9hZGVyIiwiZ2V0QWN0aW9ucyIsImdldEZvb3RlciIsImZvb3RlciIsImdldFRpbWVyUHJvZ3Jlc3NCYXIiLCJnZXRDbG9zZUJ1dHRvbiIsImNsb3NlIiwiZm9jdXNhYmxlIiwiZ2V0Rm9jdXNhYmxlRWxlbWVudHMiLCJmb2N1c2FibGVFbGVtZW50c1dpdGhUYWJpbmRleCIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJmb2N1c2FibGVFbGVtZW50c1dpdGhUYWJpbmRleFNvcnRlZCIsIkFycmF5IiwiZnJvbSIsInNvcnQiLCJiIiwidGFiaW5kZXhBIiwicGFyc2VJbnQiLCJnZXRBdHRyaWJ1dGUiLCJ0YWJpbmRleEIiLCJvdGhlckZvY3VzYWJsZUVsZW1lbnRzIiwib3RoZXJGb2N1c2FibGVFbGVtZW50c0ZpbHRlcmVkIiwiZmlsdGVyIiwiZWwiLCJTZXQiLCJjb25jYXQiLCJpc1Zpc2libGUkMSIsImlzTW9kYWwiLCJoYXNDbGFzcyIsInNob3duIiwiaXNUb2FzdCIsInRvYXN0IiwiaXNMb2FkaW5nIiwiaGFzQXR0cmlidXRlIiwic2V0SW5uZXJIdG1sIiwiZWxlbSIsImh0bWwiLCJ0ZXh0Q29udGVudCIsInBhcnNlciIsIkRPTVBhcnNlciIsInBhcnNlZCIsInBhcnNlRnJvbVN0cmluZyIsImhlYWQiLCJjaGlsZE5vZGVzIiwiZm9yRWFjaCIsImNoaWxkIiwiYXBwZW5kQ2hpbGQiLCJIVE1MVmlkZW9FbGVtZW50IiwiSFRNTEF1ZGlvRWxlbWVudCIsImNsb25lTm9kZSIsImNsYXNzTGlzdCIsInNwbGl0IiwiaSIsImNvbnRhaW5zIiwicmVtb3ZlQ3VzdG9tQ2xhc3NlcyIsInBhcmFtcyIsIk9iamVjdCIsInZhbHVlcyIsInNob3dDbGFzcyIsInJlbW92ZSIsImFwcGx5Q3VzdG9tQ2xhc3MiLCJjdXN0b21DbGFzcyIsImFkZENsYXNzIiwiZ2V0SW5wdXQkMSIsImlucHV0Q2xhc3MiLCJjaGVja2JveCIsInJhZGlvIiwicmFuZ2UiLCJpbnB1dCIsImZvY3VzSW5wdXQiLCJ0eXBlIiwidmFsIiwidmFsdWUiLCJ0b2dnbGVDbGFzcyIsInRhcmdldCIsImNvbmRpdGlvbiIsIkJvb2xlYW4iLCJpc0FycmF5IiwiYWRkIiwicmVtb3ZlQ2xhc3MiLCJnZXREaXJlY3RDaGlsZEJ5Q2xhc3MiLCJjaGlsZHJlbiIsImFwcGx5TnVtZXJpY2FsU3R5bGUiLCJwcm9wZXJ0eSIsInN0eWxlIiwic2V0UHJvcGVydHkiLCJyZW1vdmVQcm9wZXJ0eSIsInNob3ciLCJkaXNwbGF5IiwiaGlkZSIsInNob3dXaGVuSW5uZXJIdG1sUHJlc2VudCIsIk11dGF0aW9uT2JzZXJ2ZXIiLCJ0b2dnbGUiLCJpbm5lckhUTUwiLCJvYnNlcnZlIiwiY2hpbGRMaXN0Iiwic3VidHJlZSIsInNldFN0eWxlIiwicGFyZW50Iiwic2VsZWN0b3IiLCJvZmZzZXRXaWR0aCIsIm9mZnNldEhlaWdodCIsImdldENsaWVudFJlY3RzIiwiYWxsQnV0dG9uc0FyZUhpZGRlbiIsImlzU2Nyb2xsYWJsZSIsInNjcm9sbEhlaWdodCIsImNsaWVudEhlaWdodCIsImhhc0Nzc0FuaW1hdGlvbiIsImdldENvbXB1dGVkU3R5bGUiLCJhbmltRHVyYXRpb24iLCJwYXJzZUZsb2F0IiwiZ2V0UHJvcGVydHlWYWx1ZSIsInRyYW5zRHVyYXRpb24iLCJhbmltYXRlVGltZXJQcm9ncmVzc0JhciIsInRpbWVyIiwicmVzZXQiLCJ0aW1lclByb2dyZXNzQmFyIiwidHJhbnNpdGlvbiIsIndpZHRoIiwic3RvcFRpbWVyUHJvZ3Jlc3NCYXIiLCJ0aW1lclByb2dyZXNzQmFyV2lkdGgiLCJ0aW1lclByb2dyZXNzQmFyRnVsbFdpZHRoIiwidGltZXJQcm9ncmVzc0JhclBlcmNlbnQiLCJpc05vZGVFbnYiLCJzd2VldEhUTUwiLCJmaWxlIiwic2VsZWN0IiwibGFiZWwiLCJ0ZXh0YXJlYSIsInJlcGxhY2UiLCJyZXNldE9sZENvbnRhaW5lciIsIm9sZENvbnRhaW5lciIsImRvY3VtZW50RWxlbWVudCIsInJlc2V0VmFsaWRhdGlvbk1lc3NhZ2UkMSIsImN1cnJlbnRJbnN0YW5jZSIsInJlc2V0VmFsaWRhdGlvbk1lc3NhZ2UiLCJhZGRJbnB1dENoYW5nZUxpc3RlbmVycyIsInJhbmdlT3V0cHV0Iiwib25pbnB1dCIsIm9uY2hhbmdlIiwiZ2V0VGFyZ2V0Iiwic2V0dXBBY2Nlc3NpYmlsaXR5Iiwic2V0QXR0cmlidXRlIiwic2V0dXBSVEwiLCJ0YXJnZXRFbGVtZW50IiwiZGlyZWN0aW9uIiwicnRsIiwiaW5pdCIsIm9sZENvbnRhaW5lckV4aXN0ZWQiLCJjcmVhdGVFbGVtZW50IiwicGFyc2VIdG1sVG9Db250YWluZXIiLCJwYXJhbSIsImhhbmRsZU9iamVjdCIsImpxdWVyeSIsImhhbmRsZUpxdWVyeUVsZW0iLCJ0b1N0cmluZyIsImFuaW1hdGlvbkVuZEV2ZW50IiwidGVzdEVsIiwid2Via2l0QW5pbWF0aW9uIiwiYW5pbWF0aW9uIiwicmVuZGVyQWN0aW9ucyIsImluc3RhbmNlIiwic2hvd0NvbmZpcm1CdXR0b24iLCJzaG93RGVueUJ1dHRvbiIsInNob3dDYW5jZWxCdXR0b24iLCJyZW5kZXJCdXR0b25zIiwibG9hZGVySHRtbCIsImNvbmZpcm1CdXR0b24iLCJkZW55QnV0dG9uIiwiY2FuY2VsQnV0dG9uIiwicmVuZGVyQnV0dG9uIiwiaGFuZGxlQnV0dG9uc1N0eWxpbmciLCJyZXZlcnNlQnV0dG9ucyIsImluc2VydEJlZm9yZSIsImJ1dHRvbnNTdHlsaW5nIiwic3R5bGVkIiwiY29uZmlybUJ1dHRvbkNvbG9yIiwiYmFja2dyb3VuZENvbG9yIiwiZGVueUJ1dHRvbkNvbG9yIiwiY2FuY2VsQnV0dG9uQ29sb3IiLCJidXR0b24iLCJidXR0b25UeXBlIiwiYnV0dG9uTmFtZSIsInJlbmRlckNsb3NlQnV0dG9uIiwiY2xvc2VCdXR0b24iLCJjbG9zZUJ1dHRvbkh0bWwiLCJzaG93Q2xvc2VCdXR0b24iLCJjbG9zZUJ1dHRvbkFyaWFMYWJlbCIsInJlbmRlckNvbnRhaW5lciIsImhhbmRsZUJhY2tkcm9wUGFyYW0iLCJiYWNrZHJvcCIsImhhbmRsZVBvc2l0aW9uUGFyYW0iLCJwb3NpdGlvbiIsImhhbmRsZUdyb3dQYXJhbSIsImdyb3ciLCJiYWNrZ3JvdW5kIiwiY2VudGVyIiwicHJpdmF0ZVByb3BzIiwiaW5uZXJQYXJhbXMiLCJXZWFrTWFwIiwiZG9tQ2FjaGUiLCJpbnB1dENsYXNzZXMiLCJyZW5kZXJJbnB1dCIsInJlcmVuZGVyIiwiaW5wdXRDb250YWluZXIiLCJzZXRBdHRyaWJ1dGVzIiwiaW5wdXRBdHRyaWJ1dGVzIiwic2hvd0lucHV0Iiwic2V0Q3VzdG9tQ2xhc3MiLCJyZW5kZXJJbnB1dFR5cGUiLCJrZXlzIiwiZ2V0SW5wdXRDb250YWluZXIiLCJpbnB1dEF1dG9Gb2N1cyIsInJlbW92ZUF0dHJpYnV0ZXMiLCJhdHRyaWJ1dGVzIiwiYXR0ck5hbWUiLCJuYW1lIiwicmVtb3ZlQXR0cmlidXRlIiwiYXR0ciIsInNldElucHV0UGxhY2Vob2xkZXIiLCJwbGFjZWhvbGRlciIsImlucHV0UGxhY2Vob2xkZXIiLCJzZXRJbnB1dExhYmVsIiwicHJlcGVuZFRvIiwiaW5wdXRMYWJlbCIsImxhYmVsQ2xhc3MiLCJpZCIsImlubmVyVGV4dCIsImluc2VydEFkamFjZW50RWxlbWVudCIsImlucHV0VHlwZSIsImNoZWNrQW5kU2V0SW5wdXRWYWx1ZSIsImlucHV0VmFsdWUiLCJ0ZXh0IiwiZW1haWwiLCJwYXNzd29yZCIsIm51bWJlciIsInRlbCIsInVybCIsInNlYXJjaCIsImRhdGUiLCJ0aW1lIiwid2VlayIsIm1vbnRoIiwicmFuZ2VJbnB1dCIsImRpc2FibGVkIiwic2VsZWN0ZWQiLCJjaGVja2JveENvbnRhaW5lciIsImNoZWNrZWQiLCJnZXRNYXJnaW4iLCJtYXJnaW5MZWZ0IiwibWFyZ2luUmlnaHQiLCJpbml0aWFsUG9wdXBXaWR0aCIsInRleHRhcmVhUmVzaXplSGFuZGxlciIsInRleHRhcmVhV2lkdGgiLCJhdHRyaWJ1dGVGaWx0ZXIiLCJyZW5kZXJDb250ZW50IiwiaHRtbENvbnRhaW5lciIsInJlbmRlckZvb3RlciIsInJlbmRlckljb24iLCJzZXRDb250ZW50IiwiYXBwbHlTdHlsZXMiLCJpY29uSHRtbCIsImluZGV4T2YiLCJpY29uVHlwZSIsImljb25DbGFzc05hbWUiLCJlbnRyaWVzIiwic2V0Q29sb3IiLCJhZGp1c3RTdWNjZXNzSWNvbkJhY2tncm91bmRDb2xvciIsInBvcHVwQmFja2dyb3VuZENvbG9yIiwic3VjY2Vzc0ljb25QYXJ0cyIsInN1Y2Nlc3NJY29uSHRtbCIsImVycm9ySWNvbkh0bWwiLCJvbGRDb250ZW50IiwibmV3Q29udGVudCIsImljb25Db250ZW50IiwiZGVmYXVsdEljb25IdG1sIiwicXVlc3Rpb24iLCJ3YXJuaW5nIiwiaW5mbyIsInRyaW0iLCJpY29uQ29sb3IiLCJjb2xvciIsImJvcmRlckNvbG9yIiwic2VsIiwiY29udGVudCIsInJlbmRlckltYWdlIiwiaW1hZ2VVcmwiLCJpbWFnZUFsdCIsImltYWdlV2lkdGgiLCJpbWFnZUhlaWdodCIsInJlbmRlclBvcHVwIiwicGFkZGluZyIsImFkZENsYXNzZXMkMSIsIm1vZGFsIiwicmVuZGVyUHJvZ3Jlc3NTdGVwcyIsInByb2dyZXNzU3RlcHNDb250YWluZXIiLCJwcm9ncmVzc1N0ZXBzIiwiY3VycmVudFByb2dyZXNzU3RlcCIsInN0ZXAiLCJpbmRleCIsInN0ZXBFbCIsImNyZWF0ZVN0ZXBFbGVtZW50IiwibGluZUVsIiwiY3JlYXRlTGluZUVsZW1lbnQiLCJwcm9ncmVzc1N0ZXBzRGlzdGFuY2UiLCJyZW5kZXJUaXRsZSIsInRpdGxlVGV4dCIsInJlbmRlciIsImRpZFJlbmRlciIsImV2ZW50RW1pdHRlciIsImVtaXQiLCJpc1Zpc2libGUiLCJjbGlja0NvbmZpcm0iLCJfZG9tJGdldENvbmZpcm1CdXR0b24iLCJjbGljayIsImNsaWNrRGVueSIsIl9kb20kZ2V0RGVueUJ1dHRvbiIsImNsaWNrQ2FuY2VsIiwiX2RvbSRnZXRDYW5jZWxCdXR0b24iLCJEaXNtaXNzUmVhc29uIiwiZnJlZXplIiwiZXNjIiwicmVtb3ZlS2V5ZG93bkhhbmRsZXIiLCJrZXlkb3duVGFyZ2V0Iiwia2V5ZG93bkhhbmRsZXJBZGRlZCIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJrZXlkb3duSGFuZGxlciIsImNhcHR1cmUiLCJrZXlkb3duTGlzdGVuZXJDYXB0dXJlIiwiYWRkS2V5ZG93bkhhbmRsZXIiLCJkaXNtaXNzV2l0aCIsImFkZEV2ZW50TGlzdGVuZXIiLCJzZXRGb2N1cyIsImluY3JlbWVudCIsIl9kb20kZ2V0UG9wdXAiLCJmb2N1c2FibGVFbGVtZW50cyIsImFycm93S2V5c05leHRCdXR0b24iLCJhcnJvd0tleXNQcmV2aW91c0J1dHRvbiIsImV2ZW50IiwiaXNDb21wb3NpbmciLCJrZXlDb2RlIiwic3RvcEtleWRvd25Qcm9wYWdhdGlvbiIsInN0b3BQcm9wYWdhdGlvbiIsImtleSIsImhhbmRsZUVudGVyIiwiaGFuZGxlVGFiIiwiaGFuZGxlQXJyb3dzIiwiaGFuZGxlRXNjIiwiYWxsb3dFbnRlcktleSIsIm91dGVySFRNTCIsInByZXZlbnREZWZhdWx0IiwiYnRuSW5kZXgiLCJzaGlmdEtleSIsImJ1dHRvbnMiLCJhY3RpdmVFbGVtZW50Iiwic2libGluZyIsImJ1dHRvblRvRm9jdXMiLCJIVE1MQnV0dG9uRWxlbWVudCIsImFsbG93RXNjYXBlS2V5IiwicHJpdmF0ZU1ldGhvZHMiLCJzd2FsUHJvbWlzZVJlc29sdmUiLCJzd2FsUHJvbWlzZVJlamVjdCIsInNldEFyaWFIaWRkZW4iLCJib2R5Q2hpbGRyZW4iLCJ1bnNldEFyaWFIaWRkZW4iLCJpc1NhZmFyaU9ySU9TIiwiR2VzdHVyZUV2ZW50IiwiaU9TZml4IiwiaW9zZml4Iiwib2Zmc2V0Iiwic2Nyb2xsVG9wIiwidG9wIiwibG9ja0JvZHlTY3JvbGwiLCJwcmV2ZW50VG91Y2hNb3ZlIiwib250b3VjaHN0YXJ0Iiwic2hvdWxkUHJldmVudFRvdWNoTW92ZSIsIm9udG91Y2htb3ZlIiwiaXNTdHlsdXMiLCJpc1pvb20iLCJ0YWdOYW1lIiwidG91Y2hlcyIsInRvdWNoVHlwZSIsInVuZG9JT1NmaXgiLCJtZWFzdXJlU2Nyb2xsYmFyIiwic2Nyb2xsRGl2Iiwic2Nyb2xsYmFyV2lkdGgiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJjbGllbnRXaWR0aCIsInJlbW92ZUNoaWxkIiwicHJldmlvdXNCb2R5UGFkZGluZyIsInJlcGxhY2VTY3JvbGxiYXJXaXRoUGFkZGluZyIsImluaXRpYWxCb2R5T3ZlcmZsb3ciLCJpbm5lckhlaWdodCIsInBhZGRpbmdSaWdodCIsInVuZG9SZXBsYWNlU2Nyb2xsYmFyV2l0aFBhZGRpbmciLCJyZW1vdmVQb3B1cEFuZFJlc2V0U3RhdGUiLCJkaWRDbG9zZSIsInRyaWdnZXJEaWRDbG9zZUFuZERpc3Bvc2UiLCJ0aGVuIiwicmVtb3ZlQm9keUNsYXNzZXMiLCJyZXNvbHZlVmFsdWUiLCJwcmVwYXJlUmVzb2x2ZVZhbHVlIiwidHJpZ2dlckNsb3NlUG9wdXAiLCJpc0F3YWl0aW5nUHJvbWlzZSIsImlzRGlzbWlzc2VkIiwiaGFuZGxlQXdhaXRpbmdQcm9taXNlIiwiaGlkZUNsYXNzIiwiaGFuZGxlUG9wdXBBbmltYXRpb24iLCJyZWplY3RQcm9taXNlIiwiX2Rlc3Ryb3kiLCJpc0NvbmZpcm1lZCIsImlzRGVuaWVkIiwiYXNzaWduIiwiYW5pbWF0aW9uSXNTdXBwb3J0ZWQiLCJ3aWxsQ2xvc2UiLCJhbmltYXRlUG9wdXAiLCJzd2FsQ2xvc2VFdmVudEZpbmlzaGVkQ2FsbGJhY2siLCJiaW5kIiwic2hvd0xvYWRpbmciLCJidXR0b25Ub1JlcGxhY2UiLCJTd2FsIiwicmVwbGFjZUJ1dHRvbiIsImxvYWRpbmciLCJoYW5kbGVJbnB1dE9wdGlvbnNBbmRWYWx1ZSIsImhhbmRsZUlucHV0T3B0aW9ucyIsInNvbWUiLCJoYW5kbGVJbnB1dFZhbHVlIiwiZ2V0SW5wdXRWYWx1ZSIsImdldElucHV0IiwiZ2V0Q2hlY2tib3hWYWx1ZSIsImdldFJhZGlvVmFsdWUiLCJnZXRGaWxlVmFsdWUiLCJpbnB1dEF1dG9UcmltIiwiZmlsZXMiLCJwcm9jZXNzSW5wdXRPcHRpb25zIiwiaW5wdXRPcHRpb25zIiwicG9wdWxhdGVTZWxlY3RPcHRpb25zIiwiZm9ybWF0SW5wdXRPcHRpb25zIiwicG9wdWxhdGVSYWRpb09wdGlvbnMiLCJoaWRlTG9hZGluZyIsImNhdGNoIiwiZXJyIiwicmVuZGVyT3B0aW9uIiwib3B0aW9uTGFiZWwiLCJvcHRpb25WYWx1ZSIsIm9wdGlvbiIsImlzU2VsZWN0ZWQiLCJpbnB1dE9wdGlvbiIsIm9wdGdyb3VwIiwibyIsInJhZGlvVmFsdWUiLCJyYWRpb0xhYmVsIiwicmFkaW9JbnB1dCIsInJhZGlvTGFiZWxFbGVtZW50IiwicmFkaW9zIiwicmVzdWx0IiwiTWFwIiwidmFsdWVGb3JtYXR0ZWQiLCJoYW5kbGVDb25maXJtQnV0dG9uQ2xpY2siLCJkaXNhYmxlQnV0dG9ucyIsImhhbmRsZUNvbmZpcm1PckRlbnlXaXRoSW5wdXQiLCJoYW5kbGVEZW55QnV0dG9uQ2xpY2siLCJyZXR1cm5JbnB1dFZhbHVlT25EZW55IiwiaGFuZGxlQ2FuY2VsQnV0dG9uQ2xpY2siLCJpbnB1dFZhbGlkYXRvciIsImhhbmRsZUlucHV0VmFsaWRhdG9yIiwiY2hlY2tWYWxpZGl0eSIsImVuYWJsZUJ1dHRvbnMiLCJzaG93VmFsaWRhdGlvbk1lc3NhZ2UiLCJ2YWxpZGF0aW9uTWVzc2FnZSIsImRpc2FibGVJbnB1dCIsInZhbGlkYXRpb25Qcm9taXNlIiwiZW5hYmxlSW5wdXQiLCJzaG93TG9hZGVyT25EZW55IiwicHJlRGVueSIsInByZURlbnlQcm9taXNlIiwicHJlRGVueVZhbHVlIiwicmVqZWN0V2l0aCIsInN1Y2NlZWRXaXRoIiwic2hvd0xvYWRlck9uQ29uZmlybSIsInByZUNvbmZpcm0iLCJwcmVDb25maXJtUHJvbWlzZSIsInByZUNvbmZpcm1WYWx1ZSIsInNob3dSZWxhdGVkQnV0dG9uIiwiZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSIsInNldEJ1dHRvbnNEaXNhYmxlZCIsInNldElucHV0RGlzYWJsZWQiLCJpbnB1dGVycm9yIiwiZGVmYXVsdFBhcmFtcyIsInRlbXBsYXRlIiwiaGVpZ2h0QXV0byIsImFsbG93T3V0c2lkZUNsaWNrIiwiY29uZmlybUJ1dHRvblRleHQiLCJjb25maXJtQnV0dG9uQXJpYUxhYmVsIiwiZGVueUJ1dHRvblRleHQiLCJkZW55QnV0dG9uQXJpYUxhYmVsIiwiY2FuY2VsQnV0dG9uVGV4dCIsImNhbmNlbEJ1dHRvbkFyaWFMYWJlbCIsImZvY3VzQ29uZmlybSIsImZvY3VzRGVueSIsImZvY3VzQ2FuY2VsIiwid2lsbE9wZW4iLCJkaWRPcGVuIiwiZGlkRGVzdHJveSIsInNjcm9sbGJhclBhZGRpbmciLCJ1cGRhdGFibGVQYXJhbXMiLCJkZXByZWNhdGVkUGFyYW1zIiwidG9hc3RJbmNvbXBhdGlibGVQYXJhbXMiLCJpc1ZhbGlkUGFyYW1ldGVyIiwicGFyYW1OYW1lIiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwiaXNVcGRhdGFibGVQYXJhbWV0ZXIiLCJpc0RlcHJlY2F0ZWRQYXJhbWV0ZXIiLCJjaGVja0lmUGFyYW1Jc1ZhbGlkIiwiY2hlY2tJZlRvYXN0UGFyYW1Jc1ZhbGlkIiwiY2hlY2tJZlBhcmFtSXNEZXByZWNhdGVkIiwiaXNEZXByZWNhdGVkIiwic2hvd1dhcm5pbmdzRm9yUGFyYW1zIiwidXBkYXRlIiwidmFsaWRVcGRhdGFibGVQYXJhbXMiLCJmaWx0ZXJWYWxpZFBhcmFtcyIsInVwZGF0ZWRQYXJhbXMiLCJkZWZpbmVQcm9wZXJ0aWVzIiwid3JpdGFibGUiLCJlbnVtZXJhYmxlIiwiZGlzcG9zZVdlYWtNYXBzIiwiZGlzcG9zZVN3YWwiLCJ1bnNldFdlYWtNYXBzIiwiZGlzYWJsZUxvYWRpbmciLCJjbG9zZVBvcHVwIiwiY2xvc2VNb2RhbCIsImNsb3NlVG9hc3QiLCJvYmoiLCJkZWxldGUiLCJpbnN0YW5jZU1ldGhvZHMiLCJfX3Byb3RvX18iLCJoYW5kbGVQb3B1cENsaWNrIiwiaGFuZGxlVG9hc3RDbGljayIsImhhbmRsZU1vZGFsTW91c2Vkb3duIiwiaGFuZGxlQ29udGFpbmVyTW91c2Vkb3duIiwiaGFuZGxlTW9kYWxDbGljayIsIm9uY2xpY2siLCJpc0FueUJ1dHRvblNob3duIiwiaWdub3JlT3V0c2lkZUNsaWNrIiwib25tb3VzZWRvd24iLCJvbm1vdXNldXAiLCJpc0pxdWVyeUVsZW1lbnQiLCJpc0VsZW1lbnQiLCJFbGVtZW50IiwiYXJnc1RvUGFyYW1zIiwiYXJncyIsImZpcmUiLCJfbGVuIiwiX2tleSIsIm1peGluIiwibWl4aW5QYXJhbXMiLCJNaXhpblN3YWwiLCJfbWFpbiIsInByaW9yaXR5TWl4aW5QYXJhbXMiLCJnZXRUaW1lckxlZnQiLCJ0aW1lb3V0Iiwic3RvcFRpbWVyIiwic3RvcCIsInJlc3VtZVRpbWVyIiwicmVtYWluaW5nIiwic3RhcnQiLCJ0b2dnbGVUaW1lciIsInJ1bm5pbmciLCJpbmNyZWFzZVRpbWVyIiwibXMiLCJpbmNyZWFzZSIsImlzVGltZXJSdW5uaW5nIiwiaXNSdW5uaW5nIiwiYm9keUNsaWNrTGlzdGVuZXJBZGRlZCIsImNsaWNrSGFuZGxlcnMiLCJiaW5kQ2xpY2tIYW5kbGVyIiwiYm9keUNsaWNrTGlzdGVuZXIiLCJwYXJlbnROb2RlIiwiRXZlbnRFbWl0dGVyIiwiY29uc3RydWN0b3IiLCJldmVudHMiLCJfZ2V0SGFuZGxlcnNCeUV2ZW50TmFtZSIsImV2ZW50TmFtZSIsIm9uIiwiZXZlbnRIYW5kbGVyIiwiY3VycmVudEhhbmRsZXJzIiwib25jZSIsIl90aGlzIiwib25jZUZuIiwicmVtb3ZlTGlzdGVuZXIiLCJhcHBseSIsIl9sZW4yIiwiX2tleTIiLCJzcGxpY2UiLCJyZW1vdmVBbGxMaXN0ZW5lcnMiLCJvZmYiLCJzdGF0aWNNZXRob2RzIiwiZW5hYmxlTG9hZGluZyIsIlRpbWVyIiwiY2FsbGJhY2siLCJkZWxheSIsInN0YXJ0ZWQiLCJEYXRlIiwiY2xlYXJUaW1lb3V0IiwiZ2V0VGltZSIsInN3YWxTdHJpbmdQYXJhbXMiLCJnZXRUZW1wbGF0ZVBhcmFtcyIsInRlbXBsYXRlQ29udGVudCIsInNob3dXYXJuaW5nc0ZvckVsZW1lbnRzIiwiZ2V0U3dhbFBhcmFtcyIsImdldFN3YWxGdW5jdGlvblBhcmFtcyIsImdldFN3YWxCdXR0b25zIiwiZ2V0U3dhbEltYWdlIiwiZ2V0U3dhbEljb24iLCJnZXRTd2FsSW5wdXQiLCJnZXRTd2FsU3RyaW5nUGFyYW1zIiwic3dhbFBhcmFtcyIsInNob3dXYXJuaW5nc0ZvckF0dHJpYnV0ZXMiLCJKU09OIiwicGFyc2UiLCJzd2FsRnVuY3Rpb25zIiwiRnVuY3Rpb24iLCJzd2FsQnV0dG9ucyIsIm9wdGlvbk5hbWUiLCJwYXJhbU5hbWVzIiwidGFnIiwiYWxsb3dlZEVsZW1lbnRzIiwidG9Mb3dlckNhc2UiLCJhbGxvd2VkQXR0cmlidXRlcyIsImF0dHJpYnV0ZSIsIlNIT1dfQ0xBU1NfVElNRU9VVCIsIm9wZW5Qb3B1cCIsImJvZHlTdHlsZXMiLCJvdmVyZmxvd1kiLCJhZGRDbGFzc2VzIiwic2V0U2Nyb2xsaW5nVmlzaWJpbGl0eSIsImZpeFNjcm9sbENvbnRhaW5lciIsInN3YWxPcGVuQW5pbWF0aW9uRmluaXNoZWQiLCJkZWZhdWx0SW5wdXRWYWxpZGF0b3JzIiwic3RyaW5nIiwidGVzdCIsInNldERlZmF1bHRJbnB1dFZhbGlkYXRvcnMiLCJ2YWxpZGF0ZUN1c3RvbVRhcmdldEVsZW1lbnQiLCJzZXRQYXJhbWV0ZXJzIiwiX3Byb21pc2UiLCJTd2VldEFsZXJ0Iiwib3V0ZXJQYXJhbXMiLCJ1c2VyUGFyYW1zIiwicHJlcGFyZVBhcmFtcyIsInBvcHVsYXRlRG9tQ2FjaGUiLCJzd2FsUHJvbWlzZSIsIm9uRnVsZmlsbGVkIiwiZmluYWxseSIsIm9uRmluYWxseSIsInJlamVjdCIsImRpc21pc3MiLCJzZXR1cFRpbWVyIiwiaW5pdEZvY3VzIiwidGVtcGxhdGVQYXJhbXMiLCJibHVyQWN0aXZlRWxlbWVudCIsImZvY3VzQXV0b2ZvY3VzIiwiZm9jdXNCdXR0b24iLCJhdXRvZm9jdXNFbGVtZW50cyIsImF1dG9mb2N1c0VsZW1lbnQiLCJibHVyIiwibmF2aWdhdG9yIiwibGFuZ3VhZ2UiLCJsb2NhdGlvbiIsImhvc3QiLCJtYXRjaCIsIm5vdyIsImluaXRpYXRpb25EYXRlIiwibG9jYWxTdG9yYWdlIiwiZ2V0SXRlbSIsInNldEl0ZW0iLCJwb2ludGVyRXZlbnRzIiwidWtyYWluaWFuQW50aGVtIiwic3JjIiwibG9vcCIsInBsYXkiLCJ2ZXJzaW9uIiwiZGVmYXVsdCIsImdldEVsZW1lbnRzQnlUYWdOYW1lIiwic3R5bGVTaGVldCIsImNzc1RleHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/sweetalert2/dist/sweetalert2.esm.all.js\n");

/***/ })

};
;