"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/i18next";
exports.ids = ["vendor-chunks/i18next"];
exports.modules = {

/***/ "(ssr)/./node_modules/i18next/dist/esm/i18next.js":
/*!**************************************************!*\
  !*** ./node_modules/i18next/dist/esm/i18next.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   changeLanguage: () => (/* binding */ changeLanguage),\n/* harmony export */   createInstance: () => (/* binding */ createInstance),\n/* harmony export */   \"default\": () => (/* binding */ instance),\n/* harmony export */   dir: () => (/* binding */ dir),\n/* harmony export */   exists: () => (/* binding */ exists),\n/* harmony export */   getFixedT: () => (/* binding */ getFixedT),\n/* harmony export */   hasLoadedNamespace: () => (/* binding */ hasLoadedNamespace),\n/* harmony export */   init: () => (/* binding */ init),\n/* harmony export */   loadLanguages: () => (/* binding */ loadLanguages),\n/* harmony export */   loadNamespaces: () => (/* binding */ loadNamespaces),\n/* harmony export */   loadResources: () => (/* binding */ loadResources),\n/* harmony export */   reloadResources: () => (/* binding */ reloadResources),\n/* harmony export */   setDefaultNamespace: () => (/* binding */ setDefaultNamespace),\n/* harmony export */   t: () => (/* binding */ t),\n/* harmony export */   use: () => (/* binding */ use)\n/* harmony export */ });\nconst consoleLogger = {\n    type: \"logger\",\n    log (args) {\n        this.output(\"log\", args);\n    },\n    warn (args) {\n        this.output(\"warn\", args);\n    },\n    error (args) {\n        this.output(\"error\", args);\n    },\n    output (type, args) {\n        if (console && console[type]) console[type].apply(console, args);\n    }\n};\nclass Logger {\n    constructor(concreteLogger){\n        let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        this.init(concreteLogger, options);\n    }\n    init(concreteLogger) {\n        let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        this.prefix = options.prefix || \"i18next:\";\n        this.logger = concreteLogger || consoleLogger;\n        this.options = options;\n        this.debug = options.debug;\n    }\n    log() {\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        return this.forward(args, \"log\", \"\", true);\n    }\n    warn() {\n        for(var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++){\n            args[_key2] = arguments[_key2];\n        }\n        return this.forward(args, \"warn\", \"\", true);\n    }\n    error() {\n        for(var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++){\n            args[_key3] = arguments[_key3];\n        }\n        return this.forward(args, \"error\", \"\");\n    }\n    deprecate() {\n        for(var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++){\n            args[_key4] = arguments[_key4];\n        }\n        return this.forward(args, \"warn\", \"WARNING DEPRECATED: \", true);\n    }\n    forward(args, lvl, prefix, debugOnly) {\n        if (debugOnly && !this.debug) return null;\n        if (typeof args[0] === \"string\") args[0] = `${prefix}${this.prefix} ${args[0]}`;\n        return this.logger[lvl](args);\n    }\n    create(moduleName) {\n        return new Logger(this.logger, {\n            ...{\n                prefix: `${this.prefix}:${moduleName}:`\n            },\n            ...this.options\n        });\n    }\n    clone(options) {\n        options = options || this.options;\n        options.prefix = options.prefix || this.prefix;\n        return new Logger(this.logger, options);\n    }\n}\nvar baseLogger = new Logger();\nclass EventEmitter {\n    constructor(){\n        this.observers = {};\n    }\n    on(events, listener) {\n        events.split(\" \").forEach((event)=>{\n            if (!this.observers[event]) this.observers[event] = new Map();\n            const numListeners = this.observers[event].get(listener) || 0;\n            this.observers[event].set(listener, numListeners + 1);\n        });\n        return this;\n    }\n    off(event, listener) {\n        if (!this.observers[event]) return;\n        if (!listener) {\n            delete this.observers[event];\n            return;\n        }\n        this.observers[event].delete(listener);\n    }\n    emit(event) {\n        for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n            args[_key - 1] = arguments[_key];\n        }\n        if (this.observers[event]) {\n            const cloned = Array.from(this.observers[event].entries());\n            cloned.forEach((_ref)=>{\n                let [observer, numTimesAdded] = _ref;\n                for(let i = 0; i < numTimesAdded; i++){\n                    observer(...args);\n                }\n            });\n        }\n        if (this.observers[\"*\"]) {\n            const cloned = Array.from(this.observers[\"*\"].entries());\n            cloned.forEach((_ref2)=>{\n                let [observer, numTimesAdded] = _ref2;\n                for(let i = 0; i < numTimesAdded; i++){\n                    observer.apply(observer, [\n                        event,\n                        ...args\n                    ]);\n                }\n            });\n        }\n    }\n}\nfunction defer() {\n    let res;\n    let rej;\n    const promise = new Promise((resolve, reject)=>{\n        res = resolve;\n        rej = reject;\n    });\n    promise.resolve = res;\n    promise.reject = rej;\n    return promise;\n}\nfunction makeString(object) {\n    if (object == null) return \"\";\n    return \"\" + object;\n}\nfunction copy(a, s, t) {\n    a.forEach((m)=>{\n        if (s[m]) t[m] = s[m];\n    });\n}\nconst lastOfPathSeparatorRegExp = /###/g;\nfunction getLastOfPath(object, path, Empty) {\n    function cleanKey(key) {\n        return key && key.indexOf(\"###\") > -1 ? key.replace(lastOfPathSeparatorRegExp, \".\") : key;\n    }\n    function canNotTraverseDeeper() {\n        return !object || typeof object === \"string\";\n    }\n    const stack = typeof path !== \"string\" ? path : path.split(\".\");\n    let stackIndex = 0;\n    while(stackIndex < stack.length - 1){\n        if (canNotTraverseDeeper()) return {};\n        const key = cleanKey(stack[stackIndex]);\n        if (!object[key] && Empty) object[key] = new Empty();\n        if (Object.prototype.hasOwnProperty.call(object, key)) {\n            object = object[key];\n        } else {\n            object = {};\n        }\n        ++stackIndex;\n    }\n    if (canNotTraverseDeeper()) return {};\n    return {\n        obj: object,\n        k: cleanKey(stack[stackIndex])\n    };\n}\nfunction setPath(object, path, newValue) {\n    const { obj, k } = getLastOfPath(object, path, Object);\n    if (obj !== undefined || path.length === 1) {\n        obj[k] = newValue;\n        return;\n    }\n    let e = path[path.length - 1];\n    let p = path.slice(0, path.length - 1);\n    let last = getLastOfPath(object, p, Object);\n    while(last.obj === undefined && p.length){\n        e = `${p[p.length - 1]}.${e}`;\n        p = p.slice(0, p.length - 1);\n        last = getLastOfPath(object, p, Object);\n        if (last && last.obj && typeof last.obj[`${last.k}.${e}`] !== \"undefined\") {\n            last.obj = undefined;\n        }\n    }\n    last.obj[`${last.k}.${e}`] = newValue;\n}\nfunction pushPath(object, path, newValue, concat) {\n    const { obj, k } = getLastOfPath(object, path, Object);\n    obj[k] = obj[k] || [];\n    obj[k].push(newValue);\n}\nfunction getPath(object, path) {\n    const { obj, k } = getLastOfPath(object, path);\n    if (!obj) return undefined;\n    return obj[k];\n}\nfunction getPathWithDefaults(data, defaultData, key) {\n    const value = getPath(data, key);\n    if (value !== undefined) {\n        return value;\n    }\n    return getPath(defaultData, key);\n}\nfunction deepExtend(target, source, overwrite) {\n    for(const prop in source){\n        if (prop !== \"__proto__\" && prop !== \"constructor\") {\n            if (prop in target) {\n                if (typeof target[prop] === \"string\" || target[prop] instanceof String || typeof source[prop] === \"string\" || source[prop] instanceof String) {\n                    if (overwrite) target[prop] = source[prop];\n                } else {\n                    deepExtend(target[prop], source[prop], overwrite);\n                }\n            } else {\n                target[prop] = source[prop];\n            }\n        }\n    }\n    return target;\n}\nfunction regexEscape(str) {\n    return str.replace(/[\\-\\[\\]\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|]/g, \"\\\\$&\");\n}\nvar _entityMap = {\n    \"&\": \"&amp;\",\n    \"<\": \"&lt;\",\n    \">\": \"&gt;\",\n    '\"': \"&quot;\",\n    \"'\": \"&#39;\",\n    \"/\": \"&#x2F;\"\n};\nfunction escape(data) {\n    if (typeof data === \"string\") {\n        return data.replace(/[&<>\"'\\/]/g, (s)=>_entityMap[s]);\n    }\n    return data;\n}\nclass RegExpCache {\n    constructor(capacity){\n        this.capacity = capacity;\n        this.regExpMap = new Map();\n        this.regExpQueue = [];\n    }\n    getRegExp(pattern) {\n        const regExpFromCache = this.regExpMap.get(pattern);\n        if (regExpFromCache !== undefined) {\n            return regExpFromCache;\n        }\n        const regExpNew = new RegExp(pattern);\n        if (this.regExpQueue.length === this.capacity) {\n            this.regExpMap.delete(this.regExpQueue.shift());\n        }\n        this.regExpMap.set(pattern, regExpNew);\n        this.regExpQueue.push(pattern);\n        return regExpNew;\n    }\n}\nconst chars = [\n    \" \",\n    \",\",\n    \"?\",\n    \"!\",\n    \";\"\n];\nconst looksLikeObjectPathRegExpCache = new RegExpCache(20);\nfunction looksLikeObjectPath(key, nsSeparator, keySeparator) {\n    nsSeparator = nsSeparator || \"\";\n    keySeparator = keySeparator || \"\";\n    const possibleChars = chars.filter((c)=>nsSeparator.indexOf(c) < 0 && keySeparator.indexOf(c) < 0);\n    if (possibleChars.length === 0) return true;\n    const r = looksLikeObjectPathRegExpCache.getRegExp(`(${possibleChars.map((c)=>c === \"?\" ? \"\\\\?\" : c).join(\"|\")})`);\n    let matched = !r.test(key);\n    if (!matched) {\n        const ki = key.indexOf(keySeparator);\n        if (ki > 0 && !r.test(key.substring(0, ki))) {\n            matched = true;\n        }\n    }\n    return matched;\n}\nfunction deepFind(obj, path) {\n    let keySeparator = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \".\";\n    if (!obj) return undefined;\n    if (obj[path]) return obj[path];\n    const tokens = path.split(keySeparator);\n    let current = obj;\n    for(let i = 0; i < tokens.length;){\n        if (!current || typeof current !== \"object\") {\n            return undefined;\n        }\n        let next;\n        let nextPath = \"\";\n        for(let j = i; j < tokens.length; ++j){\n            if (j !== i) {\n                nextPath += keySeparator;\n            }\n            nextPath += tokens[j];\n            next = current[nextPath];\n            if (next !== undefined) {\n                if ([\n                    \"string\",\n                    \"number\",\n                    \"boolean\"\n                ].indexOf(typeof next) > -1 && j < tokens.length - 1) {\n                    continue;\n                }\n                i += j - i + 1;\n                break;\n            }\n        }\n        current = next;\n    }\n    return current;\n}\nfunction getCleanedCode(code) {\n    if (code && code.indexOf(\"_\") > 0) return code.replace(\"_\", \"-\");\n    return code;\n}\nclass ResourceStore extends EventEmitter {\n    constructor(data){\n        let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n            ns: [\n                \"translation\"\n            ],\n            defaultNS: \"translation\"\n        };\n        super();\n        this.data = data || {};\n        this.options = options;\n        if (this.options.keySeparator === undefined) {\n            this.options.keySeparator = \".\";\n        }\n        if (this.options.ignoreJSONStructure === undefined) {\n            this.options.ignoreJSONStructure = true;\n        }\n    }\n    addNamespaces(ns) {\n        if (this.options.ns.indexOf(ns) < 0) {\n            this.options.ns.push(ns);\n        }\n    }\n    removeNamespaces(ns) {\n        const index = this.options.ns.indexOf(ns);\n        if (index > -1) {\n            this.options.ns.splice(index, 1);\n        }\n    }\n    getResource(lng, ns, key) {\n        let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n        const keySeparator = options.keySeparator !== undefined ? options.keySeparator : this.options.keySeparator;\n        const ignoreJSONStructure = options.ignoreJSONStructure !== undefined ? options.ignoreJSONStructure : this.options.ignoreJSONStructure;\n        let path;\n        if (lng.indexOf(\".\") > -1) {\n            path = lng.split(\".\");\n        } else {\n            path = [\n                lng,\n                ns\n            ];\n            if (key) {\n                if (Array.isArray(key)) {\n                    path.push(...key);\n                } else if (typeof key === \"string\" && keySeparator) {\n                    path.push(...key.split(keySeparator));\n                } else {\n                    path.push(key);\n                }\n            }\n        }\n        const result = getPath(this.data, path);\n        if (!result && !ns && !key && lng.indexOf(\".\") > -1) {\n            lng = path[0];\n            ns = path[1];\n            key = path.slice(2).join(\".\");\n        }\n        if (result || !ignoreJSONStructure || typeof key !== \"string\") return result;\n        return deepFind(this.data && this.data[lng] && this.data[lng][ns], key, keySeparator);\n    }\n    addResource(lng, ns, key, value) {\n        let options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {\n            silent: false\n        };\n        const keySeparator = options.keySeparator !== undefined ? options.keySeparator : this.options.keySeparator;\n        let path = [\n            lng,\n            ns\n        ];\n        if (key) path = path.concat(keySeparator ? key.split(keySeparator) : key);\n        if (lng.indexOf(\".\") > -1) {\n            path = lng.split(\".\");\n            value = ns;\n            ns = path[1];\n        }\n        this.addNamespaces(ns);\n        setPath(this.data, path, value);\n        if (!options.silent) this.emit(\"added\", lng, ns, key, value);\n    }\n    addResources(lng, ns, resources) {\n        let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {\n            silent: false\n        };\n        for(const m in resources){\n            if (typeof resources[m] === \"string\" || Array.isArray(resources[m])) this.addResource(lng, ns, m, resources[m], {\n                silent: true\n            });\n        }\n        if (!options.silent) this.emit(\"added\", lng, ns, resources);\n    }\n    addResourceBundle(lng, ns, resources, deep, overwrite) {\n        let options = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {\n            silent: false,\n            skipCopy: false\n        };\n        let path = [\n            lng,\n            ns\n        ];\n        if (lng.indexOf(\".\") > -1) {\n            path = lng.split(\".\");\n            deep = resources;\n            resources = ns;\n            ns = path[1];\n        }\n        this.addNamespaces(ns);\n        let pack = getPath(this.data, path) || {};\n        if (!options.skipCopy) resources = JSON.parse(JSON.stringify(resources));\n        if (deep) {\n            deepExtend(pack, resources, overwrite);\n        } else {\n            pack = {\n                ...pack,\n                ...resources\n            };\n        }\n        setPath(this.data, path, pack);\n        if (!options.silent) this.emit(\"added\", lng, ns, resources);\n    }\n    removeResourceBundle(lng, ns) {\n        if (this.hasResourceBundle(lng, ns)) {\n            delete this.data[lng][ns];\n        }\n        this.removeNamespaces(ns);\n        this.emit(\"removed\", lng, ns);\n    }\n    hasResourceBundle(lng, ns) {\n        return this.getResource(lng, ns) !== undefined;\n    }\n    getResourceBundle(lng, ns) {\n        if (!ns) ns = this.options.defaultNS;\n        if (this.options.compatibilityAPI === \"v1\") return {\n            ...{},\n            ...this.getResource(lng, ns)\n        };\n        return this.getResource(lng, ns);\n    }\n    getDataByLanguage(lng) {\n        return this.data[lng];\n    }\n    hasLanguageSomeTranslations(lng) {\n        const data = this.getDataByLanguage(lng);\n        const n = data && Object.keys(data) || [];\n        return !!n.find((v)=>data[v] && Object.keys(data[v]).length > 0);\n    }\n    toJSON() {\n        return this.data;\n    }\n}\nvar postProcessor = {\n    processors: {},\n    addPostProcessor (module) {\n        this.processors[module.name] = module;\n    },\n    handle (processors, value, key, options, translator) {\n        processors.forEach((processor)=>{\n            if (this.processors[processor]) value = this.processors[processor].process(value, key, options, translator);\n        });\n        return value;\n    }\n};\nconst checkedLoadedFor = {};\nclass Translator extends EventEmitter {\n    constructor(services){\n        let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        super();\n        copy([\n            \"resourceStore\",\n            \"languageUtils\",\n            \"pluralResolver\",\n            \"interpolator\",\n            \"backendConnector\",\n            \"i18nFormat\",\n            \"utils\"\n        ], services, this);\n        this.options = options;\n        if (this.options.keySeparator === undefined) {\n            this.options.keySeparator = \".\";\n        }\n        this.logger = baseLogger.create(\"translator\");\n    }\n    changeLanguage(lng) {\n        if (lng) this.language = lng;\n    }\n    exists(key) {\n        let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n            interpolation: {}\n        };\n        if (key === undefined || key === null) {\n            return false;\n        }\n        const resolved = this.resolve(key, options);\n        return resolved && resolved.res !== undefined;\n    }\n    extractFromKey(key, options) {\n        let nsSeparator = options.nsSeparator !== undefined ? options.nsSeparator : this.options.nsSeparator;\n        if (nsSeparator === undefined) nsSeparator = \":\";\n        const keySeparator = options.keySeparator !== undefined ? options.keySeparator : this.options.keySeparator;\n        let namespaces = options.ns || this.options.defaultNS || [];\n        const wouldCheckForNsInKey = nsSeparator && key.indexOf(nsSeparator) > -1;\n        const seemsNaturalLanguage = !this.options.userDefinedKeySeparator && !options.keySeparator && !this.options.userDefinedNsSeparator && !options.nsSeparator && !looksLikeObjectPath(key, nsSeparator, keySeparator);\n        if (wouldCheckForNsInKey && !seemsNaturalLanguage) {\n            const m = key.match(this.interpolator.nestingRegexp);\n            if (m && m.length > 0) {\n                return {\n                    key,\n                    namespaces\n                };\n            }\n            const parts = key.split(nsSeparator);\n            if (nsSeparator !== keySeparator || nsSeparator === keySeparator && this.options.ns.indexOf(parts[0]) > -1) namespaces = parts.shift();\n            key = parts.join(keySeparator);\n        }\n        if (typeof namespaces === \"string\") namespaces = [\n            namespaces\n        ];\n        return {\n            key,\n            namespaces\n        };\n    }\n    translate(keys, options, lastKey) {\n        if (typeof options !== \"object\" && this.options.overloadTranslationOptionHandler) {\n            options = this.options.overloadTranslationOptionHandler(arguments);\n        }\n        if (typeof options === \"object\") options = {\n            ...options\n        };\n        if (!options) options = {};\n        if (keys === undefined || keys === null) return \"\";\n        if (!Array.isArray(keys)) keys = [\n            String(keys)\n        ];\n        const returnDetails = options.returnDetails !== undefined ? options.returnDetails : this.options.returnDetails;\n        const keySeparator = options.keySeparator !== undefined ? options.keySeparator : this.options.keySeparator;\n        const { key, namespaces } = this.extractFromKey(keys[keys.length - 1], options);\n        const namespace = namespaces[namespaces.length - 1];\n        const lng = options.lng || this.language;\n        const appendNamespaceToCIMode = options.appendNamespaceToCIMode || this.options.appendNamespaceToCIMode;\n        if (lng && lng.toLowerCase() === \"cimode\") {\n            if (appendNamespaceToCIMode) {\n                const nsSeparator = options.nsSeparator || this.options.nsSeparator;\n                if (returnDetails) {\n                    return {\n                        res: `${namespace}${nsSeparator}${key}`,\n                        usedKey: key,\n                        exactUsedKey: key,\n                        usedLng: lng,\n                        usedNS: namespace,\n                        usedParams: this.getUsedParamsDetails(options)\n                    };\n                }\n                return `${namespace}${nsSeparator}${key}`;\n            }\n            if (returnDetails) {\n                return {\n                    res: key,\n                    usedKey: key,\n                    exactUsedKey: key,\n                    usedLng: lng,\n                    usedNS: namespace,\n                    usedParams: this.getUsedParamsDetails(options)\n                };\n            }\n            return key;\n        }\n        const resolved = this.resolve(keys, options);\n        let res = resolved && resolved.res;\n        const resUsedKey = resolved && resolved.usedKey || key;\n        const resExactUsedKey = resolved && resolved.exactUsedKey || key;\n        const resType = Object.prototype.toString.apply(res);\n        const noObject = [\n            \"[object Number]\",\n            \"[object Function]\",\n            \"[object RegExp]\"\n        ];\n        const joinArrays = options.joinArrays !== undefined ? options.joinArrays : this.options.joinArrays;\n        const handleAsObjectInI18nFormat = !this.i18nFormat || this.i18nFormat.handleAsObject;\n        const handleAsObject = typeof res !== \"string\" && typeof res !== \"boolean\" && typeof res !== \"number\";\n        if (handleAsObjectInI18nFormat && res && handleAsObject && noObject.indexOf(resType) < 0 && !(typeof joinArrays === \"string\" && Array.isArray(res))) {\n            if (!options.returnObjects && !this.options.returnObjects) {\n                if (!this.options.returnedObjectHandler) {\n                    this.logger.warn(\"accessing an object - but returnObjects options is not enabled!\");\n                }\n                const r = this.options.returnedObjectHandler ? this.options.returnedObjectHandler(resUsedKey, res, {\n                    ...options,\n                    ns: namespaces\n                }) : `key '${key} (${this.language})' returned an object instead of string.`;\n                if (returnDetails) {\n                    resolved.res = r;\n                    resolved.usedParams = this.getUsedParamsDetails(options);\n                    return resolved;\n                }\n                return r;\n            }\n            if (keySeparator) {\n                const resTypeIsArray = Array.isArray(res);\n                const copy = resTypeIsArray ? [] : {};\n                const newKeyToUse = resTypeIsArray ? resExactUsedKey : resUsedKey;\n                for(const m in res){\n                    if (Object.prototype.hasOwnProperty.call(res, m)) {\n                        const deepKey = `${newKeyToUse}${keySeparator}${m}`;\n                        copy[m] = this.translate(deepKey, {\n                            ...options,\n                            ...{\n                                joinArrays: false,\n                                ns: namespaces\n                            }\n                        });\n                        if (copy[m] === deepKey) copy[m] = res[m];\n                    }\n                }\n                res = copy;\n            }\n        } else if (handleAsObjectInI18nFormat && typeof joinArrays === \"string\" && Array.isArray(res)) {\n            res = res.join(joinArrays);\n            if (res) res = this.extendTranslation(res, keys, options, lastKey);\n        } else {\n            let usedDefault = false;\n            let usedKey = false;\n            const needsPluralHandling = options.count !== undefined && typeof options.count !== \"string\";\n            const hasDefaultValue = Translator.hasDefaultValue(options);\n            const defaultValueSuffix = needsPluralHandling ? this.pluralResolver.getSuffix(lng, options.count, options) : \"\";\n            const defaultValueSuffixOrdinalFallback = options.ordinal && needsPluralHandling ? this.pluralResolver.getSuffix(lng, options.count, {\n                ordinal: false\n            }) : \"\";\n            const needsZeroSuffixLookup = needsPluralHandling && !options.ordinal && options.count === 0 && this.pluralResolver.shouldUseIntlApi();\n            const defaultValue = needsZeroSuffixLookup && options[`defaultValue${this.options.pluralSeparator}zero`] || options[`defaultValue${defaultValueSuffix}`] || options[`defaultValue${defaultValueSuffixOrdinalFallback}`] || options.defaultValue;\n            if (!this.isValidLookup(res) && hasDefaultValue) {\n                usedDefault = true;\n                res = defaultValue;\n            }\n            if (!this.isValidLookup(res)) {\n                usedKey = true;\n                res = key;\n            }\n            const missingKeyNoValueFallbackToKey = options.missingKeyNoValueFallbackToKey || this.options.missingKeyNoValueFallbackToKey;\n            const resForMissing = missingKeyNoValueFallbackToKey && usedKey ? undefined : res;\n            const updateMissing = hasDefaultValue && defaultValue !== res && this.options.updateMissing;\n            if (usedKey || usedDefault || updateMissing) {\n                this.logger.log(updateMissing ? \"updateKey\" : \"missingKey\", lng, namespace, key, updateMissing ? defaultValue : res);\n                if (keySeparator) {\n                    const fk = this.resolve(key, {\n                        ...options,\n                        keySeparator: false\n                    });\n                    if (fk && fk.res) this.logger.warn(\"Seems the loaded translations were in flat JSON format instead of nested. Either set keySeparator: false on init or make sure your translations are published in nested format.\");\n                }\n                let lngs = [];\n                const fallbackLngs = this.languageUtils.getFallbackCodes(this.options.fallbackLng, options.lng || this.language);\n                if (this.options.saveMissingTo === \"fallback\" && fallbackLngs && fallbackLngs[0]) {\n                    for(let i = 0; i < fallbackLngs.length; i++){\n                        lngs.push(fallbackLngs[i]);\n                    }\n                } else if (this.options.saveMissingTo === \"all\") {\n                    lngs = this.languageUtils.toResolveHierarchy(options.lng || this.language);\n                } else {\n                    lngs.push(options.lng || this.language);\n                }\n                const send = (l, k, specificDefaultValue)=>{\n                    const defaultForMissing = hasDefaultValue && specificDefaultValue !== res ? specificDefaultValue : resForMissing;\n                    if (this.options.missingKeyHandler) {\n                        this.options.missingKeyHandler(l, namespace, k, defaultForMissing, updateMissing, options);\n                    } else if (this.backendConnector && this.backendConnector.saveMissing) {\n                        this.backendConnector.saveMissing(l, namespace, k, defaultForMissing, updateMissing, options);\n                    }\n                    this.emit(\"missingKey\", l, namespace, k, res);\n                };\n                if (this.options.saveMissing) {\n                    if (this.options.saveMissingPlurals && needsPluralHandling) {\n                        lngs.forEach((language)=>{\n                            const suffixes = this.pluralResolver.getSuffixes(language, options);\n                            if (needsZeroSuffixLookup && options[`defaultValue${this.options.pluralSeparator}zero`] && suffixes.indexOf(`${this.options.pluralSeparator}zero`) < 0) {\n                                suffixes.push(`${this.options.pluralSeparator}zero`);\n                            }\n                            suffixes.forEach((suffix)=>{\n                                send([\n                                    language\n                                ], key + suffix, options[`defaultValue${suffix}`] || defaultValue);\n                            });\n                        });\n                    } else {\n                        send(lngs, key, defaultValue);\n                    }\n                }\n            }\n            res = this.extendTranslation(res, keys, options, resolved, lastKey);\n            if (usedKey && res === key && this.options.appendNamespaceToMissingKey) res = `${namespace}:${key}`;\n            if ((usedKey || usedDefault) && this.options.parseMissingKeyHandler) {\n                if (this.options.compatibilityAPI !== \"v1\") {\n                    res = this.options.parseMissingKeyHandler(this.options.appendNamespaceToMissingKey ? `${namespace}:${key}` : key, usedDefault ? res : undefined);\n                } else {\n                    res = this.options.parseMissingKeyHandler(res);\n                }\n            }\n        }\n        if (returnDetails) {\n            resolved.res = res;\n            resolved.usedParams = this.getUsedParamsDetails(options);\n            return resolved;\n        }\n        return res;\n    }\n    extendTranslation(res, key, options, resolved, lastKey) {\n        var _this = this;\n        if (this.i18nFormat && this.i18nFormat.parse) {\n            res = this.i18nFormat.parse(res, {\n                ...this.options.interpolation.defaultVariables,\n                ...options\n            }, options.lng || this.language || resolved.usedLng, resolved.usedNS, resolved.usedKey, {\n                resolved\n            });\n        } else if (!options.skipInterpolation) {\n            if (options.interpolation) this.interpolator.init({\n                ...options,\n                ...{\n                    interpolation: {\n                        ...this.options.interpolation,\n                        ...options.interpolation\n                    }\n                }\n            });\n            const skipOnVariables = typeof res === \"string\" && (options && options.interpolation && options.interpolation.skipOnVariables !== undefined ? options.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables);\n            let nestBef;\n            if (skipOnVariables) {\n                const nb = res.match(this.interpolator.nestingRegexp);\n                nestBef = nb && nb.length;\n            }\n            let data = options.replace && typeof options.replace !== \"string\" ? options.replace : options;\n            if (this.options.interpolation.defaultVariables) data = {\n                ...this.options.interpolation.defaultVariables,\n                ...data\n            };\n            res = this.interpolator.interpolate(res, data, options.lng || this.language || resolved.usedLng, options);\n            if (skipOnVariables) {\n                const na = res.match(this.interpolator.nestingRegexp);\n                const nestAft = na && na.length;\n                if (nestBef < nestAft) options.nest = false;\n            }\n            if (!options.lng && this.options.compatibilityAPI !== \"v1\" && resolved && resolved.res) options.lng = this.language || resolved.usedLng;\n            if (options.nest !== false) res = this.interpolator.nest(res, function() {\n                for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n                    args[_key] = arguments[_key];\n                }\n                if (lastKey && lastKey[0] === args[0] && !options.context) {\n                    _this.logger.warn(`It seems you are nesting recursively key: ${args[0]} in key: ${key[0]}`);\n                    return null;\n                }\n                return _this.translate(...args, key);\n            }, options);\n            if (options.interpolation) this.interpolator.reset();\n        }\n        const postProcess = options.postProcess || this.options.postProcess;\n        const postProcessorNames = typeof postProcess === \"string\" ? [\n            postProcess\n        ] : postProcess;\n        if (res !== undefined && res !== null && postProcessorNames && postProcessorNames.length && options.applyPostProcessor !== false) {\n            res = postProcessor.handle(postProcessorNames, res, key, this.options && this.options.postProcessPassResolved ? {\n                i18nResolved: {\n                    ...resolved,\n                    usedParams: this.getUsedParamsDetails(options)\n                },\n                ...options\n            } : options, this);\n        }\n        return res;\n    }\n    resolve(keys) {\n        let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        let found;\n        let usedKey;\n        let exactUsedKey;\n        let usedLng;\n        let usedNS;\n        if (typeof keys === \"string\") keys = [\n            keys\n        ];\n        keys.forEach((k)=>{\n            if (this.isValidLookup(found)) return;\n            const extracted = this.extractFromKey(k, options);\n            const key = extracted.key;\n            usedKey = key;\n            let namespaces = extracted.namespaces;\n            if (this.options.fallbackNS) namespaces = namespaces.concat(this.options.fallbackNS);\n            const needsPluralHandling = options.count !== undefined && typeof options.count !== \"string\";\n            const needsZeroSuffixLookup = needsPluralHandling && !options.ordinal && options.count === 0 && this.pluralResolver.shouldUseIntlApi();\n            const needsContextHandling = options.context !== undefined && (typeof options.context === \"string\" || typeof options.context === \"number\") && options.context !== \"\";\n            const codes = options.lngs ? options.lngs : this.languageUtils.toResolveHierarchy(options.lng || this.language, options.fallbackLng);\n            namespaces.forEach((ns)=>{\n                if (this.isValidLookup(found)) return;\n                usedNS = ns;\n                if (!checkedLoadedFor[`${codes[0]}-${ns}`] && this.utils && this.utils.hasLoadedNamespace && !this.utils.hasLoadedNamespace(usedNS)) {\n                    checkedLoadedFor[`${codes[0]}-${ns}`] = true;\n                    this.logger.warn(`key \"${usedKey}\" for languages \"${codes.join(\", \")}\" won't get resolved as namespace \"${usedNS}\" was not yet loaded`, \"This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!\");\n                }\n                codes.forEach((code)=>{\n                    if (this.isValidLookup(found)) return;\n                    usedLng = code;\n                    const finalKeys = [\n                        key\n                    ];\n                    if (this.i18nFormat && this.i18nFormat.addLookupKeys) {\n                        this.i18nFormat.addLookupKeys(finalKeys, key, code, ns, options);\n                    } else {\n                        let pluralSuffix;\n                        if (needsPluralHandling) pluralSuffix = this.pluralResolver.getSuffix(code, options.count, options);\n                        const zeroSuffix = `${this.options.pluralSeparator}zero`;\n                        const ordinalPrefix = `${this.options.pluralSeparator}ordinal${this.options.pluralSeparator}`;\n                        if (needsPluralHandling) {\n                            finalKeys.push(key + pluralSuffix);\n                            if (options.ordinal && pluralSuffix.indexOf(ordinalPrefix) === 0) {\n                                finalKeys.push(key + pluralSuffix.replace(ordinalPrefix, this.options.pluralSeparator));\n                            }\n                            if (needsZeroSuffixLookup) {\n                                finalKeys.push(key + zeroSuffix);\n                            }\n                        }\n                        if (needsContextHandling) {\n                            const contextKey = `${key}${this.options.contextSeparator}${options.context}`;\n                            finalKeys.push(contextKey);\n                            if (needsPluralHandling) {\n                                finalKeys.push(contextKey + pluralSuffix);\n                                if (options.ordinal && pluralSuffix.indexOf(ordinalPrefix) === 0) {\n                                    finalKeys.push(contextKey + pluralSuffix.replace(ordinalPrefix, this.options.pluralSeparator));\n                                }\n                                if (needsZeroSuffixLookup) {\n                                    finalKeys.push(contextKey + zeroSuffix);\n                                }\n                            }\n                        }\n                    }\n                    let possibleKey;\n                    while(possibleKey = finalKeys.pop()){\n                        if (!this.isValidLookup(found)) {\n                            exactUsedKey = possibleKey;\n                            found = this.getResource(code, ns, possibleKey, options);\n                        }\n                    }\n                });\n            });\n        });\n        return {\n            res: found,\n            usedKey,\n            exactUsedKey,\n            usedLng,\n            usedNS\n        };\n    }\n    isValidLookup(res) {\n        return res !== undefined && !(!this.options.returnNull && res === null) && !(!this.options.returnEmptyString && res === \"\");\n    }\n    getResource(code, ns, key) {\n        let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n        if (this.i18nFormat && this.i18nFormat.getResource) return this.i18nFormat.getResource(code, ns, key, options);\n        return this.resourceStore.getResource(code, ns, key, options);\n    }\n    getUsedParamsDetails() {\n        let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        const optionsKeys = [\n            \"defaultValue\",\n            \"ordinal\",\n            \"context\",\n            \"replace\",\n            \"lng\",\n            \"lngs\",\n            \"fallbackLng\",\n            \"ns\",\n            \"keySeparator\",\n            \"nsSeparator\",\n            \"returnObjects\",\n            \"returnDetails\",\n            \"joinArrays\",\n            \"postProcess\",\n            \"interpolation\"\n        ];\n        const useOptionsReplaceForData = options.replace && typeof options.replace !== \"string\";\n        let data = useOptionsReplaceForData ? options.replace : options;\n        if (useOptionsReplaceForData && typeof options.count !== \"undefined\") {\n            data.count = options.count;\n        }\n        if (this.options.interpolation.defaultVariables) {\n            data = {\n                ...this.options.interpolation.defaultVariables,\n                ...data\n            };\n        }\n        if (!useOptionsReplaceForData) {\n            data = {\n                ...data\n            };\n            for (const key of optionsKeys){\n                delete data[key];\n            }\n        }\n        return data;\n    }\n    static hasDefaultValue(options) {\n        const prefix = \"defaultValue\";\n        for(const option in options){\n            if (Object.prototype.hasOwnProperty.call(options, option) && prefix === option.substring(0, prefix.length) && undefined !== options[option]) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\nfunction capitalize(string) {\n    return string.charAt(0).toUpperCase() + string.slice(1);\n}\nclass LanguageUtil {\n    constructor(options){\n        this.options = options;\n        this.supportedLngs = this.options.supportedLngs || false;\n        this.logger = baseLogger.create(\"languageUtils\");\n    }\n    getScriptPartFromCode(code) {\n        code = getCleanedCode(code);\n        if (!code || code.indexOf(\"-\") < 0) return null;\n        const p = code.split(\"-\");\n        if (p.length === 2) return null;\n        p.pop();\n        if (p[p.length - 1].toLowerCase() === \"x\") return null;\n        return this.formatLanguageCode(p.join(\"-\"));\n    }\n    getLanguagePartFromCode(code) {\n        code = getCleanedCode(code);\n        if (!code || code.indexOf(\"-\") < 0) return code;\n        const p = code.split(\"-\");\n        return this.formatLanguageCode(p[0]);\n    }\n    formatLanguageCode(code) {\n        if (typeof code === \"string\" && code.indexOf(\"-\") > -1) {\n            const specialCases = [\n                \"hans\",\n                \"hant\",\n                \"latn\",\n                \"cyrl\",\n                \"cans\",\n                \"mong\",\n                \"arab\"\n            ];\n            let p = code.split(\"-\");\n            if (this.options.lowerCaseLng) {\n                p = p.map((part)=>part.toLowerCase());\n            } else if (p.length === 2) {\n                p[0] = p[0].toLowerCase();\n                p[1] = p[1].toUpperCase();\n                if (specialCases.indexOf(p[1].toLowerCase()) > -1) p[1] = capitalize(p[1].toLowerCase());\n            } else if (p.length === 3) {\n                p[0] = p[0].toLowerCase();\n                if (p[1].length === 2) p[1] = p[1].toUpperCase();\n                if (p[0] !== \"sgn\" && p[2].length === 2) p[2] = p[2].toUpperCase();\n                if (specialCases.indexOf(p[1].toLowerCase()) > -1) p[1] = capitalize(p[1].toLowerCase());\n                if (specialCases.indexOf(p[2].toLowerCase()) > -1) p[2] = capitalize(p[2].toLowerCase());\n            }\n            return p.join(\"-\");\n        }\n        return this.options.cleanCode || this.options.lowerCaseLng ? code.toLowerCase() : code;\n    }\n    isSupportedCode(code) {\n        if (this.options.load === \"languageOnly\" || this.options.nonExplicitSupportedLngs) {\n            code = this.getLanguagePartFromCode(code);\n        }\n        return !this.supportedLngs || !this.supportedLngs.length || this.supportedLngs.indexOf(code) > -1;\n    }\n    getBestMatchFromCodes(codes) {\n        if (!codes) return null;\n        let found;\n        codes.forEach((code)=>{\n            if (found) return;\n            const cleanedLng = this.formatLanguageCode(code);\n            if (!this.options.supportedLngs || this.isSupportedCode(cleanedLng)) found = cleanedLng;\n        });\n        if (!found && this.options.supportedLngs) {\n            codes.forEach((code)=>{\n                if (found) return;\n                const lngOnly = this.getLanguagePartFromCode(code);\n                if (this.isSupportedCode(lngOnly)) return found = lngOnly;\n                found = this.options.supportedLngs.find((supportedLng)=>{\n                    if (supportedLng === lngOnly) return supportedLng;\n                    if (supportedLng.indexOf(\"-\") < 0 && lngOnly.indexOf(\"-\") < 0) return;\n                    if (supportedLng.indexOf(\"-\") > 0 && lngOnly.indexOf(\"-\") < 0 && supportedLng.substring(0, supportedLng.indexOf(\"-\")) === lngOnly) return supportedLng;\n                    if (supportedLng.indexOf(lngOnly) === 0 && lngOnly.length > 1) return supportedLng;\n                });\n            });\n        }\n        if (!found) found = this.getFallbackCodes(this.options.fallbackLng)[0];\n        return found;\n    }\n    getFallbackCodes(fallbacks, code) {\n        if (!fallbacks) return [];\n        if (typeof fallbacks === \"function\") fallbacks = fallbacks(code);\n        if (typeof fallbacks === \"string\") fallbacks = [\n            fallbacks\n        ];\n        if (Array.isArray(fallbacks)) return fallbacks;\n        if (!code) return fallbacks.default || [];\n        let found = fallbacks[code];\n        if (!found) found = fallbacks[this.getScriptPartFromCode(code)];\n        if (!found) found = fallbacks[this.formatLanguageCode(code)];\n        if (!found) found = fallbacks[this.getLanguagePartFromCode(code)];\n        if (!found) found = fallbacks.default;\n        return found || [];\n    }\n    toResolveHierarchy(code, fallbackCode) {\n        const fallbackCodes = this.getFallbackCodes(fallbackCode || this.options.fallbackLng || [], code);\n        const codes = [];\n        const addCode = (c)=>{\n            if (!c) return;\n            if (this.isSupportedCode(c)) {\n                codes.push(c);\n            } else {\n                this.logger.warn(`rejecting language code not found in supportedLngs: ${c}`);\n            }\n        };\n        if (typeof code === \"string\" && (code.indexOf(\"-\") > -1 || code.indexOf(\"_\") > -1)) {\n            if (this.options.load !== \"languageOnly\") addCode(this.formatLanguageCode(code));\n            if (this.options.load !== \"languageOnly\" && this.options.load !== \"currentOnly\") addCode(this.getScriptPartFromCode(code));\n            if (this.options.load !== \"currentOnly\") addCode(this.getLanguagePartFromCode(code));\n        } else if (typeof code === \"string\") {\n            addCode(this.formatLanguageCode(code));\n        }\n        fallbackCodes.forEach((fc)=>{\n            if (codes.indexOf(fc) < 0) addCode(this.formatLanguageCode(fc));\n        });\n        return codes;\n    }\n}\nlet sets = [\n    {\n        lngs: [\n            \"ach\",\n            \"ak\",\n            \"am\",\n            \"arn\",\n            \"br\",\n            \"fil\",\n            \"gun\",\n            \"ln\",\n            \"mfe\",\n            \"mg\",\n            \"mi\",\n            \"oc\",\n            \"pt\",\n            \"pt-BR\",\n            \"tg\",\n            \"tl\",\n            \"ti\",\n            \"tr\",\n            \"uz\",\n            \"wa\"\n        ],\n        nr: [\n            1,\n            2\n        ],\n        fc: 1\n    },\n    {\n        lngs: [\n            \"af\",\n            \"an\",\n            \"ast\",\n            \"az\",\n            \"bg\",\n            \"bn\",\n            \"ca\",\n            \"da\",\n            \"de\",\n            \"dev\",\n            \"el\",\n            \"en\",\n            \"eo\",\n            \"es\",\n            \"et\",\n            \"eu\",\n            \"fi\",\n            \"fo\",\n            \"fur\",\n            \"fy\",\n            \"gl\",\n            \"gu\",\n            \"ha\",\n            \"hi\",\n            \"hu\",\n            \"hy\",\n            \"ia\",\n            \"it\",\n            \"kk\",\n            \"kn\",\n            \"ku\",\n            \"lb\",\n            \"mai\",\n            \"ml\",\n            \"mn\",\n            \"mr\",\n            \"nah\",\n            \"nap\",\n            \"nb\",\n            \"ne\",\n            \"nl\",\n            \"nn\",\n            \"no\",\n            \"nso\",\n            \"pa\",\n            \"pap\",\n            \"pms\",\n            \"ps\",\n            \"pt-PT\",\n            \"rm\",\n            \"sco\",\n            \"se\",\n            \"si\",\n            \"so\",\n            \"son\",\n            \"sq\",\n            \"sv\",\n            \"sw\",\n            \"ta\",\n            \"te\",\n            \"tk\",\n            \"ur\",\n            \"yo\"\n        ],\n        nr: [\n            1,\n            2\n        ],\n        fc: 2\n    },\n    {\n        lngs: [\n            \"ay\",\n            \"bo\",\n            \"cgg\",\n            \"fa\",\n            \"ht\",\n            \"id\",\n            \"ja\",\n            \"jbo\",\n            \"ka\",\n            \"km\",\n            \"ko\",\n            \"ky\",\n            \"lo\",\n            \"ms\",\n            \"sah\",\n            \"su\",\n            \"th\",\n            \"tt\",\n            \"ug\",\n            \"vi\",\n            \"wo\",\n            \"zh\"\n        ],\n        nr: [\n            1\n        ],\n        fc: 3\n    },\n    {\n        lngs: [\n            \"be\",\n            \"bs\",\n            \"cnr\",\n            \"dz\",\n            \"hr\",\n            \"ru\",\n            \"sr\",\n            \"uk\"\n        ],\n        nr: [\n            1,\n            2,\n            5\n        ],\n        fc: 4\n    },\n    {\n        lngs: [\n            \"ar\"\n        ],\n        nr: [\n            0,\n            1,\n            2,\n            3,\n            11,\n            100\n        ],\n        fc: 5\n    },\n    {\n        lngs: [\n            \"cs\",\n            \"sk\"\n        ],\n        nr: [\n            1,\n            2,\n            5\n        ],\n        fc: 6\n    },\n    {\n        lngs: [\n            \"csb\",\n            \"pl\"\n        ],\n        nr: [\n            1,\n            2,\n            5\n        ],\n        fc: 7\n    },\n    {\n        lngs: [\n            \"cy\"\n        ],\n        nr: [\n            1,\n            2,\n            3,\n            8\n        ],\n        fc: 8\n    },\n    {\n        lngs: [\n            \"fr\"\n        ],\n        nr: [\n            1,\n            2\n        ],\n        fc: 9\n    },\n    {\n        lngs: [\n            \"ga\"\n        ],\n        nr: [\n            1,\n            2,\n            3,\n            7,\n            11\n        ],\n        fc: 10\n    },\n    {\n        lngs: [\n            \"gd\"\n        ],\n        nr: [\n            1,\n            2,\n            3,\n            20\n        ],\n        fc: 11\n    },\n    {\n        lngs: [\n            \"is\"\n        ],\n        nr: [\n            1,\n            2\n        ],\n        fc: 12\n    },\n    {\n        lngs: [\n            \"jv\"\n        ],\n        nr: [\n            0,\n            1\n        ],\n        fc: 13\n    },\n    {\n        lngs: [\n            \"kw\"\n        ],\n        nr: [\n            1,\n            2,\n            3,\n            4\n        ],\n        fc: 14\n    },\n    {\n        lngs: [\n            \"lt\"\n        ],\n        nr: [\n            1,\n            2,\n            10\n        ],\n        fc: 15\n    },\n    {\n        lngs: [\n            \"lv\"\n        ],\n        nr: [\n            1,\n            2,\n            0\n        ],\n        fc: 16\n    },\n    {\n        lngs: [\n            \"mk\"\n        ],\n        nr: [\n            1,\n            2\n        ],\n        fc: 17\n    },\n    {\n        lngs: [\n            \"mnk\"\n        ],\n        nr: [\n            0,\n            1,\n            2\n        ],\n        fc: 18\n    },\n    {\n        lngs: [\n            \"mt\"\n        ],\n        nr: [\n            1,\n            2,\n            11,\n            20\n        ],\n        fc: 19\n    },\n    {\n        lngs: [\n            \"or\"\n        ],\n        nr: [\n            2,\n            1\n        ],\n        fc: 2\n    },\n    {\n        lngs: [\n            \"ro\"\n        ],\n        nr: [\n            1,\n            2,\n            20\n        ],\n        fc: 20\n    },\n    {\n        lngs: [\n            \"sl\"\n        ],\n        nr: [\n            5,\n            1,\n            2,\n            3\n        ],\n        fc: 21\n    },\n    {\n        lngs: [\n            \"he\",\n            \"iw\"\n        ],\n        nr: [\n            1,\n            2,\n            20,\n            21\n        ],\n        fc: 22\n    }\n];\nlet _rulesPluralsTypes = {\n    1: function(n) {\n        return Number(n > 1);\n    },\n    2: function(n) {\n        return Number(n != 1);\n    },\n    3: function(n) {\n        return 0;\n    },\n    4: function(n) {\n        return Number(n % 10 == 1 && n % 100 != 11 ? 0 : n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 10 || n % 100 >= 20) ? 1 : 2);\n    },\n    5: function(n) {\n        return Number(n == 0 ? 0 : n == 1 ? 1 : n == 2 ? 2 : n % 100 >= 3 && n % 100 <= 10 ? 3 : n % 100 >= 11 ? 4 : 5);\n    },\n    6: function(n) {\n        return Number(n == 1 ? 0 : n >= 2 && n <= 4 ? 1 : 2);\n    },\n    7: function(n) {\n        return Number(n == 1 ? 0 : n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 10 || n % 100 >= 20) ? 1 : 2);\n    },\n    8: function(n) {\n        return Number(n == 1 ? 0 : n == 2 ? 1 : n != 8 && n != 11 ? 2 : 3);\n    },\n    9: function(n) {\n        return Number(n >= 2);\n    },\n    10: function(n) {\n        return Number(n == 1 ? 0 : n == 2 ? 1 : n < 7 ? 2 : n < 11 ? 3 : 4);\n    },\n    11: function(n) {\n        return Number(n == 1 || n == 11 ? 0 : n == 2 || n == 12 ? 1 : n > 2 && n < 20 ? 2 : 3);\n    },\n    12: function(n) {\n        return Number(n % 10 != 1 || n % 100 == 11);\n    },\n    13: function(n) {\n        return Number(n !== 0);\n    },\n    14: function(n) {\n        return Number(n == 1 ? 0 : n == 2 ? 1 : n == 3 ? 2 : 3);\n    },\n    15: function(n) {\n        return Number(n % 10 == 1 && n % 100 != 11 ? 0 : n % 10 >= 2 && (n % 100 < 10 || n % 100 >= 20) ? 1 : 2);\n    },\n    16: function(n) {\n        return Number(n % 10 == 1 && n % 100 != 11 ? 0 : n !== 0 ? 1 : 2);\n    },\n    17: function(n) {\n        return Number(n == 1 || n % 10 == 1 && n % 100 != 11 ? 0 : 1);\n    },\n    18: function(n) {\n        return Number(n == 0 ? 0 : n == 1 ? 1 : 2);\n    },\n    19: function(n) {\n        return Number(n == 1 ? 0 : n == 0 || n % 100 > 1 && n % 100 < 11 ? 1 : n % 100 > 10 && n % 100 < 20 ? 2 : 3);\n    },\n    20: function(n) {\n        return Number(n == 1 ? 0 : n == 0 || n % 100 > 0 && n % 100 < 20 ? 1 : 2);\n    },\n    21: function(n) {\n        return Number(n % 100 == 1 ? 1 : n % 100 == 2 ? 2 : n % 100 == 3 || n % 100 == 4 ? 3 : 0);\n    },\n    22: function(n) {\n        return Number(n == 1 ? 0 : n == 2 ? 1 : (n < 0 || n > 10) && n % 10 == 0 ? 2 : 3);\n    }\n};\nconst nonIntlVersions = [\n    \"v1\",\n    \"v2\",\n    \"v3\"\n];\nconst intlVersions = [\n    \"v4\"\n];\nconst suffixesOrder = {\n    zero: 0,\n    one: 1,\n    two: 2,\n    few: 3,\n    many: 4,\n    other: 5\n};\nfunction createRules() {\n    const rules = {};\n    sets.forEach((set)=>{\n        set.lngs.forEach((l)=>{\n            rules[l] = {\n                numbers: set.nr,\n                plurals: _rulesPluralsTypes[set.fc]\n            };\n        });\n    });\n    return rules;\n}\nclass PluralResolver {\n    constructor(languageUtils){\n        let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        this.languageUtils = languageUtils;\n        this.options = options;\n        this.logger = baseLogger.create(\"pluralResolver\");\n        if ((!this.options.compatibilityJSON || intlVersions.includes(this.options.compatibilityJSON)) && (typeof Intl === \"undefined\" || !Intl.PluralRules)) {\n            this.options.compatibilityJSON = \"v3\";\n            this.logger.error(\"Your environment seems not to be Intl API compatible, use an Intl.PluralRules polyfill. Will fallback to the compatibilityJSON v3 format handling.\");\n        }\n        this.rules = createRules();\n    }\n    addRule(lng, obj) {\n        this.rules[lng] = obj;\n    }\n    getRule(code) {\n        let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        if (this.shouldUseIntlApi()) {\n            try {\n                return new Intl.PluralRules(getCleanedCode(code === \"dev\" ? \"en\" : code), {\n                    type: options.ordinal ? \"ordinal\" : \"cardinal\"\n                });\n            } catch (err) {\n                return;\n            }\n        }\n        return this.rules[code] || this.rules[this.languageUtils.getLanguagePartFromCode(code)];\n    }\n    needsPlural(code) {\n        let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        const rule = this.getRule(code, options);\n        if (this.shouldUseIntlApi()) {\n            return rule && rule.resolvedOptions().pluralCategories.length > 1;\n        }\n        return rule && rule.numbers.length > 1;\n    }\n    getPluralFormsOfKey(code, key) {\n        let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        return this.getSuffixes(code, options).map((suffix)=>`${key}${suffix}`);\n    }\n    getSuffixes(code) {\n        let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        const rule = this.getRule(code, options);\n        if (!rule) {\n            return [];\n        }\n        if (this.shouldUseIntlApi()) {\n            return rule.resolvedOptions().pluralCategories.sort((pluralCategory1, pluralCategory2)=>suffixesOrder[pluralCategory1] - suffixesOrder[pluralCategory2]).map((pluralCategory)=>`${this.options.prepend}${options.ordinal ? `ordinal${this.options.prepend}` : \"\"}${pluralCategory}`);\n        }\n        return rule.numbers.map((number)=>this.getSuffix(code, number, options));\n    }\n    getSuffix(code, count) {\n        let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        const rule = this.getRule(code, options);\n        if (rule) {\n            if (this.shouldUseIntlApi()) {\n                return `${this.options.prepend}${options.ordinal ? `ordinal${this.options.prepend}` : \"\"}${rule.select(count)}`;\n            }\n            return this.getSuffixRetroCompatible(rule, count);\n        }\n        this.logger.warn(`no plural rule found for: ${code}`);\n        return \"\";\n    }\n    getSuffixRetroCompatible(rule, count) {\n        const idx = rule.noAbs ? rule.plurals(count) : rule.plurals(Math.abs(count));\n        let suffix = rule.numbers[idx];\n        if (this.options.simplifyPluralSuffix && rule.numbers.length === 2 && rule.numbers[0] === 1) {\n            if (suffix === 2) {\n                suffix = \"plural\";\n            } else if (suffix === 1) {\n                suffix = \"\";\n            }\n        }\n        const returnSuffix = ()=>this.options.prepend && suffix.toString() ? this.options.prepend + suffix.toString() : suffix.toString();\n        if (this.options.compatibilityJSON === \"v1\") {\n            if (suffix === 1) return \"\";\n            if (typeof suffix === \"number\") return `_plural_${suffix.toString()}`;\n            return returnSuffix();\n        } else if (this.options.compatibilityJSON === \"v2\") {\n            return returnSuffix();\n        } else if (this.options.simplifyPluralSuffix && rule.numbers.length === 2 && rule.numbers[0] === 1) {\n            return returnSuffix();\n        }\n        return this.options.prepend && idx.toString() ? this.options.prepend + idx.toString() : idx.toString();\n    }\n    shouldUseIntlApi() {\n        return !nonIntlVersions.includes(this.options.compatibilityJSON);\n    }\n}\nfunction deepFindWithDefaults(data, defaultData, key) {\n    let keySeparator = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : \".\";\n    let ignoreJSONStructure = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;\n    let path = getPathWithDefaults(data, defaultData, key);\n    if (!path && ignoreJSONStructure && typeof key === \"string\") {\n        path = deepFind(data, key, keySeparator);\n        if (path === undefined) path = deepFind(defaultData, key, keySeparator);\n    }\n    return path;\n}\nclass Interpolator {\n    constructor(){\n        let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        this.logger = baseLogger.create(\"interpolator\");\n        this.options = options;\n        this.format = options.interpolation && options.interpolation.format || ((value)=>value);\n        this.init(options);\n    }\n    init() {\n        let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        if (!options.interpolation) options.interpolation = {\n            escapeValue: true\n        };\n        const { escape: escape$1, escapeValue, useRawValueToEscape, prefix, prefixEscaped, suffix, suffixEscaped, formatSeparator, unescapeSuffix, unescapePrefix, nestingPrefix, nestingPrefixEscaped, nestingSuffix, nestingSuffixEscaped, nestingOptionsSeparator, maxReplaces, alwaysFormat } = options.interpolation;\n        this.escape = escape$1 !== undefined ? escape$1 : escape;\n        this.escapeValue = escapeValue !== undefined ? escapeValue : true;\n        this.useRawValueToEscape = useRawValueToEscape !== undefined ? useRawValueToEscape : false;\n        this.prefix = prefix ? regexEscape(prefix) : prefixEscaped || \"{{\";\n        this.suffix = suffix ? regexEscape(suffix) : suffixEscaped || \"}}\";\n        this.formatSeparator = formatSeparator || \",\";\n        this.unescapePrefix = unescapeSuffix ? \"\" : unescapePrefix || \"-\";\n        this.unescapeSuffix = this.unescapePrefix ? \"\" : unescapeSuffix || \"\";\n        this.nestingPrefix = nestingPrefix ? regexEscape(nestingPrefix) : nestingPrefixEscaped || regexEscape(\"$t(\");\n        this.nestingSuffix = nestingSuffix ? regexEscape(nestingSuffix) : nestingSuffixEscaped || regexEscape(\")\");\n        this.nestingOptionsSeparator = nestingOptionsSeparator || \",\";\n        this.maxReplaces = maxReplaces || 1000;\n        this.alwaysFormat = alwaysFormat !== undefined ? alwaysFormat : false;\n        this.resetRegExp();\n    }\n    reset() {\n        if (this.options) this.init(this.options);\n    }\n    resetRegExp() {\n        const getOrResetRegExp = (existingRegExp, pattern)=>{\n            if (existingRegExp && existingRegExp.source === pattern) {\n                existingRegExp.lastIndex = 0;\n                return existingRegExp;\n            }\n            return new RegExp(pattern, \"g\");\n        };\n        this.regexp = getOrResetRegExp(this.regexp, `${this.prefix}(.+?)${this.suffix}`);\n        this.regexpUnescape = getOrResetRegExp(this.regexpUnescape, `${this.prefix}${this.unescapePrefix}(.+?)${this.unescapeSuffix}${this.suffix}`);\n        this.nestingRegexp = getOrResetRegExp(this.nestingRegexp, `${this.nestingPrefix}(.+?)${this.nestingSuffix}`);\n    }\n    interpolate(str, data, lng, options) {\n        let match;\n        let value;\n        let replaces;\n        const defaultData = this.options && this.options.interpolation && this.options.interpolation.defaultVariables || {};\n        function regexSafe(val) {\n            return val.replace(/\\$/g, \"$$$$\");\n        }\n        const handleFormat = (key)=>{\n            if (key.indexOf(this.formatSeparator) < 0) {\n                const path = deepFindWithDefaults(data, defaultData, key, this.options.keySeparator, this.options.ignoreJSONStructure);\n                return this.alwaysFormat ? this.format(path, undefined, lng, {\n                    ...options,\n                    ...data,\n                    interpolationkey: key\n                }) : path;\n            }\n            const p = key.split(this.formatSeparator);\n            const k = p.shift().trim();\n            const f = p.join(this.formatSeparator).trim();\n            return this.format(deepFindWithDefaults(data, defaultData, k, this.options.keySeparator, this.options.ignoreJSONStructure), f, lng, {\n                ...options,\n                ...data,\n                interpolationkey: k\n            });\n        };\n        this.resetRegExp();\n        const missingInterpolationHandler = options && options.missingInterpolationHandler || this.options.missingInterpolationHandler;\n        const skipOnVariables = options && options.interpolation && options.interpolation.skipOnVariables !== undefined ? options.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables;\n        const todos = [\n            {\n                regex: this.regexpUnescape,\n                safeValue: (val)=>regexSafe(val)\n            },\n            {\n                regex: this.regexp,\n                safeValue: (val)=>this.escapeValue ? regexSafe(this.escape(val)) : regexSafe(val)\n            }\n        ];\n        todos.forEach((todo)=>{\n            replaces = 0;\n            while(match = todo.regex.exec(str)){\n                const matchedVar = match[1].trim();\n                value = handleFormat(matchedVar);\n                if (value === undefined) {\n                    if (typeof missingInterpolationHandler === \"function\") {\n                        const temp = missingInterpolationHandler(str, match, options);\n                        value = typeof temp === \"string\" ? temp : \"\";\n                    } else if (options && Object.prototype.hasOwnProperty.call(options, matchedVar)) {\n                        value = \"\";\n                    } else if (skipOnVariables) {\n                        value = match[0];\n                        continue;\n                    } else {\n                        this.logger.warn(`missed to pass in variable ${matchedVar} for interpolating ${str}`);\n                        value = \"\";\n                    }\n                } else if (typeof value !== \"string\" && !this.useRawValueToEscape) {\n                    value = makeString(value);\n                }\n                const safeValue = todo.safeValue(value);\n                str = str.replace(match[0], safeValue);\n                if (skipOnVariables) {\n                    todo.regex.lastIndex += value.length;\n                    todo.regex.lastIndex -= match[0].length;\n                } else {\n                    todo.regex.lastIndex = 0;\n                }\n                replaces++;\n                if (replaces >= this.maxReplaces) {\n                    break;\n                }\n            }\n        });\n        return str;\n    }\n    nest(str, fc) {\n        let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        let match;\n        let value;\n        let clonedOptions;\n        function handleHasOptions(key, inheritedOptions) {\n            const sep = this.nestingOptionsSeparator;\n            if (key.indexOf(sep) < 0) return key;\n            const c = key.split(new RegExp(`${sep}[ ]*{`));\n            let optionsString = `{${c[1]}`;\n            key = c[0];\n            optionsString = this.interpolate(optionsString, clonedOptions);\n            const matchedSingleQuotes = optionsString.match(/'/g);\n            const matchedDoubleQuotes = optionsString.match(/\"/g);\n            if (matchedSingleQuotes && matchedSingleQuotes.length % 2 === 0 && !matchedDoubleQuotes || matchedDoubleQuotes.length % 2 !== 0) {\n                optionsString = optionsString.replace(/'/g, '\"');\n            }\n            try {\n                clonedOptions = JSON.parse(optionsString);\n                if (inheritedOptions) clonedOptions = {\n                    ...inheritedOptions,\n                    ...clonedOptions\n                };\n            } catch (e) {\n                this.logger.warn(`failed parsing options string in nesting for key ${key}`, e);\n                return `${key}${sep}${optionsString}`;\n            }\n            if (clonedOptions.defaultValue && clonedOptions.defaultValue.indexOf(this.prefix) > -1) delete clonedOptions.defaultValue;\n            return key;\n        }\n        while(match = this.nestingRegexp.exec(str)){\n            let formatters = [];\n            clonedOptions = {\n                ...options\n            };\n            clonedOptions = clonedOptions.replace && typeof clonedOptions.replace !== \"string\" ? clonedOptions.replace : clonedOptions;\n            clonedOptions.applyPostProcessor = false;\n            delete clonedOptions.defaultValue;\n            let doReduce = false;\n            if (match[0].indexOf(this.formatSeparator) !== -1 && !/{.*}/.test(match[1])) {\n                const r = match[1].split(this.formatSeparator).map((elem)=>elem.trim());\n                match[1] = r.shift();\n                formatters = r;\n                doReduce = true;\n            }\n            value = fc(handleHasOptions.call(this, match[1].trim(), clonedOptions), clonedOptions);\n            if (value && match[0] === str && typeof value !== \"string\") return value;\n            if (typeof value !== \"string\") value = makeString(value);\n            if (!value) {\n                this.logger.warn(`missed to resolve ${match[1]} for nesting ${str}`);\n                value = \"\";\n            }\n            if (doReduce) {\n                value = formatters.reduce((v, f)=>this.format(v, f, options.lng, {\n                        ...options,\n                        interpolationkey: match[1].trim()\n                    }), value.trim());\n            }\n            str = str.replace(match[0], value);\n            this.regexp.lastIndex = 0;\n        }\n        return str;\n    }\n}\nfunction parseFormatStr(formatStr) {\n    let formatName = formatStr.toLowerCase().trim();\n    const formatOptions = {};\n    if (formatStr.indexOf(\"(\") > -1) {\n        const p = formatStr.split(\"(\");\n        formatName = p[0].toLowerCase().trim();\n        const optStr = p[1].substring(0, p[1].length - 1);\n        if (formatName === \"currency\" && optStr.indexOf(\":\") < 0) {\n            if (!formatOptions.currency) formatOptions.currency = optStr.trim();\n        } else if (formatName === \"relativetime\" && optStr.indexOf(\":\") < 0) {\n            if (!formatOptions.range) formatOptions.range = optStr.trim();\n        } else {\n            const opts = optStr.split(\";\");\n            opts.forEach((opt)=>{\n                if (opt) {\n                    const [key, ...rest] = opt.split(\":\");\n                    const val = rest.join(\":\").trim().replace(/^'+|'+$/g, \"\");\n                    const trimmedKey = key.trim();\n                    if (!formatOptions[trimmedKey]) formatOptions[trimmedKey] = val;\n                    if (val === \"false\") formatOptions[trimmedKey] = false;\n                    if (val === \"true\") formatOptions[trimmedKey] = true;\n                    if (!isNaN(val)) formatOptions[trimmedKey] = parseInt(val, 10);\n                }\n            });\n        }\n    }\n    return {\n        formatName,\n        formatOptions\n    };\n}\nfunction createCachedFormatter(fn) {\n    const cache = {};\n    return function invokeFormatter(val, lng, options) {\n        const key = lng + JSON.stringify(options);\n        let formatter = cache[key];\n        if (!formatter) {\n            formatter = fn(getCleanedCode(lng), options);\n            cache[key] = formatter;\n        }\n        return formatter(val);\n    };\n}\nclass Formatter {\n    constructor(){\n        let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        this.logger = baseLogger.create(\"formatter\");\n        this.options = options;\n        this.formats = {\n            number: createCachedFormatter((lng, opt)=>{\n                const formatter = new Intl.NumberFormat(lng, {\n                    ...opt\n                });\n                return (val)=>formatter.format(val);\n            }),\n            currency: createCachedFormatter((lng, opt)=>{\n                const formatter = new Intl.NumberFormat(lng, {\n                    ...opt,\n                    style: \"currency\"\n                });\n                return (val)=>formatter.format(val);\n            }),\n            datetime: createCachedFormatter((lng, opt)=>{\n                const formatter = new Intl.DateTimeFormat(lng, {\n                    ...opt\n                });\n                return (val)=>formatter.format(val);\n            }),\n            relativetime: createCachedFormatter((lng, opt)=>{\n                const formatter = new Intl.RelativeTimeFormat(lng, {\n                    ...opt\n                });\n                return (val)=>formatter.format(val, opt.range || \"day\");\n            }),\n            list: createCachedFormatter((lng, opt)=>{\n                const formatter = new Intl.ListFormat(lng, {\n                    ...opt\n                });\n                return (val)=>formatter.format(val);\n            })\n        };\n        this.init(options);\n    }\n    init(services) {\n        let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n            interpolation: {}\n        };\n        const iOpts = options.interpolation;\n        this.formatSeparator = iOpts.formatSeparator ? iOpts.formatSeparator : iOpts.formatSeparator || \",\";\n    }\n    add(name, fc) {\n        this.formats[name.toLowerCase().trim()] = fc;\n    }\n    addCached(name, fc) {\n        this.formats[name.toLowerCase().trim()] = createCachedFormatter(fc);\n    }\n    format(value, format, lng) {\n        let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n        const formats = format.split(this.formatSeparator);\n        const result = formats.reduce((mem, f)=>{\n            const { formatName, formatOptions } = parseFormatStr(f);\n            if (this.formats[formatName]) {\n                let formatted = mem;\n                try {\n                    const valOptions = options && options.formatParams && options.formatParams[options.interpolationkey] || {};\n                    const l = valOptions.locale || valOptions.lng || options.locale || options.lng || lng;\n                    formatted = this.formats[formatName](mem, l, {\n                        ...formatOptions,\n                        ...options,\n                        ...valOptions\n                    });\n                } catch (error) {\n                    this.logger.warn(error);\n                }\n                return formatted;\n            } else {\n                this.logger.warn(`there was no format function for ${formatName}`);\n            }\n            return mem;\n        }, value);\n        return result;\n    }\n}\nfunction removePending(q, name) {\n    if (q.pending[name] !== undefined) {\n        delete q.pending[name];\n        q.pendingCount--;\n    }\n}\nclass Connector extends EventEmitter {\n    constructor(backend, store, services){\n        let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n        super();\n        this.backend = backend;\n        this.store = store;\n        this.services = services;\n        this.languageUtils = services.languageUtils;\n        this.options = options;\n        this.logger = baseLogger.create(\"backendConnector\");\n        this.waitingReads = [];\n        this.maxParallelReads = options.maxParallelReads || 10;\n        this.readingCalls = 0;\n        this.maxRetries = options.maxRetries >= 0 ? options.maxRetries : 5;\n        this.retryTimeout = options.retryTimeout >= 1 ? options.retryTimeout : 350;\n        this.state = {};\n        this.queue = [];\n        if (this.backend && this.backend.init) {\n            this.backend.init(services, options.backend, options);\n        }\n    }\n    queueLoad(languages, namespaces, options, callback) {\n        const toLoad = {};\n        const pending = {};\n        const toLoadLanguages = {};\n        const toLoadNamespaces = {};\n        languages.forEach((lng)=>{\n            let hasAllNamespaces = true;\n            namespaces.forEach((ns)=>{\n                const name = `${lng}|${ns}`;\n                if (!options.reload && this.store.hasResourceBundle(lng, ns)) {\n                    this.state[name] = 2;\n                } else if (this.state[name] < 0) ;\n                else if (this.state[name] === 1) {\n                    if (pending[name] === undefined) pending[name] = true;\n                } else {\n                    this.state[name] = 1;\n                    hasAllNamespaces = false;\n                    if (pending[name] === undefined) pending[name] = true;\n                    if (toLoad[name] === undefined) toLoad[name] = true;\n                    if (toLoadNamespaces[ns] === undefined) toLoadNamespaces[ns] = true;\n                }\n            });\n            if (!hasAllNamespaces) toLoadLanguages[lng] = true;\n        });\n        if (Object.keys(toLoad).length || Object.keys(pending).length) {\n            this.queue.push({\n                pending,\n                pendingCount: Object.keys(pending).length,\n                loaded: {},\n                errors: [],\n                callback\n            });\n        }\n        return {\n            toLoad: Object.keys(toLoad),\n            pending: Object.keys(pending),\n            toLoadLanguages: Object.keys(toLoadLanguages),\n            toLoadNamespaces: Object.keys(toLoadNamespaces)\n        };\n    }\n    loaded(name, err, data) {\n        const s = name.split(\"|\");\n        const lng = s[0];\n        const ns = s[1];\n        if (err) this.emit(\"failedLoading\", lng, ns, err);\n        if (data) {\n            this.store.addResourceBundle(lng, ns, data, undefined, undefined, {\n                skipCopy: true\n            });\n        }\n        this.state[name] = err ? -1 : 2;\n        const loaded = {};\n        this.queue.forEach((q)=>{\n            pushPath(q.loaded, [\n                lng\n            ], ns);\n            removePending(q, name);\n            if (err) q.errors.push(err);\n            if (q.pendingCount === 0 && !q.done) {\n                Object.keys(q.loaded).forEach((l)=>{\n                    if (!loaded[l]) loaded[l] = {};\n                    const loadedKeys = q.loaded[l];\n                    if (loadedKeys.length) {\n                        loadedKeys.forEach((n)=>{\n                            if (loaded[l][n] === undefined) loaded[l][n] = true;\n                        });\n                    }\n                });\n                q.done = true;\n                if (q.errors.length) {\n                    q.callback(q.errors);\n                } else {\n                    q.callback();\n                }\n            }\n        });\n        this.emit(\"loaded\", loaded);\n        this.queue = this.queue.filter((q)=>!q.done);\n    }\n    read(lng, ns, fcName) {\n        let tried = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n        let wait = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : this.retryTimeout;\n        let callback = arguments.length > 5 ? arguments[5] : undefined;\n        if (!lng.length) return callback(null, {});\n        if (this.readingCalls >= this.maxParallelReads) {\n            this.waitingReads.push({\n                lng,\n                ns,\n                fcName,\n                tried,\n                wait,\n                callback\n            });\n            return;\n        }\n        this.readingCalls++;\n        const resolver = (err, data)=>{\n            this.readingCalls--;\n            if (this.waitingReads.length > 0) {\n                const next = this.waitingReads.shift();\n                this.read(next.lng, next.ns, next.fcName, next.tried, next.wait, next.callback);\n            }\n            if (err && data && tried < this.maxRetries) {\n                setTimeout(()=>{\n                    this.read.call(this, lng, ns, fcName, tried + 1, wait * 2, callback);\n                }, wait);\n                return;\n            }\n            callback(err, data);\n        };\n        const fc = this.backend[fcName].bind(this.backend);\n        if (fc.length === 2) {\n            try {\n                const r = fc(lng, ns);\n                if (r && typeof r.then === \"function\") {\n                    r.then((data)=>resolver(null, data)).catch(resolver);\n                } else {\n                    resolver(null, r);\n                }\n            } catch (err) {\n                resolver(err);\n            }\n            return;\n        }\n        return fc(lng, ns, resolver);\n    }\n    prepareLoading(languages, namespaces) {\n        let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        let callback = arguments.length > 3 ? arguments[3] : undefined;\n        if (!this.backend) {\n            this.logger.warn(\"No backend was added via i18next.use. Will not load resources.\");\n            return callback && callback();\n        }\n        if (typeof languages === \"string\") languages = this.languageUtils.toResolveHierarchy(languages);\n        if (typeof namespaces === \"string\") namespaces = [\n            namespaces\n        ];\n        const toLoad = this.queueLoad(languages, namespaces, options, callback);\n        if (!toLoad.toLoad.length) {\n            if (!toLoad.pending.length) callback();\n            return null;\n        }\n        toLoad.toLoad.forEach((name)=>{\n            this.loadOne(name);\n        });\n    }\n    load(languages, namespaces, callback) {\n        this.prepareLoading(languages, namespaces, {}, callback);\n    }\n    reload(languages, namespaces, callback) {\n        this.prepareLoading(languages, namespaces, {\n            reload: true\n        }, callback);\n    }\n    loadOne(name) {\n        let prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n        const s = name.split(\"|\");\n        const lng = s[0];\n        const ns = s[1];\n        this.read(lng, ns, \"read\", undefined, undefined, (err, data)=>{\n            if (err) this.logger.warn(`${prefix}loading namespace ${ns} for language ${lng} failed`, err);\n            if (!err && data) this.logger.log(`${prefix}loaded namespace ${ns} for language ${lng}`, data);\n            this.loaded(name, err, data);\n        });\n    }\n    saveMissing(languages, namespace, key, fallbackValue, isUpdate) {\n        let options = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {};\n        let clb = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : ()=>{};\n        if (this.services.utils && this.services.utils.hasLoadedNamespace && !this.services.utils.hasLoadedNamespace(namespace)) {\n            this.logger.warn(`did not save key \"${key}\" as the namespace \"${namespace}\" was not yet loaded`, \"This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!\");\n            return;\n        }\n        if (key === undefined || key === null || key === \"\") return;\n        if (this.backend && this.backend.create) {\n            const opts = {\n                ...options,\n                isUpdate\n            };\n            const fc = this.backend.create.bind(this.backend);\n            if (fc.length < 6) {\n                try {\n                    let r;\n                    if (fc.length === 5) {\n                        r = fc(languages, namespace, key, fallbackValue, opts);\n                    } else {\n                        r = fc(languages, namespace, key, fallbackValue);\n                    }\n                    if (r && typeof r.then === \"function\") {\n                        r.then((data)=>clb(null, data)).catch(clb);\n                    } else {\n                        clb(null, r);\n                    }\n                } catch (err) {\n                    clb(err);\n                }\n            } else {\n                fc(languages, namespace, key, fallbackValue, clb, opts);\n            }\n        }\n        if (!languages || !languages[0]) return;\n        this.store.addResource(languages[0], namespace, key, fallbackValue);\n    }\n}\nfunction get() {\n    return {\n        debug: false,\n        initImmediate: true,\n        ns: [\n            \"translation\"\n        ],\n        defaultNS: [\n            \"translation\"\n        ],\n        fallbackLng: [\n            \"dev\"\n        ],\n        fallbackNS: false,\n        supportedLngs: false,\n        nonExplicitSupportedLngs: false,\n        load: \"all\",\n        preload: false,\n        simplifyPluralSuffix: true,\n        keySeparator: \".\",\n        nsSeparator: \":\",\n        pluralSeparator: \"_\",\n        contextSeparator: \"_\",\n        partialBundledLanguages: false,\n        saveMissing: false,\n        updateMissing: false,\n        saveMissingTo: \"fallback\",\n        saveMissingPlurals: true,\n        missingKeyHandler: false,\n        missingInterpolationHandler: false,\n        postProcess: false,\n        postProcessPassResolved: false,\n        returnNull: false,\n        returnEmptyString: true,\n        returnObjects: false,\n        joinArrays: false,\n        returnedObjectHandler: false,\n        parseMissingKeyHandler: false,\n        appendNamespaceToMissingKey: false,\n        appendNamespaceToCIMode: false,\n        overloadTranslationOptionHandler: function handle(args) {\n            let ret = {};\n            if (typeof args[1] === \"object\") ret = args[1];\n            if (typeof args[1] === \"string\") ret.defaultValue = args[1];\n            if (typeof args[2] === \"string\") ret.tDescription = args[2];\n            if (typeof args[2] === \"object\" || typeof args[3] === \"object\") {\n                const options = args[3] || args[2];\n                Object.keys(options).forEach((key)=>{\n                    ret[key] = options[key];\n                });\n            }\n            return ret;\n        },\n        interpolation: {\n            escapeValue: true,\n            format: (value)=>value,\n            prefix: \"{{\",\n            suffix: \"}}\",\n            formatSeparator: \",\",\n            unescapePrefix: \"-\",\n            nestingPrefix: \"$t(\",\n            nestingSuffix: \")\",\n            nestingOptionsSeparator: \",\",\n            maxReplaces: 1000,\n            skipOnVariables: true\n        }\n    };\n}\nfunction transformOptions(options) {\n    if (typeof options.ns === \"string\") options.ns = [\n        options.ns\n    ];\n    if (typeof options.fallbackLng === \"string\") options.fallbackLng = [\n        options.fallbackLng\n    ];\n    if (typeof options.fallbackNS === \"string\") options.fallbackNS = [\n        options.fallbackNS\n    ];\n    if (options.supportedLngs && options.supportedLngs.indexOf(\"cimode\") < 0) {\n        options.supportedLngs = options.supportedLngs.concat([\n            \"cimode\"\n        ]);\n    }\n    return options;\n}\nfunction noop() {}\nfunction bindMemberFunctions(inst) {\n    const mems = Object.getOwnPropertyNames(Object.getPrototypeOf(inst));\n    mems.forEach((mem)=>{\n        if (typeof inst[mem] === \"function\") {\n            inst[mem] = inst[mem].bind(inst);\n        }\n    });\n}\nclass I18n extends EventEmitter {\n    constructor(){\n        let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        let callback = arguments.length > 1 ? arguments[1] : undefined;\n        super();\n        this.options = transformOptions(options);\n        this.services = {};\n        this.logger = baseLogger;\n        this.modules = {\n            external: []\n        };\n        bindMemberFunctions(this);\n        if (callback && !this.isInitialized && !options.isClone) {\n            if (!this.options.initImmediate) {\n                this.init(options, callback);\n                return this;\n            }\n            setTimeout(()=>{\n                this.init(options, callback);\n            }, 0);\n        }\n    }\n    init() {\n        var _this = this;\n        let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        let callback = arguments.length > 1 ? arguments[1] : undefined;\n        this.isInitializing = true;\n        if (typeof options === \"function\") {\n            callback = options;\n            options = {};\n        }\n        if (!options.defaultNS && options.defaultNS !== false && options.ns) {\n            if (typeof options.ns === \"string\") {\n                options.defaultNS = options.ns;\n            } else if (options.ns.indexOf(\"translation\") < 0) {\n                options.defaultNS = options.ns[0];\n            }\n        }\n        const defOpts = get();\n        this.options = {\n            ...defOpts,\n            ...this.options,\n            ...transformOptions(options)\n        };\n        if (this.options.compatibilityAPI !== \"v1\") {\n            this.options.interpolation = {\n                ...defOpts.interpolation,\n                ...this.options.interpolation\n            };\n        }\n        if (options.keySeparator !== undefined) {\n            this.options.userDefinedKeySeparator = options.keySeparator;\n        }\n        if (options.nsSeparator !== undefined) {\n            this.options.userDefinedNsSeparator = options.nsSeparator;\n        }\n        function createClassOnDemand(ClassOrObject) {\n            if (!ClassOrObject) return null;\n            if (typeof ClassOrObject === \"function\") return new ClassOrObject();\n            return ClassOrObject;\n        }\n        if (!this.options.isClone) {\n            if (this.modules.logger) {\n                baseLogger.init(createClassOnDemand(this.modules.logger), this.options);\n            } else {\n                baseLogger.init(null, this.options);\n            }\n            let formatter;\n            if (this.modules.formatter) {\n                formatter = this.modules.formatter;\n            } else if (typeof Intl !== \"undefined\") {\n                formatter = Formatter;\n            }\n            const lu = new LanguageUtil(this.options);\n            this.store = new ResourceStore(this.options.resources, this.options);\n            const s = this.services;\n            s.logger = baseLogger;\n            s.resourceStore = this.store;\n            s.languageUtils = lu;\n            s.pluralResolver = new PluralResolver(lu, {\n                prepend: this.options.pluralSeparator,\n                compatibilityJSON: this.options.compatibilityJSON,\n                simplifyPluralSuffix: this.options.simplifyPluralSuffix\n            });\n            if (formatter && (!this.options.interpolation.format || this.options.interpolation.format === defOpts.interpolation.format)) {\n                s.formatter = createClassOnDemand(formatter);\n                s.formatter.init(s, this.options);\n                this.options.interpolation.format = s.formatter.format.bind(s.formatter);\n            }\n            s.interpolator = new Interpolator(this.options);\n            s.utils = {\n                hasLoadedNamespace: this.hasLoadedNamespace.bind(this)\n            };\n            s.backendConnector = new Connector(createClassOnDemand(this.modules.backend), s.resourceStore, s, this.options);\n            s.backendConnector.on(\"*\", function(event) {\n                for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n                    args[_key - 1] = arguments[_key];\n                }\n                _this.emit(event, ...args);\n            });\n            if (this.modules.languageDetector) {\n                s.languageDetector = createClassOnDemand(this.modules.languageDetector);\n                if (s.languageDetector.init) s.languageDetector.init(s, this.options.detection, this.options);\n            }\n            if (this.modules.i18nFormat) {\n                s.i18nFormat = createClassOnDemand(this.modules.i18nFormat);\n                if (s.i18nFormat.init) s.i18nFormat.init(this);\n            }\n            this.translator = new Translator(this.services, this.options);\n            this.translator.on(\"*\", function(event) {\n                for(var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++){\n                    args[_key2 - 1] = arguments[_key2];\n                }\n                _this.emit(event, ...args);\n            });\n            this.modules.external.forEach((m)=>{\n                if (m.init) m.init(this);\n            });\n        }\n        this.format = this.options.interpolation.format;\n        if (!callback) callback = noop;\n        if (this.options.fallbackLng && !this.services.languageDetector && !this.options.lng) {\n            const codes = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);\n            if (codes.length > 0 && codes[0] !== \"dev\") this.options.lng = codes[0];\n        }\n        if (!this.services.languageDetector && !this.options.lng) {\n            this.logger.warn(\"init: no languageDetector is used and no lng is defined\");\n        }\n        const storeApi = [\n            \"getResource\",\n            \"hasResourceBundle\",\n            \"getResourceBundle\",\n            \"getDataByLanguage\"\n        ];\n        storeApi.forEach((fcName)=>{\n            this[fcName] = function() {\n                return _this.store[fcName](...arguments);\n            };\n        });\n        const storeApiChained = [\n            \"addResource\",\n            \"addResources\",\n            \"addResourceBundle\",\n            \"removeResourceBundle\"\n        ];\n        storeApiChained.forEach((fcName)=>{\n            this[fcName] = function() {\n                _this.store[fcName](...arguments);\n                return _this;\n            };\n        });\n        const deferred = defer();\n        const load = ()=>{\n            const finish = (err, t)=>{\n                this.isInitializing = false;\n                if (this.isInitialized && !this.initializedStoreOnce) this.logger.warn(\"init: i18next is already initialized. You should call init just once!\");\n                this.isInitialized = true;\n                if (!this.options.isClone) this.logger.log(\"initialized\", this.options);\n                this.emit(\"initialized\", this.options);\n                deferred.resolve(t);\n                callback(err, t);\n            };\n            if (this.languages && this.options.compatibilityAPI !== \"v1\" && !this.isInitialized) return finish(null, this.t.bind(this));\n            this.changeLanguage(this.options.lng, finish);\n        };\n        if (this.options.resources || !this.options.initImmediate) {\n            load();\n        } else {\n            setTimeout(load, 0);\n        }\n        return deferred;\n    }\n    loadResources(language) {\n        let callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop;\n        let usedCallback = callback;\n        const usedLng = typeof language === \"string\" ? language : this.language;\n        if (typeof language === \"function\") usedCallback = language;\n        if (!this.options.resources || this.options.partialBundledLanguages) {\n            if (usedLng && usedLng.toLowerCase() === \"cimode\" && (!this.options.preload || this.options.preload.length === 0)) return usedCallback();\n            const toLoad = [];\n            const append = (lng)=>{\n                if (!lng) return;\n                if (lng === \"cimode\") return;\n                const lngs = this.services.languageUtils.toResolveHierarchy(lng);\n                lngs.forEach((l)=>{\n                    if (l === \"cimode\") return;\n                    if (toLoad.indexOf(l) < 0) toLoad.push(l);\n                });\n            };\n            if (!usedLng) {\n                const fallbacks = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);\n                fallbacks.forEach((l)=>append(l));\n            } else {\n                append(usedLng);\n            }\n            if (this.options.preload) {\n                this.options.preload.forEach((l)=>append(l));\n            }\n            this.services.backendConnector.load(toLoad, this.options.ns, (e)=>{\n                if (!e && !this.resolvedLanguage && this.language) this.setResolvedLanguage(this.language);\n                usedCallback(e);\n            });\n        } else {\n            usedCallback(null);\n        }\n    }\n    reloadResources(lngs, ns, callback) {\n        const deferred = defer();\n        if (!lngs) lngs = this.languages;\n        if (!ns) ns = this.options.ns;\n        if (!callback) callback = noop;\n        this.services.backendConnector.reload(lngs, ns, (err)=>{\n            deferred.resolve();\n            callback(err);\n        });\n        return deferred;\n    }\n    use(module) {\n        if (!module) throw new Error(\"You are passing an undefined module! Please check the object you are passing to i18next.use()\");\n        if (!module.type) throw new Error(\"You are passing a wrong module! Please check the object you are passing to i18next.use()\");\n        if (module.type === \"backend\") {\n            this.modules.backend = module;\n        }\n        if (module.type === \"logger\" || module.log && module.warn && module.error) {\n            this.modules.logger = module;\n        }\n        if (module.type === \"languageDetector\") {\n            this.modules.languageDetector = module;\n        }\n        if (module.type === \"i18nFormat\") {\n            this.modules.i18nFormat = module;\n        }\n        if (module.type === \"postProcessor\") {\n            postProcessor.addPostProcessor(module);\n        }\n        if (module.type === \"formatter\") {\n            this.modules.formatter = module;\n        }\n        if (module.type === \"3rdParty\") {\n            this.modules.external.push(module);\n        }\n        return this;\n    }\n    setResolvedLanguage(l) {\n        if (!l || !this.languages) return;\n        if ([\n            \"cimode\",\n            \"dev\"\n        ].indexOf(l) > -1) return;\n        for(let li = 0; li < this.languages.length; li++){\n            const lngInLngs = this.languages[li];\n            if ([\n                \"cimode\",\n                \"dev\"\n            ].indexOf(lngInLngs) > -1) continue;\n            if (this.store.hasLanguageSomeTranslations(lngInLngs)) {\n                this.resolvedLanguage = lngInLngs;\n                break;\n            }\n        }\n    }\n    changeLanguage(lng, callback) {\n        var _this2 = this;\n        this.isLanguageChangingTo = lng;\n        const deferred = defer();\n        this.emit(\"languageChanging\", lng);\n        const setLngProps = (l)=>{\n            this.language = l;\n            this.languages = this.services.languageUtils.toResolveHierarchy(l);\n            this.resolvedLanguage = undefined;\n            this.setResolvedLanguage(l);\n        };\n        const done = (err, l)=>{\n            if (l) {\n                setLngProps(l);\n                this.translator.changeLanguage(l);\n                this.isLanguageChangingTo = undefined;\n                this.emit(\"languageChanged\", l);\n                this.logger.log(\"languageChanged\", l);\n            } else {\n                this.isLanguageChangingTo = undefined;\n            }\n            deferred.resolve(function() {\n                return _this2.t(...arguments);\n            });\n            if (callback) callback(err, function() {\n                return _this2.t(...arguments);\n            });\n        };\n        const setLng = (lngs)=>{\n            if (!lng && !lngs && this.services.languageDetector) lngs = [];\n            const l = typeof lngs === \"string\" ? lngs : this.services.languageUtils.getBestMatchFromCodes(lngs);\n            if (l) {\n                if (!this.language) {\n                    setLngProps(l);\n                }\n                if (!this.translator.language) this.translator.changeLanguage(l);\n                if (this.services.languageDetector && this.services.languageDetector.cacheUserLanguage) this.services.languageDetector.cacheUserLanguage(l);\n            }\n            this.loadResources(l, (err)=>{\n                done(err, l);\n            });\n        };\n        if (!lng && this.services.languageDetector && !this.services.languageDetector.async) {\n            setLng(this.services.languageDetector.detect());\n        } else if (!lng && this.services.languageDetector && this.services.languageDetector.async) {\n            if (this.services.languageDetector.detect.length === 0) {\n                this.services.languageDetector.detect().then(setLng);\n            } else {\n                this.services.languageDetector.detect(setLng);\n            }\n        } else {\n            setLng(lng);\n        }\n        return deferred;\n    }\n    getFixedT(lng, ns, keyPrefix) {\n        var _this3 = this;\n        const fixedT = function(key, opts) {\n            let options;\n            if (typeof opts !== \"object\") {\n                for(var _len3 = arguments.length, rest = new Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++){\n                    rest[_key3 - 2] = arguments[_key3];\n                }\n                options = _this3.options.overloadTranslationOptionHandler([\n                    key,\n                    opts\n                ].concat(rest));\n            } else {\n                options = {\n                    ...opts\n                };\n            }\n            options.lng = options.lng || fixedT.lng;\n            options.lngs = options.lngs || fixedT.lngs;\n            options.ns = options.ns || fixedT.ns;\n            if (options.keyPrefix !== \"\") options.keyPrefix = options.keyPrefix || keyPrefix || fixedT.keyPrefix;\n            const keySeparator = _this3.options.keySeparator || \".\";\n            let resultKey;\n            if (options.keyPrefix && Array.isArray(key)) {\n                resultKey = key.map((k)=>`${options.keyPrefix}${keySeparator}${k}`);\n            } else {\n                resultKey = options.keyPrefix ? `${options.keyPrefix}${keySeparator}${key}` : key;\n            }\n            return _this3.t(resultKey, options);\n        };\n        if (typeof lng === \"string\") {\n            fixedT.lng = lng;\n        } else {\n            fixedT.lngs = lng;\n        }\n        fixedT.ns = ns;\n        fixedT.keyPrefix = keyPrefix;\n        return fixedT;\n    }\n    t() {\n        return this.translator && this.translator.translate(...arguments);\n    }\n    exists() {\n        return this.translator && this.translator.exists(...arguments);\n    }\n    setDefaultNamespace(ns) {\n        this.options.defaultNS = ns;\n    }\n    hasLoadedNamespace(ns) {\n        let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        if (!this.isInitialized) {\n            this.logger.warn(\"hasLoadedNamespace: i18next was not initialized\", this.languages);\n            return false;\n        }\n        if (!this.languages || !this.languages.length) {\n            this.logger.warn(\"hasLoadedNamespace: i18n.languages were undefined or empty\", this.languages);\n            return false;\n        }\n        const lng = options.lng || this.resolvedLanguage || this.languages[0];\n        const fallbackLng = this.options ? this.options.fallbackLng : false;\n        const lastLng = this.languages[this.languages.length - 1];\n        if (lng.toLowerCase() === \"cimode\") return true;\n        const loadNotPending = (l, n)=>{\n            const loadState = this.services.backendConnector.state[`${l}|${n}`];\n            return loadState === -1 || loadState === 2;\n        };\n        if (options.precheck) {\n            const preResult = options.precheck(this, loadNotPending);\n            if (preResult !== undefined) return preResult;\n        }\n        if (this.hasResourceBundle(lng, ns)) return true;\n        if (!this.services.backendConnector.backend || this.options.resources && !this.options.partialBundledLanguages) return true;\n        if (loadNotPending(lng, ns) && (!fallbackLng || loadNotPending(lastLng, ns))) return true;\n        return false;\n    }\n    loadNamespaces(ns, callback) {\n        const deferred = defer();\n        if (!this.options.ns) {\n            if (callback) callback();\n            return Promise.resolve();\n        }\n        if (typeof ns === \"string\") ns = [\n            ns\n        ];\n        ns.forEach((n)=>{\n            if (this.options.ns.indexOf(n) < 0) this.options.ns.push(n);\n        });\n        this.loadResources((err)=>{\n            deferred.resolve();\n            if (callback) callback(err);\n        });\n        return deferred;\n    }\n    loadLanguages(lngs, callback) {\n        const deferred = defer();\n        if (typeof lngs === \"string\") lngs = [\n            lngs\n        ];\n        const preloaded = this.options.preload || [];\n        const newLngs = lngs.filter((lng)=>preloaded.indexOf(lng) < 0 && this.services.languageUtils.isSupportedCode(lng));\n        if (!newLngs.length) {\n            if (callback) callback();\n            return Promise.resolve();\n        }\n        this.options.preload = preloaded.concat(newLngs);\n        this.loadResources((err)=>{\n            deferred.resolve();\n            if (callback) callback(err);\n        });\n        return deferred;\n    }\n    dir(lng) {\n        if (!lng) lng = this.resolvedLanguage || (this.languages && this.languages.length > 0 ? this.languages[0] : this.language);\n        if (!lng) return \"rtl\";\n        const rtlLngs = [\n            \"ar\",\n            \"shu\",\n            \"sqr\",\n            \"ssh\",\n            \"xaa\",\n            \"yhd\",\n            \"yud\",\n            \"aao\",\n            \"abh\",\n            \"abv\",\n            \"acm\",\n            \"acq\",\n            \"acw\",\n            \"acx\",\n            \"acy\",\n            \"adf\",\n            \"ads\",\n            \"aeb\",\n            \"aec\",\n            \"afb\",\n            \"ajp\",\n            \"apc\",\n            \"apd\",\n            \"arb\",\n            \"arq\",\n            \"ars\",\n            \"ary\",\n            \"arz\",\n            \"auz\",\n            \"avl\",\n            \"ayh\",\n            \"ayl\",\n            \"ayn\",\n            \"ayp\",\n            \"bbz\",\n            \"pga\",\n            \"he\",\n            \"iw\",\n            \"ps\",\n            \"pbt\",\n            \"pbu\",\n            \"pst\",\n            \"prp\",\n            \"prd\",\n            \"ug\",\n            \"ur\",\n            \"ydd\",\n            \"yds\",\n            \"yih\",\n            \"ji\",\n            \"yi\",\n            \"hbo\",\n            \"men\",\n            \"xmn\",\n            \"fa\",\n            \"jpr\",\n            \"peo\",\n            \"pes\",\n            \"prs\",\n            \"dv\",\n            \"sam\",\n            \"ckb\"\n        ];\n        const languageUtils = this.services && this.services.languageUtils || new LanguageUtil(get());\n        return rtlLngs.indexOf(languageUtils.getLanguagePartFromCode(lng)) > -1 || lng.toLowerCase().indexOf(\"-arab\") > 1 ? \"rtl\" : \"ltr\";\n    }\n    static createInstance() {\n        let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        let callback = arguments.length > 1 ? arguments[1] : undefined;\n        return new I18n(options, callback);\n    }\n    cloneInstance() {\n        let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        let callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop;\n        const forkResourceStore = options.forkResourceStore;\n        if (forkResourceStore) delete options.forkResourceStore;\n        const mergedOptions = {\n            ...this.options,\n            ...options,\n            ...{\n                isClone: true\n            }\n        };\n        const clone = new I18n(mergedOptions);\n        if (options.debug !== undefined || options.prefix !== undefined) {\n            clone.logger = clone.logger.clone(options);\n        }\n        const membersToCopy = [\n            \"store\",\n            \"services\",\n            \"language\"\n        ];\n        membersToCopy.forEach((m)=>{\n            clone[m] = this[m];\n        });\n        clone.services = {\n            ...this.services\n        };\n        clone.services.utils = {\n            hasLoadedNamespace: clone.hasLoadedNamespace.bind(clone)\n        };\n        if (forkResourceStore) {\n            clone.store = new ResourceStore(this.store.data, mergedOptions);\n            clone.services.resourceStore = clone.store;\n        }\n        clone.translator = new Translator(clone.services, mergedOptions);\n        clone.translator.on(\"*\", function(event) {\n            for(var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++){\n                args[_key4 - 1] = arguments[_key4];\n            }\n            clone.emit(event, ...args);\n        });\n        clone.init(mergedOptions, callback);\n        clone.translator.options = mergedOptions;\n        clone.translator.backendConnector.services.utils = {\n            hasLoadedNamespace: clone.hasLoadedNamespace.bind(clone)\n        };\n        return clone;\n    }\n    toJSON() {\n        return {\n            options: this.options,\n            store: this.store,\n            language: this.language,\n            languages: this.languages,\n            resolvedLanguage: this.resolvedLanguage\n        };\n    }\n}\nconst instance = I18n.createInstance();\ninstance.createInstance = I18n.createInstance;\nconst createInstance = instance.createInstance;\nconst dir = instance.dir;\nconst init = instance.init;\nconst loadResources = instance.loadResources;\nconst reloadResources = instance.reloadResources;\nconst use = instance.use;\nconst changeLanguage = instance.changeLanguage;\nconst getFixedT = instance.getFixedT;\nconst t = instance.t;\nconst exists = instance.exists;\nconst setDefaultNamespace = instance.setDefaultNamespace;\nconst hasLoadedNamespace = instance.hasLoadedNamespace;\nconst loadNamespaces = instance.loadNamespaces;\nconst loadLanguages = instance.loadLanguages;\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvaTE4bmV4dC9kaXN0L2VzbS9pMThuZXh0LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLE1BQU1BLGdCQUFnQjtJQUNwQkMsTUFBTTtJQUNOQyxLQUFJQyxJQUFJO1FBQ04sSUFBSSxDQUFDQyxNQUFNLENBQUMsT0FBT0Q7SUFDckI7SUFDQUUsTUFBS0YsSUFBSTtRQUNQLElBQUksQ0FBQ0MsTUFBTSxDQUFDLFFBQVFEO0lBQ3RCO0lBQ0FHLE9BQU1ILElBQUk7UUFDUixJQUFJLENBQUNDLE1BQU0sQ0FBQyxTQUFTRDtJQUN2QjtJQUNBQyxRQUFPSCxJQUFJLEVBQUVFLElBQUk7UUFDZixJQUFJSSxXQUFXQSxPQUFPLENBQUNOLEtBQUssRUFBRU0sT0FBTyxDQUFDTixLQUFLLENBQUNPLEtBQUssQ0FBQ0QsU0FBU0o7SUFDN0Q7QUFDRjtBQUNBLE1BQU1NO0lBQ0pDLFlBQVlDLGNBQWMsQ0FBRTtRQUMxQixJQUFJQyxVQUFVQyxVQUFVQyxNQUFNLEdBQUcsS0FBS0QsU0FBUyxDQUFDLEVBQUUsS0FBS0UsWUFBWUYsU0FBUyxDQUFDLEVBQUUsR0FBRyxDQUFDO1FBQ25GLElBQUksQ0FBQ0csSUFBSSxDQUFDTCxnQkFBZ0JDO0lBQzVCO0lBQ0FJLEtBQUtMLGNBQWMsRUFBRTtRQUNuQixJQUFJQyxVQUFVQyxVQUFVQyxNQUFNLEdBQUcsS0FBS0QsU0FBUyxDQUFDLEVBQUUsS0FBS0UsWUFBWUYsU0FBUyxDQUFDLEVBQUUsR0FBRyxDQUFDO1FBQ25GLElBQUksQ0FBQ0ksTUFBTSxHQUFHTCxRQUFRSyxNQUFNLElBQUk7UUFDaEMsSUFBSSxDQUFDQyxNQUFNLEdBQUdQLGtCQUFrQlg7UUFDaEMsSUFBSSxDQUFDWSxPQUFPLEdBQUdBO1FBQ2YsSUFBSSxDQUFDTyxLQUFLLEdBQUdQLFFBQVFPLEtBQUs7SUFDNUI7SUFDQWpCLE1BQU07UUFDSixJQUFLLElBQUlrQixPQUFPUCxVQUFVQyxNQUFNLEVBQUVYLE9B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a0JBQWtCLElBQUksQ0FBQ0EsZ0JBQWdCO1FBQ3pDO0lBQ0Y7QUFDRjtBQUNBLE1BQU1vQyxXQUFXeEQsS0FBS21ELGNBQWM7QUFDcENLLFNBQVNMLGNBQWMsR0FBR25ELEtBQUttRCxjQUFjO0FBRTdDLE1BQU1BLGlCQUFpQkssU0FBU0wsY0FBYztBQUM5QyxNQUFNRixNQUFNTyxTQUFTUCxHQUFHO0FBQ3hCLE1BQU0zaUIsT0FBT2tqQixTQUFTbGpCLElBQUk7QUFDMUIsTUFBTTJnQixnQkFBZ0J1QyxTQUFTdkMsYUFBYTtBQUM1QyxNQUFNSyxrQkFBa0JrQyxTQUFTbEMsZUFBZTtBQUNoRCxNQUFNQyxNQUFNaUMsU0FBU2pDLEdBQUc7QUFDeEIsTUFBTS9WLGlCQUFpQmdZLFNBQVNoWSxjQUFjO0FBQzlDLE1BQU0wVyxZQUFZc0IsU0FBU3RCLFNBQVM7QUFDcEMsTUFBTXBlLElBQUkwZixTQUFTMWYsQ0FBQztBQUNwQixNQUFNNEgsU0FBUzhYLFNBQVM5WCxNQUFNO0FBQzlCLE1BQU02VyxzQkFBc0JpQixTQUFTakIsbUJBQW1CO0FBQ3hELE1BQU12USxxQkFBcUJ3UixTQUFTeFIsa0JBQWtCO0FBQ3RELE1BQU02USxpQkFBaUJXLFNBQVNYLGNBQWM7QUFDOUMsTUFBTUMsZ0JBQWdCVSxTQUFTVixhQUFhO0FBRWlLIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc2FmcmEtYXBwLy4vbm9kZV9tb2R1bGVzL2kxOG5leHQvZGlzdC9lc20vaTE4bmV4dC5qcz82OGU1Il0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IGNvbnNvbGVMb2dnZXIgPSB7XG4gIHR5cGU6ICdsb2dnZXInLFxuICBsb2coYXJncykge1xuICAgIHRoaXMub3V0cHV0KCdsb2cnLCBhcmdzKTtcbiAgfSxcbiAgd2FybihhcmdzKSB7XG4gICAgdGhpcy5vdXRwdXQoJ3dhcm4nLCBhcmdzKTtcbiAgfSxcbiAgZXJyb3IoYXJncykge1xuICAgIHRoaXMub3V0cHV0KCdlcnJvcicsIGFyZ3MpO1xuICB9LFxuICBvdXRwdXQodHlwZSwgYXJncykge1xuICAgIGlmIChjb25zb2xlICYmIGNvbnNvbGVbdHlwZV0pIGNvbnNvbGVbdHlwZV0uYXBwbHkoY29uc29sZSwgYXJncyk7XG4gIH1cbn07XG5jbGFzcyBMb2dnZXIge1xuICBjb25zdHJ1Y3Rvcihjb25jcmV0ZUxvZ2dlcikge1xuICAgIGxldCBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICB0aGlzLmluaXQoY29uY3JldGVMb2dnZXIsIG9wdGlvbnMpO1xuICB9XG4gIGluaXQoY29uY3JldGVMb2dnZXIpIHtcbiAgICBsZXQgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgdGhpcy5wcmVmaXggPSBvcHRpb25zLnByZWZpeCB8fCAnaTE4bmV4dDonO1xuICAgIHRoaXMubG9nZ2VyID0gY29uY3JldGVMb2dnZXIgfHwgY29uc29sZUxvZ2dlcjtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMuZGVidWcgPSBvcHRpb25zLmRlYnVnO1xuICB9XG4gIGxvZygpIHtcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmZvcndhcmQoYXJncywgJ2xvZycsICcnLCB0cnVlKTtcbiAgfVxuICB3YXJuKCkge1xuICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMiksIF9rZXkyID0gMDsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgYXJnc1tfa2V5Ml0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5mb3J3YXJkKGFyZ3MsICd3YXJuJywgJycsIHRydWUpO1xuICB9XG4gIGVycm9yKCkge1xuICAgIGZvciAodmFyIF9sZW4zID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMyksIF9rZXkzID0gMDsgX2tleTMgPCBfbGVuMzsgX2tleTMrKykge1xuICAgICAgYXJnc1tfa2V5M10gPSBhcmd1bWVudHNbX2tleTNdO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5mb3J3YXJkKGFyZ3MsICdlcnJvcicsICcnKTtcbiAgfVxuICBkZXByZWNhdGUoKSB7XG4gICAgZm9yICh2YXIgX2xlbjQgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW40KSwgX2tleTQgPSAwOyBfa2V5NCA8IF9sZW40OyBfa2V5NCsrKSB7XG4gICAgICBhcmdzW19rZXk0XSA9IGFyZ3VtZW50c1tfa2V5NF07XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmZvcndhcmQoYXJncywgJ3dhcm4nLCAnV0FSTklORyBERVBSRUNBVEVEOiAnLCB0cnVlKTtcbiAgfVxuICBmb3J3YXJkKGFyZ3MsIGx2bCwgcHJlZml4LCBkZWJ1Z09ubHkpIHtcbiAgICBpZiAoZGVidWdPbmx5ICYmICF0aGlzLmRlYnVnKSByZXR1cm4gbnVsbDtcbiAgICBpZiAodHlwZW9mIGFyZ3NbMF0gPT09ICdzdHJpbmcnKSBhcmdzWzBdID0gYCR7cHJlZml4fSR7dGhpcy5wcmVmaXh9ICR7YXJnc1swXX1gO1xuICAgIHJldHVybiB0aGlzLmxvZ2dlcltsdmxdKGFyZ3MpO1xuICB9XG4gIGNyZWF0ZShtb2R1bGVOYW1lKSB7XG4gICAgcmV0dXJuIG5ldyBMb2dnZXIodGhpcy5sb2dnZXIsIHtcbiAgICAgIC4uLntcbiAgICAgICAgcHJlZml4OiBgJHt0aGlzLnByZWZpeH06JHttb2R1bGVOYW1lfTpgXG4gICAgICB9LFxuICAgICAgLi4udGhpcy5vcHRpb25zXG4gICAgfSk7XG4gIH1cbiAgY2xvbmUob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHRoaXMub3B0aW9ucztcbiAgICBvcHRpb25zLnByZWZpeCA9IG9wdGlvbnMucHJlZml4IHx8IHRoaXMucHJlZml4O1xuICAgIHJldHVybiBuZXcgTG9nZ2VyKHRoaXMubG9nZ2VyLCBvcHRpb25zKTtcbiAgfVxufVxudmFyIGJhc2VMb2dnZXIgPSBuZXcgTG9nZ2VyKCk7XG5cbmNsYXNzIEV2ZW50RW1pdHRlciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMub2JzZXJ2ZXJzID0ge307XG4gIH1cbiAgb24oZXZlbnRzLCBsaXN0ZW5lcikge1xuICAgIGV2ZW50cy5zcGxpdCgnICcpLmZvckVhY2goZXZlbnQgPT4ge1xuICAgICAgaWYgKCF0aGlzLm9ic2VydmVyc1tldmVudF0pIHRoaXMub2JzZXJ2ZXJzW2V2ZW50XSA9IG5ldyBNYXAoKTtcbiAgICAgIGNvbnN0IG51bUxpc3RlbmVycyA9IHRoaXMub2JzZXJ2ZXJzW2V2ZW50XS5nZXQobGlzdGVuZXIpIHx8IDA7XG4gICAgICB0aGlzLm9ic2VydmVyc1tldmVudF0uc2V0KGxpc3RlbmVyLCBudW1MaXN0ZW5lcnMgKyAxKTtcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBvZmYoZXZlbnQsIGxpc3RlbmVyKSB7XG4gICAgaWYgKCF0aGlzLm9ic2VydmVyc1tldmVudF0pIHJldHVybjtcbiAgICBpZiAoIWxpc3RlbmVyKSB7XG4gICAgICBkZWxldGUgdGhpcy5vYnNlcnZlcnNbZXZlbnRdO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLm9ic2VydmVyc1tldmVudF0uZGVsZXRlKGxpc3RlbmVyKTtcbiAgfVxuICBlbWl0KGV2ZW50KSB7XG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuICAgIGlmICh0aGlzLm9ic2VydmVyc1tldmVudF0pIHtcbiAgICAgIGNvbnN0IGNsb25lZCA9IEFycmF5LmZyb20odGhpcy5vYnNlcnZlcnNbZXZlbnRdLmVudHJpZXMoKSk7XG4gICAgICBjbG9uZWQuZm9yRWFjaChfcmVmID0+IHtcbiAgICAgICAgbGV0IFtvYnNlcnZlciwgbnVtVGltZXNBZGRlZF0gPSBfcmVmO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bVRpbWVzQWRkZWQ7IGkrKykge1xuICAgICAgICAgIG9ic2VydmVyKC4uLmFyZ3MpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHRoaXMub2JzZXJ2ZXJzWycqJ10pIHtcbiAgICAgIGNvbnN0IGNsb25lZCA9IEFycmF5LmZyb20odGhpcy5vYnNlcnZlcnNbJyonXS5lbnRyaWVzKCkpO1xuICAgICAgY2xvbmVkLmZvckVhY2goX3JlZjIgPT4ge1xuICAgICAgICBsZXQgW29ic2VydmVyLCBudW1UaW1lc0FkZGVkXSA9IF9yZWYyO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bVRpbWVzQWRkZWQ7IGkrKykge1xuICAgICAgICAgIG9ic2VydmVyLmFwcGx5KG9ic2VydmVyLCBbZXZlbnQsIC4uLmFyZ3NdKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGRlZmVyKCkge1xuICBsZXQgcmVzO1xuICBsZXQgcmVqO1xuICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIHJlcyA9IHJlc29sdmU7XG4gICAgcmVqID0gcmVqZWN0O1xuICB9KTtcbiAgcHJvbWlzZS5yZXNvbHZlID0gcmVzO1xuICBwcm9taXNlLnJlamVjdCA9IHJlajtcbiAgcmV0dXJuIHByb21pc2U7XG59XG5mdW5jdGlvbiBtYWtlU3RyaW5nKG9iamVjdCkge1xuICBpZiAob2JqZWN0ID09IG51bGwpIHJldHVybiAnJztcbiAgcmV0dXJuICcnICsgb2JqZWN0O1xufVxuZnVuY3Rpb24gY29weShhLCBzLCB0KSB7XG4gIGEuZm9yRWFjaChtID0+IHtcbiAgICBpZiAoc1ttXSkgdFttXSA9IHNbbV07XG4gIH0pO1xufVxuY29uc3QgbGFzdE9mUGF0aFNlcGFyYXRvclJlZ0V4cCA9IC8jIyMvZztcbmZ1bmN0aW9uIGdldExhc3RPZlBhdGgob2JqZWN0LCBwYXRoLCBFbXB0eSkge1xuICBmdW5jdGlvbiBjbGVhbktleShrZXkpIHtcbiAgICByZXR1cm4ga2V5ICYmIGtleS5pbmRleE9mKCcjIyMnKSA+IC0xID8ga2V5LnJlcGxhY2UobGFzdE9mUGF0aFNlcGFyYXRvclJlZ0V4cCwgJy4nKSA6IGtleTtcbiAgfVxuICBmdW5jdGlvbiBjYW5Ob3RUcmF2ZXJzZURlZXBlcigpIHtcbiAgICByZXR1cm4gIW9iamVjdCB8fCB0eXBlb2Ygb2JqZWN0ID09PSAnc3RyaW5nJztcbiAgfVxuICBjb25zdCBzdGFjayA9IHR5cGVvZiBwYXRoICE9PSAnc3RyaW5nJyA/IHBhdGggOiBwYXRoLnNwbGl0KCcuJyk7XG4gIGxldCBzdGFja0luZGV4ID0gMDtcbiAgd2hpbGUgKHN0YWNrSW5kZXggPCBzdGFjay5sZW5ndGggLSAxKSB7XG4gICAgaWYgKGNhbk5vdFRyYXZlcnNlRGVlcGVyKCkpIHJldHVybiB7fTtcbiAgICBjb25zdCBrZXkgPSBjbGVhbktleShzdGFja1tzdGFja0luZGV4XSk7XG4gICAgaWYgKCFvYmplY3Rba2V5XSAmJiBFbXB0eSkgb2JqZWN0W2tleV0gPSBuZXcgRW1wdHkoKTtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSkge1xuICAgICAgb2JqZWN0ID0gb2JqZWN0W2tleV07XG4gICAgfSBlbHNlIHtcbiAgICAgIG9iamVjdCA9IHt9O1xuICAgIH1cbiAgICArK3N0YWNrSW5kZXg7XG4gIH1cbiAgaWYgKGNhbk5vdFRyYXZlcnNlRGVlcGVyKCkpIHJldHVybiB7fTtcbiAgcmV0dXJuIHtcbiAgICBvYmo6IG9iamVjdCxcbiAgICBrOiBjbGVhbktleShzdGFja1tzdGFja0luZGV4XSlcbiAgfTtcbn1cbmZ1bmN0aW9uIHNldFBhdGgob2JqZWN0LCBwYXRoLCBuZXdWYWx1ZSkge1xuICBjb25zdCB7XG4gICAgb2JqLFxuICAgIGtcbiAgfSA9IGdldExhc3RPZlBhdGgob2JqZWN0LCBwYXRoLCBPYmplY3QpO1xuICBpZiAob2JqICE9PSB1bmRlZmluZWQgfHwgcGF0aC5sZW5ndGggPT09IDEpIHtcbiAgICBvYmpba10gPSBuZXdWYWx1ZTtcbiAgICByZXR1cm47XG4gIH1cbiAgbGV0IGUgPSBwYXRoW3BhdGgubGVuZ3RoIC0gMV07XG4gIGxldCBwID0gcGF0aC5zbGljZSgwLCBwYXRoLmxlbmd0aCAtIDEpO1xuICBsZXQgbGFzdCA9IGdldExhc3RPZlBhdGgob2JqZWN0LCBwLCBPYmplY3QpO1xuICB3aGlsZSAobGFzdC5vYmogPT09IHVuZGVmaW5lZCAmJiBwLmxlbmd0aCkge1xuICAgIGUgPSBgJHtwW3AubGVuZ3RoIC0gMV19LiR7ZX1gO1xuICAgIHAgPSBwLnNsaWNlKDAsIHAubGVuZ3RoIC0gMSk7XG4gICAgbGFzdCA9IGdldExhc3RPZlBhdGgob2JqZWN0LCBwLCBPYmplY3QpO1xuICAgIGlmIChsYXN0ICYmIGxhc3Qub2JqICYmIHR5cGVvZiBsYXN0Lm9ialtgJHtsYXN0Lmt9LiR7ZX1gXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGxhc3Qub2JqID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfVxuICBsYXN0Lm9ialtgJHtsYXN0Lmt9LiR7ZX1gXSA9IG5ld1ZhbHVlO1xufVxuZnVuY3Rpb24gcHVzaFBhdGgob2JqZWN0LCBwYXRoLCBuZXdWYWx1ZSwgY29uY2F0KSB7XG4gIGNvbnN0IHtcbiAgICBvYmosXG4gICAga1xuICB9ID0gZ2V0TGFzdE9mUGF0aChvYmplY3QsIHBhdGgsIE9iamVjdCk7XG4gIG9ialtrXSA9IG9ialtrXSB8fCBbXTtcbiAgb2JqW2tdLnB1c2gobmV3VmFsdWUpO1xufVxuZnVuY3Rpb24gZ2V0UGF0aChvYmplY3QsIHBhdGgpIHtcbiAgY29uc3Qge1xuICAgIG9iaixcbiAgICBrXG4gIH0gPSBnZXRMYXN0T2ZQYXRoKG9iamVjdCwgcGF0aCk7XG4gIGlmICghb2JqKSByZXR1cm4gdW5kZWZpbmVkO1xuICByZXR1cm4gb2JqW2tdO1xufVxuZnVuY3Rpb24gZ2V0UGF0aFdpdGhEZWZhdWx0cyhkYXRhLCBkZWZhdWx0RGF0YSwga2V5KSB7XG4gIGNvbnN0IHZhbHVlID0gZ2V0UGF0aChkYXRhLCBrZXkpO1xuICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICByZXR1cm4gZ2V0UGF0aChkZWZhdWx0RGF0YSwga2V5KTtcbn1cbmZ1bmN0aW9uIGRlZXBFeHRlbmQodGFyZ2V0LCBzb3VyY2UsIG92ZXJ3cml0ZSkge1xuICBmb3IgKGNvbnN0IHByb3AgaW4gc291cmNlKSB7XG4gICAgaWYgKHByb3AgIT09ICdfX3Byb3RvX18nICYmIHByb3AgIT09ICdjb25zdHJ1Y3RvcicpIHtcbiAgICAgIGlmIChwcm9wIGluIHRhcmdldCkge1xuICAgICAgICBpZiAodHlwZW9mIHRhcmdldFtwcm9wXSA9PT0gJ3N0cmluZycgfHwgdGFyZ2V0W3Byb3BdIGluc3RhbmNlb2YgU3RyaW5nIHx8IHR5cGVvZiBzb3VyY2VbcHJvcF0gPT09ICdzdHJpbmcnIHx8IHNvdXJjZVtwcm9wXSBpbnN0YW5jZW9mIFN0cmluZykge1xuICAgICAgICAgIGlmIChvdmVyd3JpdGUpIHRhcmdldFtwcm9wXSA9IHNvdXJjZVtwcm9wXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZWVwRXh0ZW5kKHRhcmdldFtwcm9wXSwgc291cmNlW3Byb3BdLCBvdmVyd3JpdGUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0YXJnZXRbcHJvcF0gPSBzb3VyY2VbcHJvcF07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB0YXJnZXQ7XG59XG5mdW5jdGlvbiByZWdleEVzY2FwZShzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9bXFwtXFxbXFxdXFwvXFx7XFx9XFwoXFwpXFwqXFwrXFw/XFwuXFxcXFxcXlxcJFxcfF0vZywgJ1xcXFwkJicpO1xufVxudmFyIF9lbnRpdHlNYXAgPSB7XG4gICcmJzogJyZhbXA7JyxcbiAgJzwnOiAnJmx0OycsXG4gICc+JzogJyZndDsnLFxuICAnXCInOiAnJnF1b3Q7JyxcbiAgXCInXCI6ICcmIzM5OycsXG4gICcvJzogJyYjeDJGOydcbn07XG5mdW5jdGlvbiBlc2NhcGUoZGF0YSkge1xuICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGRhdGEucmVwbGFjZSgvWyY8PlwiJ1xcL10vZywgcyA9PiBfZW50aXR5TWFwW3NdKTtcbiAgfVxuICByZXR1cm4gZGF0YTtcbn1cbmNsYXNzIFJlZ0V4cENhY2hlIHtcbiAgY29uc3RydWN0b3IoY2FwYWNpdHkpIHtcbiAgICB0aGlzLmNhcGFjaXR5ID0gY2FwYWNpdHk7XG4gICAgdGhpcy5yZWdFeHBNYXAgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5yZWdFeHBRdWV1ZSA9IFtdO1xuICB9XG4gIGdldFJlZ0V4cChwYXR0ZXJuKSB7XG4gICAgY29uc3QgcmVnRXhwRnJvbUNhY2hlID0gdGhpcy5yZWdFeHBNYXAuZ2V0KHBhdHRlcm4pO1xuICAgIGlmIChyZWdFeHBGcm9tQ2FjaGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHJlZ0V4cEZyb21DYWNoZTtcbiAgICB9XG4gICAgY29uc3QgcmVnRXhwTmV3ID0gbmV3IFJlZ0V4cChwYXR0ZXJuKTtcbiAgICBpZiAodGhpcy5yZWdFeHBRdWV1ZS5sZW5ndGggPT09IHRoaXMuY2FwYWNpdHkpIHtcbiAgICAgIHRoaXMucmVnRXhwTWFwLmRlbGV0ZSh0aGlzLnJlZ0V4cFF1ZXVlLnNoaWZ0KCkpO1xuICAgIH1cbiAgICB0aGlzLnJlZ0V4cE1hcC5zZXQocGF0dGVybiwgcmVnRXhwTmV3KTtcbiAgICB0aGlzLnJlZ0V4cFF1ZXVlLnB1c2gocGF0dGVybik7XG4gICAgcmV0dXJuIHJlZ0V4cE5ldztcbiAgfVxufVxuY29uc3QgY2hhcnMgPSBbJyAnLCAnLCcsICc/JywgJyEnLCAnOyddO1xuY29uc3QgbG9va3NMaWtlT2JqZWN0UGF0aFJlZ0V4cENhY2hlID0gbmV3IFJlZ0V4cENhY2hlKDIwKTtcbmZ1bmN0aW9uIGxvb2tzTGlrZU9iamVjdFBhdGgoa2V5LCBuc1NlcGFyYXRvciwga2V5U2VwYXJhdG9yKSB7XG4gIG5zU2VwYXJhdG9yID0gbnNTZXBhcmF0b3IgfHwgJyc7XG4gIGtleVNlcGFyYXRvciA9IGtleVNlcGFyYXRvciB8fCAnJztcbiAgY29uc3QgcG9zc2libGVDaGFycyA9IGNoYXJzLmZpbHRlcihjID0+IG5zU2VwYXJhdG9yLmluZGV4T2YoYykgPCAwICYmIGtleVNlcGFyYXRvci5pbmRleE9mKGMpIDwgMCk7XG4gIGlmIChwb3NzaWJsZUNoYXJzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHRydWU7XG4gIGNvbnN0IHIgPSBsb29rc0xpa2VPYmplY3RQYXRoUmVnRXhwQ2FjaGUuZ2V0UmVnRXhwKGAoJHtwb3NzaWJsZUNoYXJzLm1hcChjID0+IGMgPT09ICc/JyA/ICdcXFxcPycgOiBjKS5qb2luKCd8Jyl9KWApO1xuICBsZXQgbWF0Y2hlZCA9ICFyLnRlc3Qoa2V5KTtcbiAgaWYgKCFtYXRjaGVkKSB7XG4gICAgY29uc3Qga2kgPSBrZXkuaW5kZXhPZihrZXlTZXBhcmF0b3IpO1xuICAgIGlmIChraSA+IDAgJiYgIXIudGVzdChrZXkuc3Vic3RyaW5nKDAsIGtpKSkpIHtcbiAgICAgIG1hdGNoZWQgPSB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbWF0Y2hlZDtcbn1cbmZ1bmN0aW9uIGRlZXBGaW5kKG9iaiwgcGF0aCkge1xuICBsZXQga2V5U2VwYXJhdG9yID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiAnLic7XG4gIGlmICghb2JqKSByZXR1cm4gdW5kZWZpbmVkO1xuICBpZiAob2JqW3BhdGhdKSByZXR1cm4gb2JqW3BhdGhdO1xuICBjb25zdCB0b2tlbnMgPSBwYXRoLnNwbGl0KGtleVNlcGFyYXRvcik7XG4gIGxldCBjdXJyZW50ID0gb2JqO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHRva2Vucy5sZW5ndGg7KSB7XG4gICAgaWYgKCFjdXJyZW50IHx8IHR5cGVvZiBjdXJyZW50ICE9PSAnb2JqZWN0Jykge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgbGV0IG5leHQ7XG4gICAgbGV0IG5leHRQYXRoID0gJyc7XG4gICAgZm9yIChsZXQgaiA9IGk7IGogPCB0b2tlbnMubGVuZ3RoOyArK2opIHtcbiAgICAgIGlmIChqICE9PSBpKSB7XG4gICAgICAgIG5leHRQYXRoICs9IGtleVNlcGFyYXRvcjtcbiAgICAgIH1cbiAgICAgIG5leHRQYXRoICs9IHRva2Vuc1tqXTtcbiAgICAgIG5leHQgPSBjdXJyZW50W25leHRQYXRoXTtcbiAgICAgIGlmIChuZXh0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKFsnc3RyaW5nJywgJ251bWJlcicsICdib29sZWFuJ10uaW5kZXhPZih0eXBlb2YgbmV4dCkgPiAtMSAmJiBqIDwgdG9rZW5zLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpICs9IGogLSBpICsgMTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGN1cnJlbnQgPSBuZXh0O1xuICB9XG4gIHJldHVybiBjdXJyZW50O1xufVxuZnVuY3Rpb24gZ2V0Q2xlYW5lZENvZGUoY29kZSkge1xuICBpZiAoY29kZSAmJiBjb2RlLmluZGV4T2YoJ18nKSA+IDApIHJldHVybiBjb2RlLnJlcGxhY2UoJ18nLCAnLScpO1xuICByZXR1cm4gY29kZTtcbn1cblxuY2xhc3MgUmVzb3VyY2VTdG9yZSBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAgICBsZXQgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge1xuICAgICAgbnM6IFsndHJhbnNsYXRpb24nXSxcbiAgICAgIGRlZmF1bHROUzogJ3RyYW5zbGF0aW9uJ1xuICAgIH07XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmRhdGEgPSBkYXRhIHx8IHt9O1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5rZXlTZXBhcmF0b3IgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5vcHRpb25zLmtleVNlcGFyYXRvciA9ICcuJztcbiAgICB9XG4gICAgaWYgKHRoaXMub3B0aW9ucy5pZ25vcmVKU09OU3RydWN0dXJlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMub3B0aW9ucy5pZ25vcmVKU09OU3RydWN0dXJlID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgYWRkTmFtZXNwYWNlcyhucykge1xuICAgIGlmICh0aGlzLm9wdGlvbnMubnMuaW5kZXhPZihucykgPCAwKSB7XG4gICAgICB0aGlzLm9wdGlvbnMubnMucHVzaChucyk7XG4gICAgfVxuICB9XG4gIHJlbW92ZU5hbWVzcGFjZXMobnMpIHtcbiAgICBjb25zdCBpbmRleCA9IHRoaXMub3B0aW9ucy5ucy5pbmRleE9mKG5zKTtcbiAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgdGhpcy5vcHRpb25zLm5zLnNwbGljZShpbmRleCwgMSk7XG4gICAgfVxuICB9XG4gIGdldFJlc291cmNlKGxuZywgbnMsIGtleSkge1xuICAgIGxldCBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiB7fTtcbiAgICBjb25zdCBrZXlTZXBhcmF0b3IgPSBvcHRpb25zLmtleVNlcGFyYXRvciAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5rZXlTZXBhcmF0b3IgOiB0aGlzLm9wdGlvbnMua2V5U2VwYXJhdG9yO1xuICAgIGNvbnN0IGlnbm9yZUpTT05TdHJ1Y3R1cmUgPSBvcHRpb25zLmlnbm9yZUpTT05TdHJ1Y3R1cmUgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuaWdub3JlSlNPTlN0cnVjdHVyZSA6IHRoaXMub3B0aW9ucy5pZ25vcmVKU09OU3RydWN0dXJlO1xuICAgIGxldCBwYXRoO1xuICAgIGlmIChsbmcuaW5kZXhPZignLicpID4gLTEpIHtcbiAgICAgIHBhdGggPSBsbmcuc3BsaXQoJy4nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGF0aCA9IFtsbmcsIG5zXTtcbiAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoa2V5KSkge1xuICAgICAgICAgIHBhdGgucHVzaCguLi5rZXkpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnICYmIGtleVNlcGFyYXRvcikge1xuICAgICAgICAgIHBhdGgucHVzaCguLi5rZXkuc3BsaXQoa2V5U2VwYXJhdG9yKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGF0aC5wdXNoKGtleSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gZ2V0UGF0aCh0aGlzLmRhdGEsIHBhdGgpO1xuICAgIGlmICghcmVzdWx0ICYmICFucyAmJiAha2V5ICYmIGxuZy5pbmRleE9mKCcuJykgPiAtMSkge1xuICAgICAgbG5nID0gcGF0aFswXTtcbiAgICAgIG5zID0gcGF0aFsxXTtcbiAgICAgIGtleSA9IHBhdGguc2xpY2UoMikuam9pbignLicpO1xuICAgIH1cbiAgICBpZiAocmVzdWx0IHx8ICFpZ25vcmVKU09OU3RydWN0dXJlIHx8IHR5cGVvZiBrZXkgIT09ICdzdHJpbmcnKSByZXR1cm4gcmVzdWx0O1xuICAgIHJldHVybiBkZWVwRmluZCh0aGlzLmRhdGEgJiYgdGhpcy5kYXRhW2xuZ10gJiYgdGhpcy5kYXRhW2xuZ11bbnNdLCBrZXksIGtleVNlcGFyYXRvcik7XG4gIH1cbiAgYWRkUmVzb3VyY2UobG5nLCBucywga2V5LCB2YWx1ZSkge1xuICAgIGxldCBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDQgJiYgYXJndW1lbnRzWzRdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNF0gOiB7XG4gICAgICBzaWxlbnQ6IGZhbHNlXG4gICAgfTtcbiAgICBjb25zdCBrZXlTZXBhcmF0b3IgPSBvcHRpb25zLmtleVNlcGFyYXRvciAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5rZXlTZXBhcmF0b3IgOiB0aGlzLm9wdGlvbnMua2V5U2VwYXJhdG9yO1xuICAgIGxldCBwYXRoID0gW2xuZywgbnNdO1xuICAgIGlmIChrZXkpIHBhdGggPSBwYXRoLmNvbmNhdChrZXlTZXBhcmF0b3IgPyBrZXkuc3BsaXQoa2V5U2VwYXJhdG9yKSA6IGtleSk7XG4gICAgaWYgKGxuZy5pbmRleE9mKCcuJykgPiAtMSkge1xuICAgICAgcGF0aCA9IGxuZy5zcGxpdCgnLicpO1xuICAgICAgdmFsdWUgPSBucztcbiAgICAgIG5zID0gcGF0aFsxXTtcbiAgICB9XG4gICAgdGhpcy5hZGROYW1lc3BhY2VzKG5zKTtcbiAgICBzZXRQYXRoKHRoaXMuZGF0YSwgcGF0aCwgdmFsdWUpO1xuICAgIGlmICghb3B0aW9ucy5zaWxlbnQpIHRoaXMuZW1pdCgnYWRkZWQnLCBsbmcsIG5zLCBrZXksIHZhbHVlKTtcbiAgfVxuICBhZGRSZXNvdXJjZXMobG5nLCBucywgcmVzb3VyY2VzKSB7XG4gICAgbGV0IG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IHtcbiAgICAgIHNpbGVudDogZmFsc2VcbiAgICB9O1xuICAgIGZvciAoY29uc3QgbSBpbiByZXNvdXJjZXMpIHtcbiAgICAgIGlmICh0eXBlb2YgcmVzb3VyY2VzW21dID09PSAnc3RyaW5nJyB8fCBBcnJheS5pc0FycmF5KHJlc291cmNlc1ttXSkpIHRoaXMuYWRkUmVzb3VyY2UobG5nLCBucywgbSwgcmVzb3VyY2VzW21dLCB7XG4gICAgICAgIHNpbGVudDogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmICghb3B0aW9ucy5zaWxlbnQpIHRoaXMuZW1pdCgnYWRkZWQnLCBsbmcsIG5zLCByZXNvdXJjZXMpO1xuICB9XG4gIGFkZFJlc291cmNlQnVuZGxlKGxuZywgbnMsIHJlc291cmNlcywgZGVlcCwgb3ZlcndyaXRlKSB7XG4gICAgbGV0IG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gNSAmJiBhcmd1bWVudHNbNV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s1XSA6IHtcbiAgICAgIHNpbGVudDogZmFsc2UsXG4gICAgICBza2lwQ29weTogZmFsc2VcbiAgICB9O1xuICAgIGxldCBwYXRoID0gW2xuZywgbnNdO1xuICAgIGlmIChsbmcuaW5kZXhPZignLicpID4gLTEpIHtcbiAgICAgIHBhdGggPSBsbmcuc3BsaXQoJy4nKTtcbiAgICAgIGRlZXAgPSByZXNvdXJjZXM7XG4gICAgICByZXNvdXJjZXMgPSBucztcbiAgICAgIG5zID0gcGF0aFsxXTtcbiAgICB9XG4gICAgdGhpcy5hZGROYW1lc3BhY2VzKG5zKTtcbiAgICBsZXQgcGFjayA9IGdldFBhdGgodGhpcy5kYXRhLCBwYXRoKSB8fCB7fTtcbiAgICBpZiAoIW9wdGlvbnMuc2tpcENvcHkpIHJlc291cmNlcyA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkocmVzb3VyY2VzKSk7XG4gICAgaWYgKGRlZXApIHtcbiAgICAgIGRlZXBFeHRlbmQocGFjaywgcmVzb3VyY2VzLCBvdmVyd3JpdGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYWNrID0ge1xuICAgICAgICAuLi5wYWNrLFxuICAgICAgICAuLi5yZXNvdXJjZXNcbiAgICAgIH07XG4gICAgfVxuICAgIHNldFBhdGgodGhpcy5kYXRhLCBwYXRoLCBwYWNrKTtcbiAgICBpZiAoIW9wdGlvbnMuc2lsZW50KSB0aGlzLmVtaXQoJ2FkZGVkJywgbG5nLCBucywgcmVzb3VyY2VzKTtcbiAgfVxuICByZW1vdmVSZXNvdXJjZUJ1bmRsZShsbmcsIG5zKSB7XG4gICAgaWYgKHRoaXMuaGFzUmVzb3VyY2VCdW5kbGUobG5nLCBucykpIHtcbiAgICAgIGRlbGV0ZSB0aGlzLmRhdGFbbG5nXVtuc107XG4gICAgfVxuICAgIHRoaXMucmVtb3ZlTmFtZXNwYWNlcyhucyk7XG4gICAgdGhpcy5lbWl0KCdyZW1vdmVkJywgbG5nLCBucyk7XG4gIH1cbiAgaGFzUmVzb3VyY2VCdW5kbGUobG5nLCBucykge1xuICAgIHJldHVybiB0aGlzLmdldFJlc291cmNlKGxuZywgbnMpICE9PSB1bmRlZmluZWQ7XG4gIH1cbiAgZ2V0UmVzb3VyY2VCdW5kbGUobG5nLCBucykge1xuICAgIGlmICghbnMpIG5zID0gdGhpcy5vcHRpb25zLmRlZmF1bHROUztcbiAgICBpZiAodGhpcy5vcHRpb25zLmNvbXBhdGliaWxpdHlBUEkgPT09ICd2MScpIHJldHVybiB7XG4gICAgICAuLi57fSxcbiAgICAgIC4uLnRoaXMuZ2V0UmVzb3VyY2UobG5nLCBucylcbiAgICB9O1xuICAgIHJldHVybiB0aGlzLmdldFJlc291cmNlKGxuZywgbnMpO1xuICB9XG4gIGdldERhdGFCeUxhbmd1YWdlKGxuZykge1xuICAgIHJldHVybiB0aGlzLmRhdGFbbG5nXTtcbiAgfVxuICBoYXNMYW5ndWFnZVNvbWVUcmFuc2xhdGlvbnMobG5nKSB7XG4gICAgY29uc3QgZGF0YSA9IHRoaXMuZ2V0RGF0YUJ5TGFuZ3VhZ2UobG5nKTtcbiAgICBjb25zdCBuID0gZGF0YSAmJiBPYmplY3Qua2V5cyhkYXRhKSB8fCBbXTtcbiAgICByZXR1cm4gISFuLmZpbmQodiA9PiBkYXRhW3ZdICYmIE9iamVjdC5rZXlzKGRhdGFbdl0pLmxlbmd0aCA+IDApO1xuICB9XG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRhO1xuICB9XG59XG5cbnZhciBwb3N0UHJvY2Vzc29yID0ge1xuICBwcm9jZXNzb3JzOiB7fSxcbiAgYWRkUG9zdFByb2Nlc3Nvcihtb2R1bGUpIHtcbiAgICB0aGlzLnByb2Nlc3NvcnNbbW9kdWxlLm5hbWVdID0gbW9kdWxlO1xuICB9LFxuICBoYW5kbGUocHJvY2Vzc29ycywgdmFsdWUsIGtleSwgb3B0aW9ucywgdHJhbnNsYXRvcikge1xuICAgIHByb2Nlc3NvcnMuZm9yRWFjaChwcm9jZXNzb3IgPT4ge1xuICAgICAgaWYgKHRoaXMucHJvY2Vzc29yc1twcm9jZXNzb3JdKSB2YWx1ZSA9IHRoaXMucHJvY2Vzc29yc1twcm9jZXNzb3JdLnByb2Nlc3ModmFsdWUsIGtleSwgb3B0aW9ucywgdHJhbnNsYXRvcik7XG4gICAgfSk7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG59O1xuXG5jb25zdCBjaGVja2VkTG9hZGVkRm9yID0ge307XG5jbGFzcyBUcmFuc2xhdG9yIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcbiAgY29uc3RydWN0b3Ioc2VydmljZXMpIHtcbiAgICBsZXQgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgc3VwZXIoKTtcbiAgICBjb3B5KFsncmVzb3VyY2VTdG9yZScsICdsYW5ndWFnZVV0aWxzJywgJ3BsdXJhbFJlc29sdmVyJywgJ2ludGVycG9sYXRvcicsICdiYWNrZW5kQ29ubmVjdG9yJywgJ2kxOG5Gb3JtYXQnLCAndXRpbHMnXSwgc2VydmljZXMsIHRoaXMpO1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5rZXlTZXBhcmF0b3IgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5vcHRpb25zLmtleVNlcGFyYXRvciA9ICcuJztcbiAgICB9XG4gICAgdGhpcy5sb2dnZXIgPSBiYXNlTG9nZ2VyLmNyZWF0ZSgndHJhbnNsYXRvcicpO1xuICB9XG4gIGNoYW5nZUxhbmd1YWdlKGxuZykge1xuICAgIGlmIChsbmcpIHRoaXMubGFuZ3VhZ2UgPSBsbmc7XG4gIH1cbiAgZXhpc3RzKGtleSkge1xuICAgIGxldCBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7XG4gICAgICBpbnRlcnBvbGF0aW9uOiB7fVxuICAgIH07XG4gICAgaWYgKGtleSA9PT0gdW5kZWZpbmVkIHx8IGtleSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCByZXNvbHZlZCA9IHRoaXMucmVzb2x2ZShrZXksIG9wdGlvbnMpO1xuICAgIHJldHVybiByZXNvbHZlZCAmJiByZXNvbHZlZC5yZXMgIT09IHVuZGVmaW5lZDtcbiAgfVxuICBleHRyYWN0RnJvbUtleShrZXksIG9wdGlvbnMpIHtcbiAgICBsZXQgbnNTZXBhcmF0b3IgPSBvcHRpb25zLm5zU2VwYXJhdG9yICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLm5zU2VwYXJhdG9yIDogdGhpcy5vcHRpb25zLm5zU2VwYXJhdG9yO1xuICAgIGlmIChuc1NlcGFyYXRvciA9PT0gdW5kZWZpbmVkKSBuc1NlcGFyYXRvciA9ICc6JztcbiAgICBjb25zdCBrZXlTZXBhcmF0b3IgPSBvcHRpb25zLmtleVNlcGFyYXRvciAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5rZXlTZXBhcmF0b3IgOiB0aGlzLm9wdGlvbnMua2V5U2VwYXJhdG9yO1xuICAgIGxldCBuYW1lc3BhY2VzID0gb3B0aW9ucy5ucyB8fCB0aGlzLm9wdGlvbnMuZGVmYXVsdE5TIHx8IFtdO1xuICAgIGNvbnN0IHdvdWxkQ2hlY2tGb3JOc0luS2V5ID0gbnNTZXBhcmF0b3IgJiYga2V5LmluZGV4T2YobnNTZXBhcmF0b3IpID4gLTE7XG4gICAgY29uc3Qgc2VlbXNOYXR1cmFsTGFuZ3VhZ2UgPSAhdGhpcy5vcHRpb25zLnVzZXJEZWZpbmVkS2V5U2VwYXJhdG9yICYmICFvcHRpb25zLmtleVNlcGFyYXRvciAmJiAhdGhpcy5vcHRpb25zLnVzZXJEZWZpbmVkTnNTZXBhcmF0b3IgJiYgIW9wdGlvbnMubnNTZXBhcmF0b3IgJiYgIWxvb2tzTGlrZU9iamVjdFBhdGgoa2V5LCBuc1NlcGFyYXRvciwga2V5U2VwYXJhdG9yKTtcbiAgICBpZiAod291bGRDaGVja0Zvck5zSW5LZXkgJiYgIXNlZW1zTmF0dXJhbExhbmd1YWdlKSB7XG4gICAgICBjb25zdCBtID0ga2V5Lm1hdGNoKHRoaXMuaW50ZXJwb2xhdG9yLm5lc3RpbmdSZWdleHApO1xuICAgICAgaWYgKG0gJiYgbS5sZW5ndGggPiAwKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAga2V5LFxuICAgICAgICAgIG5hbWVzcGFjZXNcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHBhcnRzID0ga2V5LnNwbGl0KG5zU2VwYXJhdG9yKTtcbiAgICAgIGlmIChuc1NlcGFyYXRvciAhPT0ga2V5U2VwYXJhdG9yIHx8IG5zU2VwYXJhdG9yID09PSBrZXlTZXBhcmF0b3IgJiYgdGhpcy5vcHRpb25zLm5zLmluZGV4T2YocGFydHNbMF0pID4gLTEpIG5hbWVzcGFjZXMgPSBwYXJ0cy5zaGlmdCgpO1xuICAgICAga2V5ID0gcGFydHMuam9pbihrZXlTZXBhcmF0b3IpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG5hbWVzcGFjZXMgPT09ICdzdHJpbmcnKSBuYW1lc3BhY2VzID0gW25hbWVzcGFjZXNdO1xuICAgIHJldHVybiB7XG4gICAgICBrZXksXG4gICAgICBuYW1lc3BhY2VzXG4gICAgfTtcbiAgfVxuICB0cmFuc2xhdGUoa2V5cywgb3B0aW9ucywgbGFzdEtleSkge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyAhPT0gJ29iamVjdCcgJiYgdGhpcy5vcHRpb25zLm92ZXJsb2FkVHJhbnNsYXRpb25PcHRpb25IYW5kbGVyKSB7XG4gICAgICBvcHRpb25zID0gdGhpcy5vcHRpb25zLm92ZXJsb2FkVHJhbnNsYXRpb25PcHRpb25IYW5kbGVyKGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ29iamVjdCcpIG9wdGlvbnMgPSB7XG4gICAgICAuLi5vcHRpb25zXG4gICAgfTtcbiAgICBpZiAoIW9wdGlvbnMpIG9wdGlvbnMgPSB7fTtcbiAgICBpZiAoa2V5cyA9PT0gdW5kZWZpbmVkIHx8IGtleXMgPT09IG51bGwpIHJldHVybiAnJztcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoa2V5cykpIGtleXMgPSBbU3RyaW5nKGtleXMpXTtcbiAgICBjb25zdCByZXR1cm5EZXRhaWxzID0gb3B0aW9ucy5yZXR1cm5EZXRhaWxzICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnJldHVybkRldGFpbHMgOiB0aGlzLm9wdGlvbnMucmV0dXJuRGV0YWlscztcbiAgICBjb25zdCBrZXlTZXBhcmF0b3IgPSBvcHRpb25zLmtleVNlcGFyYXRvciAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5rZXlTZXBhcmF0b3IgOiB0aGlzLm9wdGlvbnMua2V5U2VwYXJhdG9yO1xuICAgIGNvbnN0IHtcbiAgICAgIGtleSxcbiAgICAgIG5hbWVzcGFjZXNcbiAgICB9ID0gdGhpcy5leHRyYWN0RnJvbUtleShrZXlzW2tleXMubGVuZ3RoIC0gMV0sIG9wdGlvbnMpO1xuICAgIGNvbnN0IG5hbWVzcGFjZSA9IG5hbWVzcGFjZXNbbmFtZXNwYWNlcy5sZW5ndGggLSAxXTtcbiAgICBjb25zdCBsbmcgPSBvcHRpb25zLmxuZyB8fCB0aGlzLmxhbmd1YWdlO1xuICAgIGNvbnN0IGFwcGVuZE5hbWVzcGFjZVRvQ0lNb2RlID0gb3B0aW9ucy5hcHBlbmROYW1lc3BhY2VUb0NJTW9kZSB8fCB0aGlzLm9wdGlvbnMuYXBwZW5kTmFtZXNwYWNlVG9DSU1vZGU7XG4gICAgaWYgKGxuZyAmJiBsbmcudG9Mb3dlckNhc2UoKSA9PT0gJ2NpbW9kZScpIHtcbiAgICAgIGlmIChhcHBlbmROYW1lc3BhY2VUb0NJTW9kZSkge1xuICAgICAgICBjb25zdCBuc1NlcGFyYXRvciA9IG9wdGlvbnMubnNTZXBhcmF0b3IgfHwgdGhpcy5vcHRpb25zLm5zU2VwYXJhdG9yO1xuICAgICAgICBpZiAocmV0dXJuRGV0YWlscykge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByZXM6IGAke25hbWVzcGFjZX0ke25zU2VwYXJhdG9yfSR7a2V5fWAsXG4gICAgICAgICAgICB1c2VkS2V5OiBrZXksXG4gICAgICAgICAgICBleGFjdFVzZWRLZXk6IGtleSxcbiAgICAgICAgICAgIHVzZWRMbmc6IGxuZyxcbiAgICAgICAgICAgIHVzZWROUzogbmFtZXNwYWNlLFxuICAgICAgICAgICAgdXNlZFBhcmFtczogdGhpcy5nZXRVc2VkUGFyYW1zRGV0YWlscyhvcHRpb25zKVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGAke25hbWVzcGFjZX0ke25zU2VwYXJhdG9yfSR7a2V5fWA7XG4gICAgICB9XG4gICAgICBpZiAocmV0dXJuRGV0YWlscykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHJlczoga2V5LFxuICAgICAgICAgIHVzZWRLZXk6IGtleSxcbiAgICAgICAgICBleGFjdFVzZWRLZXk6IGtleSxcbiAgICAgICAgICB1c2VkTG5nOiBsbmcsXG4gICAgICAgICAgdXNlZE5TOiBuYW1lc3BhY2UsXG4gICAgICAgICAgdXNlZFBhcmFtczogdGhpcy5nZXRVc2VkUGFyYW1zRGV0YWlscyhvcHRpb25zKVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIGtleTtcbiAgICB9XG4gICAgY29uc3QgcmVzb2x2ZWQgPSB0aGlzLnJlc29sdmUoa2V5cywgb3B0aW9ucyk7XG4gICAgbGV0IHJlcyA9IHJlc29sdmVkICYmIHJlc29sdmVkLnJlcztcbiAgICBjb25zdCByZXNVc2VkS2V5ID0gcmVzb2x2ZWQgJiYgcmVzb2x2ZWQudXNlZEtleSB8fCBrZXk7XG4gICAgY29uc3QgcmVzRXhhY3RVc2VkS2V5ID0gcmVzb2x2ZWQgJiYgcmVzb2x2ZWQuZXhhY3RVc2VkS2V5IHx8IGtleTtcbiAgICBjb25zdCByZXNUeXBlID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5hcHBseShyZXMpO1xuICAgIGNvbnN0IG5vT2JqZWN0ID0gWydbb2JqZWN0IE51bWJlcl0nLCAnW29iamVjdCBGdW5jdGlvbl0nLCAnW29iamVjdCBSZWdFeHBdJ107XG4gICAgY29uc3Qgam9pbkFycmF5cyA9IG9wdGlvbnMuam9pbkFycmF5cyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5qb2luQXJyYXlzIDogdGhpcy5vcHRpb25zLmpvaW5BcnJheXM7XG4gICAgY29uc3QgaGFuZGxlQXNPYmplY3RJbkkxOG5Gb3JtYXQgPSAhdGhpcy5pMThuRm9ybWF0IHx8IHRoaXMuaTE4bkZvcm1hdC5oYW5kbGVBc09iamVjdDtcbiAgICBjb25zdCBoYW5kbGVBc09iamVjdCA9IHR5cGVvZiByZXMgIT09ICdzdHJpbmcnICYmIHR5cGVvZiByZXMgIT09ICdib29sZWFuJyAmJiB0eXBlb2YgcmVzICE9PSAnbnVtYmVyJztcbiAgICBpZiAoaGFuZGxlQXNPYmplY3RJbkkxOG5Gb3JtYXQgJiYgcmVzICYmIGhhbmRsZUFzT2JqZWN0ICYmIG5vT2JqZWN0LmluZGV4T2YocmVzVHlwZSkgPCAwICYmICEodHlwZW9mIGpvaW5BcnJheXMgPT09ICdzdHJpbmcnICYmIEFycmF5LmlzQXJyYXkocmVzKSkpIHtcbiAgICAgIGlmICghb3B0aW9ucy5yZXR1cm5PYmplY3RzICYmICF0aGlzLm9wdGlvbnMucmV0dXJuT2JqZWN0cykge1xuICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy5yZXR1cm5lZE9iamVjdEhhbmRsZXIpIHtcbiAgICAgICAgICB0aGlzLmxvZ2dlci53YXJuKCdhY2Nlc3NpbmcgYW4gb2JqZWN0IC0gYnV0IHJldHVybk9iamVjdHMgb3B0aW9ucyBpcyBub3QgZW5hYmxlZCEnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByID0gdGhpcy5vcHRpb25zLnJldHVybmVkT2JqZWN0SGFuZGxlciA/IHRoaXMub3B0aW9ucy5yZXR1cm5lZE9iamVjdEhhbmRsZXIocmVzVXNlZEtleSwgcmVzLCB7XG4gICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICBuczogbmFtZXNwYWNlc1xuICAgICAgICB9KSA6IGBrZXkgJyR7a2V5fSAoJHt0aGlzLmxhbmd1YWdlfSknIHJldHVybmVkIGFuIG9iamVjdCBpbnN0ZWFkIG9mIHN0cmluZy5gO1xuICAgICAgICBpZiAocmV0dXJuRGV0YWlscykge1xuICAgICAgICAgIHJlc29sdmVkLnJlcyA9IHI7XG4gICAgICAgICAgcmVzb2x2ZWQudXNlZFBhcmFtcyA9IHRoaXMuZ2V0VXNlZFBhcmFtc0RldGFpbHMob3B0aW9ucyk7XG4gICAgICAgICAgcmV0dXJuIHJlc29sdmVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByO1xuICAgICAgfVxuICAgICAgaWYgKGtleVNlcGFyYXRvcikge1xuICAgICAgICBjb25zdCByZXNUeXBlSXNBcnJheSA9IEFycmF5LmlzQXJyYXkocmVzKTtcbiAgICAgICAgY29uc3QgY29weSA9IHJlc1R5cGVJc0FycmF5ID8gW10gOiB7fTtcbiAgICAgICAgY29uc3QgbmV3S2V5VG9Vc2UgPSByZXNUeXBlSXNBcnJheSA/IHJlc0V4YWN0VXNlZEtleSA6IHJlc1VzZWRLZXk7XG4gICAgICAgIGZvciAoY29uc3QgbSBpbiByZXMpIHtcbiAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHJlcywgbSkpIHtcbiAgICAgICAgICAgIGNvbnN0IGRlZXBLZXkgPSBgJHtuZXdLZXlUb1VzZX0ke2tleVNlcGFyYXRvcn0ke219YDtcbiAgICAgICAgICAgIGNvcHlbbV0gPSB0aGlzLnRyYW5zbGF0ZShkZWVwS2V5LCB7XG4gICAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICAgIC4uLntcbiAgICAgICAgICAgICAgICBqb2luQXJyYXlzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBuczogbmFtZXNwYWNlc1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChjb3B5W21dID09PSBkZWVwS2V5KSBjb3B5W21dID0gcmVzW21dO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXMgPSBjb3B5O1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaGFuZGxlQXNPYmplY3RJbkkxOG5Gb3JtYXQgJiYgdHlwZW9mIGpvaW5BcnJheXMgPT09ICdzdHJpbmcnICYmIEFycmF5LmlzQXJyYXkocmVzKSkge1xuICAgICAgcmVzID0gcmVzLmpvaW4oam9pbkFycmF5cyk7XG4gICAgICBpZiAocmVzKSByZXMgPSB0aGlzLmV4dGVuZFRyYW5zbGF0aW9uKHJlcywga2V5cywgb3B0aW9ucywgbGFzdEtleSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCB1c2VkRGVmYXVsdCA9IGZhbHNlO1xuICAgICAgbGV0IHVzZWRLZXkgPSBmYWxzZTtcbiAgICAgIGNvbnN0IG5lZWRzUGx1cmFsSGFuZGxpbmcgPSBvcHRpb25zLmNvdW50ICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIG9wdGlvbnMuY291bnQgIT09ICdzdHJpbmcnO1xuICAgICAgY29uc3QgaGFzRGVmYXVsdFZhbHVlID0gVHJhbnNsYXRvci5oYXNEZWZhdWx0VmFsdWUob3B0aW9ucyk7XG4gICAgICBjb25zdCBkZWZhdWx0VmFsdWVTdWZmaXggPSBuZWVkc1BsdXJhbEhhbmRsaW5nID8gdGhpcy5wbHVyYWxSZXNvbHZlci5nZXRTdWZmaXgobG5nLCBvcHRpb25zLmNvdW50LCBvcHRpb25zKSA6ICcnO1xuICAgICAgY29uc3QgZGVmYXVsdFZhbHVlU3VmZml4T3JkaW5hbEZhbGxiYWNrID0gb3B0aW9ucy5vcmRpbmFsICYmIG5lZWRzUGx1cmFsSGFuZGxpbmcgPyB0aGlzLnBsdXJhbFJlc29sdmVyLmdldFN1ZmZpeChsbmcsIG9wdGlvbnMuY291bnQsIHtcbiAgICAgICAgb3JkaW5hbDogZmFsc2VcbiAgICAgIH0pIDogJyc7XG4gICAgICBjb25zdCBuZWVkc1plcm9TdWZmaXhMb29rdXAgPSBuZWVkc1BsdXJhbEhhbmRsaW5nICYmICFvcHRpb25zLm9yZGluYWwgJiYgb3B0aW9ucy5jb3VudCA9PT0gMCAmJiB0aGlzLnBsdXJhbFJlc29sdmVyLnNob3VsZFVzZUludGxBcGkoKTtcbiAgICAgIGNvbnN0IGRlZmF1bHRWYWx1ZSA9IG5lZWRzWmVyb1N1ZmZpeExvb2t1cCAmJiBvcHRpb25zW2BkZWZhdWx0VmFsdWUke3RoaXMub3B0aW9ucy5wbHVyYWxTZXBhcmF0b3J9emVyb2BdIHx8IG9wdGlvbnNbYGRlZmF1bHRWYWx1ZSR7ZGVmYXVsdFZhbHVlU3VmZml4fWBdIHx8IG9wdGlvbnNbYGRlZmF1bHRWYWx1ZSR7ZGVmYXVsdFZhbHVlU3VmZml4T3JkaW5hbEZhbGxiYWNrfWBdIHx8IG9wdGlvbnMuZGVmYXVsdFZhbHVlO1xuICAgICAgaWYgKCF0aGlzLmlzVmFsaWRMb29rdXAocmVzKSAmJiBoYXNEZWZhdWx0VmFsdWUpIHtcbiAgICAgICAgdXNlZERlZmF1bHQgPSB0cnVlO1xuICAgICAgICByZXMgPSBkZWZhdWx0VmFsdWU7XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMuaXNWYWxpZExvb2t1cChyZXMpKSB7XG4gICAgICAgIHVzZWRLZXkgPSB0cnVlO1xuICAgICAgICByZXMgPSBrZXk7XG4gICAgICB9XG4gICAgICBjb25zdCBtaXNzaW5nS2V5Tm9WYWx1ZUZhbGxiYWNrVG9LZXkgPSBvcHRpb25zLm1pc3NpbmdLZXlOb1ZhbHVlRmFsbGJhY2tUb0tleSB8fCB0aGlzLm9wdGlvbnMubWlzc2luZ0tleU5vVmFsdWVGYWxsYmFja1RvS2V5O1xuICAgICAgY29uc3QgcmVzRm9yTWlzc2luZyA9IG1pc3NpbmdLZXlOb1ZhbHVlRmFsbGJhY2tUb0tleSAmJiB1c2VkS2V5ID8gdW5kZWZpbmVkIDogcmVzO1xuICAgICAgY29uc3QgdXBkYXRlTWlzc2luZyA9IGhhc0RlZmF1bHRWYWx1ZSAmJiBkZWZhdWx0VmFsdWUgIT09IHJlcyAmJiB0aGlzLm9wdGlvbnMudXBkYXRlTWlzc2luZztcbiAgICAgIGlmICh1c2VkS2V5IHx8IHVzZWREZWZhdWx0IHx8IHVwZGF0ZU1pc3NpbmcpIHtcbiAgICAgICAgdGhpcy5sb2dnZXIubG9nKHVwZGF0ZU1pc3NpbmcgPyAndXBkYXRlS2V5JyA6ICdtaXNzaW5nS2V5JywgbG5nLCBuYW1lc3BhY2UsIGtleSwgdXBkYXRlTWlzc2luZyA/IGRlZmF1bHRWYWx1ZSA6IHJlcyk7XG4gICAgICAgIGlmIChrZXlTZXBhcmF0b3IpIHtcbiAgICAgICAgICBjb25zdCBmayA9IHRoaXMucmVzb2x2ZShrZXksIHtcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICBrZXlTZXBhcmF0b3I6IGZhbHNlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKGZrICYmIGZrLnJlcykgdGhpcy5sb2dnZXIud2FybignU2VlbXMgdGhlIGxvYWRlZCB0cmFuc2xhdGlvbnMgd2VyZSBpbiBmbGF0IEpTT04gZm9ybWF0IGluc3RlYWQgb2YgbmVzdGVkLiBFaXRoZXIgc2V0IGtleVNlcGFyYXRvcjogZmFsc2Ugb24gaW5pdCBvciBtYWtlIHN1cmUgeW91ciB0cmFuc2xhdGlvbnMgYXJlIHB1Ymxpc2hlZCBpbiBuZXN0ZWQgZm9ybWF0LicpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBsbmdzID0gW107XG4gICAgICAgIGNvbnN0IGZhbGxiYWNrTG5ncyA9IHRoaXMubGFuZ3VhZ2VVdGlscy5nZXRGYWxsYmFja0NvZGVzKHRoaXMub3B0aW9ucy5mYWxsYmFja0xuZywgb3B0aW9ucy5sbmcgfHwgdGhpcy5sYW5ndWFnZSk7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2F2ZU1pc3NpbmdUbyA9PT0gJ2ZhbGxiYWNrJyAmJiBmYWxsYmFja0xuZ3MgJiYgZmFsbGJhY2tMbmdzWzBdKSB7XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmYWxsYmFja0xuZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxuZ3MucHVzaChmYWxsYmFja0xuZ3NbaV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLm9wdGlvbnMuc2F2ZU1pc3NpbmdUbyA9PT0gJ2FsbCcpIHtcbiAgICAgICAgICBsbmdzID0gdGhpcy5sYW5ndWFnZVV0aWxzLnRvUmVzb2x2ZUhpZXJhcmNoeShvcHRpb25zLmxuZyB8fCB0aGlzLmxhbmd1YWdlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsbmdzLnB1c2gob3B0aW9ucy5sbmcgfHwgdGhpcy5sYW5ndWFnZSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2VuZCA9IChsLCBrLCBzcGVjaWZpY0RlZmF1bHRWYWx1ZSkgPT4ge1xuICAgICAgICAgIGNvbnN0IGRlZmF1bHRGb3JNaXNzaW5nID0gaGFzRGVmYXVsdFZhbHVlICYmIHNwZWNpZmljRGVmYXVsdFZhbHVlICE9PSByZXMgPyBzcGVjaWZpY0RlZmF1bHRWYWx1ZSA6IHJlc0Zvck1pc3Npbmc7XG4gICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5taXNzaW5nS2V5SGFuZGxlcikge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zLm1pc3NpbmdLZXlIYW5kbGVyKGwsIG5hbWVzcGFjZSwgaywgZGVmYXVsdEZvck1pc3NpbmcsIHVwZGF0ZU1pc3NpbmcsIG9wdGlvbnMpO1xuICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5iYWNrZW5kQ29ubmVjdG9yICYmIHRoaXMuYmFja2VuZENvbm5lY3Rvci5zYXZlTWlzc2luZykge1xuICAgICAgICAgICAgdGhpcy5iYWNrZW5kQ29ubmVjdG9yLnNhdmVNaXNzaW5nKGwsIG5hbWVzcGFjZSwgaywgZGVmYXVsdEZvck1pc3NpbmcsIHVwZGF0ZU1pc3NpbmcsIG9wdGlvbnMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmVtaXQoJ21pc3NpbmdLZXknLCBsLCBuYW1lc3BhY2UsIGssIHJlcyk7XG4gICAgICAgIH07XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2F2ZU1pc3NpbmcpIHtcbiAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnNhdmVNaXNzaW5nUGx1cmFscyAmJiBuZWVkc1BsdXJhbEhhbmRsaW5nKSB7XG4gICAgICAgICAgICBsbmdzLmZvckVhY2gobGFuZ3VhZ2UgPT4ge1xuICAgICAgICAgICAgICBjb25zdCBzdWZmaXhlcyA9IHRoaXMucGx1cmFsUmVzb2x2ZXIuZ2V0U3VmZml4ZXMobGFuZ3VhZ2UsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICBpZiAobmVlZHNaZXJvU3VmZml4TG9va3VwICYmIG9wdGlvbnNbYGRlZmF1bHRWYWx1ZSR7dGhpcy5vcHRpb25zLnBsdXJhbFNlcGFyYXRvcn16ZXJvYF0gJiYgc3VmZml4ZXMuaW5kZXhPZihgJHt0aGlzLm9wdGlvbnMucGx1cmFsU2VwYXJhdG9yfXplcm9gKSA8IDApIHtcbiAgICAgICAgICAgICAgICBzdWZmaXhlcy5wdXNoKGAke3RoaXMub3B0aW9ucy5wbHVyYWxTZXBhcmF0b3J9emVyb2ApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHN1ZmZpeGVzLmZvckVhY2goc3VmZml4ID0+IHtcbiAgICAgICAgICAgICAgICBzZW5kKFtsYW5ndWFnZV0sIGtleSArIHN1ZmZpeCwgb3B0aW9uc1tgZGVmYXVsdFZhbHVlJHtzdWZmaXh9YF0gfHwgZGVmYXVsdFZhbHVlKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2VuZChsbmdzLCBrZXksIGRlZmF1bHRWYWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXMgPSB0aGlzLmV4dGVuZFRyYW5zbGF0aW9uKHJlcywga2V5cywgb3B0aW9ucywgcmVzb2x2ZWQsIGxhc3RLZXkpO1xuICAgICAgaWYgKHVzZWRLZXkgJiYgcmVzID09PSBrZXkgJiYgdGhpcy5vcHRpb25zLmFwcGVuZE5hbWVzcGFjZVRvTWlzc2luZ0tleSkgcmVzID0gYCR7bmFtZXNwYWNlfToke2tleX1gO1xuICAgICAgaWYgKCh1c2VkS2V5IHx8IHVzZWREZWZhdWx0KSAmJiB0aGlzLm9wdGlvbnMucGFyc2VNaXNzaW5nS2V5SGFuZGxlcikge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmNvbXBhdGliaWxpdHlBUEkgIT09ICd2MScpIHtcbiAgICAgICAgICByZXMgPSB0aGlzLm9wdGlvbnMucGFyc2VNaXNzaW5nS2V5SGFuZGxlcih0aGlzLm9wdGlvbnMuYXBwZW5kTmFtZXNwYWNlVG9NaXNzaW5nS2V5ID8gYCR7bmFtZXNwYWNlfToke2tleX1gIDoga2V5LCB1c2VkRGVmYXVsdCA/IHJlcyA6IHVuZGVmaW5lZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzID0gdGhpcy5vcHRpb25zLnBhcnNlTWlzc2luZ0tleUhhbmRsZXIocmVzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAocmV0dXJuRGV0YWlscykge1xuICAgICAgcmVzb2x2ZWQucmVzID0gcmVzO1xuICAgICAgcmVzb2x2ZWQudXNlZFBhcmFtcyA9IHRoaXMuZ2V0VXNlZFBhcmFtc0RldGFpbHMob3B0aW9ucyk7XG4gICAgICByZXR1cm4gcmVzb2x2ZWQ7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG4gIH1cbiAgZXh0ZW5kVHJhbnNsYXRpb24ocmVzLCBrZXksIG9wdGlvbnMsIHJlc29sdmVkLCBsYXN0S2V5KSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICBpZiAodGhpcy5pMThuRm9ybWF0ICYmIHRoaXMuaTE4bkZvcm1hdC5wYXJzZSkge1xuICAgICAgcmVzID0gdGhpcy5pMThuRm9ybWF0LnBhcnNlKHJlcywge1xuICAgICAgICAuLi50aGlzLm9wdGlvbnMuaW50ZXJwb2xhdGlvbi5kZWZhdWx0VmFyaWFibGVzLFxuICAgICAgICAuLi5vcHRpb25zXG4gICAgICB9LCBvcHRpb25zLmxuZyB8fCB0aGlzLmxhbmd1YWdlIHx8IHJlc29sdmVkLnVzZWRMbmcsIHJlc29sdmVkLnVzZWROUywgcmVzb2x2ZWQudXNlZEtleSwge1xuICAgICAgICByZXNvbHZlZFxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmICghb3B0aW9ucy5za2lwSW50ZXJwb2xhdGlvbikge1xuICAgICAgaWYgKG9wdGlvbnMuaW50ZXJwb2xhdGlvbikgdGhpcy5pbnRlcnBvbGF0b3IuaW5pdCh7XG4gICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgIC4uLntcbiAgICAgICAgICBpbnRlcnBvbGF0aW9uOiB7XG4gICAgICAgICAgICAuLi50aGlzLm9wdGlvbnMuaW50ZXJwb2xhdGlvbixcbiAgICAgICAgICAgIC4uLm9wdGlvbnMuaW50ZXJwb2xhdGlvblxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBjb25zdCBza2lwT25WYXJpYWJsZXMgPSB0eXBlb2YgcmVzID09PSAnc3RyaW5nJyAmJiAob3B0aW9ucyAmJiBvcHRpb25zLmludGVycG9sYXRpb24gJiYgb3B0aW9ucy5pbnRlcnBvbGF0aW9uLnNraXBPblZhcmlhYmxlcyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5pbnRlcnBvbGF0aW9uLnNraXBPblZhcmlhYmxlcyA6IHRoaXMub3B0aW9ucy5pbnRlcnBvbGF0aW9uLnNraXBPblZhcmlhYmxlcyk7XG4gICAgICBsZXQgbmVzdEJlZjtcbiAgICAgIGlmIChza2lwT25WYXJpYWJsZXMpIHtcbiAgICAgICAgY29uc3QgbmIgPSByZXMubWF0Y2godGhpcy5pbnRlcnBvbGF0b3IubmVzdGluZ1JlZ2V4cCk7XG4gICAgICAgIG5lc3RCZWYgPSBuYiAmJiBuYi5sZW5ndGg7XG4gICAgICB9XG4gICAgICBsZXQgZGF0YSA9IG9wdGlvbnMucmVwbGFjZSAmJiB0eXBlb2Ygb3B0aW9ucy5yZXBsYWNlICE9PSAnc3RyaW5nJyA/IG9wdGlvbnMucmVwbGFjZSA6IG9wdGlvbnM7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmludGVycG9sYXRpb24uZGVmYXVsdFZhcmlhYmxlcykgZGF0YSA9IHtcbiAgICAgICAgLi4udGhpcy5vcHRpb25zLmludGVycG9sYXRpb24uZGVmYXVsdFZhcmlhYmxlcyxcbiAgICAgICAgLi4uZGF0YVxuICAgICAgfTtcbiAgICAgIHJlcyA9IHRoaXMuaW50ZXJwb2xhdG9yLmludGVycG9sYXRlKHJlcywgZGF0YSwgb3B0aW9ucy5sbmcgfHwgdGhpcy5sYW5ndWFnZSB8fCByZXNvbHZlZC51c2VkTG5nLCBvcHRpb25zKTtcbiAgICAgIGlmIChza2lwT25WYXJpYWJsZXMpIHtcbiAgICAgICAgY29uc3QgbmEgPSByZXMubWF0Y2godGhpcy5pbnRlcnBvbGF0b3IubmVzdGluZ1JlZ2V4cCk7XG4gICAgICAgIGNvbnN0IG5lc3RBZnQgPSBuYSAmJiBuYS5sZW5ndGg7XG4gICAgICAgIGlmIChuZXN0QmVmIDwgbmVzdEFmdCkgb3B0aW9ucy5uZXN0ID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoIW9wdGlvbnMubG5nICYmIHRoaXMub3B0aW9ucy5jb21wYXRpYmlsaXR5QVBJICE9PSAndjEnICYmIHJlc29sdmVkICYmIHJlc29sdmVkLnJlcykgb3B0aW9ucy5sbmcgPSB0aGlzLmxhbmd1YWdlIHx8IHJlc29sdmVkLnVzZWRMbmc7XG4gICAgICBpZiAob3B0aW9ucy5uZXN0ICE9PSBmYWxzZSkgcmVzID0gdGhpcy5pbnRlcnBvbGF0b3IubmVzdChyZXMsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGFzdEtleSAmJiBsYXN0S2V5WzBdID09PSBhcmdzWzBdICYmICFvcHRpb25zLmNvbnRleHQpIHtcbiAgICAgICAgICBfdGhpcy5sb2dnZXIud2FybihgSXQgc2VlbXMgeW91IGFyZSBuZXN0aW5nIHJlY3Vyc2l2ZWx5IGtleTogJHthcmdzWzBdfSBpbiBrZXk6ICR7a2V5WzBdfWApO1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfdGhpcy50cmFuc2xhdGUoLi4uYXJncywga2V5KTtcbiAgICAgIH0sIG9wdGlvbnMpO1xuICAgICAgaWYgKG9wdGlvbnMuaW50ZXJwb2xhdGlvbikgdGhpcy5pbnRlcnBvbGF0b3IucmVzZXQoKTtcbiAgICB9XG4gICAgY29uc3QgcG9zdFByb2Nlc3MgPSBvcHRpb25zLnBvc3RQcm9jZXNzIHx8IHRoaXMub3B0aW9ucy5wb3N0UHJvY2VzcztcbiAgICBjb25zdCBwb3N0UHJvY2Vzc29yTmFtZXMgPSB0eXBlb2YgcG9zdFByb2Nlc3MgPT09ICdzdHJpbmcnID8gW3Bvc3RQcm9jZXNzXSA6IHBvc3RQcm9jZXNzO1xuICAgIGlmIChyZXMgIT09IHVuZGVmaW5lZCAmJiByZXMgIT09IG51bGwgJiYgcG9zdFByb2Nlc3Nvck5hbWVzICYmIHBvc3RQcm9jZXNzb3JOYW1lcy5sZW5ndGggJiYgb3B0aW9ucy5hcHBseVBvc3RQcm9jZXNzb3IgIT09IGZhbHNlKSB7XG4gICAgICByZXMgPSBwb3N0UHJvY2Vzc29yLmhhbmRsZShwb3N0UHJvY2Vzc29yTmFtZXMsIHJlcywga2V5LCB0aGlzLm9wdGlvbnMgJiYgdGhpcy5vcHRpb25zLnBvc3RQcm9jZXNzUGFzc1Jlc29sdmVkID8ge1xuICAgICAgICBpMThuUmVzb2x2ZWQ6IHtcbiAgICAgICAgICAuLi5yZXNvbHZlZCxcbiAgICAgICAgICB1c2VkUGFyYW1zOiB0aGlzLmdldFVzZWRQYXJhbXNEZXRhaWxzKG9wdGlvbnMpXG4gICAgICAgIH0sXG4gICAgICAgIC4uLm9wdGlvbnNcbiAgICAgIH0gOiBvcHRpb25zLCB0aGlzKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbiAgfVxuICByZXNvbHZlKGtleXMpIHtcbiAgICBsZXQgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgbGV0IGZvdW5kO1xuICAgIGxldCB1c2VkS2V5O1xuICAgIGxldCBleGFjdFVzZWRLZXk7XG4gICAgbGV0IHVzZWRMbmc7XG4gICAgbGV0IHVzZWROUztcbiAgICBpZiAodHlwZW9mIGtleXMgPT09ICdzdHJpbmcnKSBrZXlzID0gW2tleXNdO1xuICAgIGtleXMuZm9yRWFjaChrID0+IHtcbiAgICAgIGlmICh0aGlzLmlzVmFsaWRMb29rdXAoZm91bmQpKSByZXR1cm47XG4gICAgICBjb25zdCBleHRyYWN0ZWQgPSB0aGlzLmV4dHJhY3RGcm9tS2V5KGssIG9wdGlvbnMpO1xuICAgICAgY29uc3Qga2V5ID0gZXh0cmFjdGVkLmtleTtcbiAgICAgIHVzZWRLZXkgPSBrZXk7XG4gICAgICBsZXQgbmFtZXNwYWNlcyA9IGV4dHJhY3RlZC5uYW1lc3BhY2VzO1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5mYWxsYmFja05TKSBuYW1lc3BhY2VzID0gbmFtZXNwYWNlcy5jb25jYXQodGhpcy5vcHRpb25zLmZhbGxiYWNrTlMpO1xuICAgICAgY29uc3QgbmVlZHNQbHVyYWxIYW5kbGluZyA9IG9wdGlvbnMuY291bnQgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygb3B0aW9ucy5jb3VudCAhPT0gJ3N0cmluZyc7XG4gICAgICBjb25zdCBuZWVkc1plcm9TdWZmaXhMb29rdXAgPSBuZWVkc1BsdXJhbEhhbmRsaW5nICYmICFvcHRpb25zLm9yZGluYWwgJiYgb3B0aW9ucy5jb3VudCA9PT0gMCAmJiB0aGlzLnBsdXJhbFJlc29sdmVyLnNob3VsZFVzZUludGxBcGkoKTtcbiAgICAgIGNvbnN0IG5lZWRzQ29udGV4dEhhbmRsaW5nID0gb3B0aW9ucy5jb250ZXh0ICE9PSB1bmRlZmluZWQgJiYgKHR5cGVvZiBvcHRpb25zLmNvbnRleHQgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBvcHRpb25zLmNvbnRleHQgPT09ICdudW1iZXInKSAmJiBvcHRpb25zLmNvbnRleHQgIT09ICcnO1xuICAgICAgY29uc3QgY29kZXMgPSBvcHRpb25zLmxuZ3MgPyBvcHRpb25zLmxuZ3MgOiB0aGlzLmxhbmd1YWdlVXRpbHMudG9SZXNvbHZlSGllcmFyY2h5KG9wdGlvbnMubG5nIHx8IHRoaXMubGFuZ3VhZ2UsIG9wdGlvbnMuZmFsbGJhY2tMbmcpO1xuICAgICAgbmFtZXNwYWNlcy5mb3JFYWNoKG5zID0+IHtcbiAgICAgICAgaWYgKHRoaXMuaXNWYWxpZExvb2t1cChmb3VuZCkpIHJldHVybjtcbiAgICAgICAgdXNlZE5TID0gbnM7XG4gICAgICAgIGlmICghY2hlY2tlZExvYWRlZEZvcltgJHtjb2Rlc1swXX0tJHtuc31gXSAmJiB0aGlzLnV0aWxzICYmIHRoaXMudXRpbHMuaGFzTG9hZGVkTmFtZXNwYWNlICYmICF0aGlzLnV0aWxzLmhhc0xvYWRlZE5hbWVzcGFjZSh1c2VkTlMpKSB7XG4gICAgICAgICAgY2hlY2tlZExvYWRlZEZvcltgJHtjb2Rlc1swXX0tJHtuc31gXSA9IHRydWU7XG4gICAgICAgICAgdGhpcy5sb2dnZXIud2Fybihga2V5IFwiJHt1c2VkS2V5fVwiIGZvciBsYW5ndWFnZXMgXCIke2NvZGVzLmpvaW4oJywgJyl9XCIgd29uJ3QgZ2V0IHJlc29sdmVkIGFzIG5hbWVzcGFjZSBcIiR7dXNlZE5TfVwiIHdhcyBub3QgeWV0IGxvYWRlZGAsICdUaGlzIG1lYW5zIHNvbWV0aGluZyBJUyBXUk9ORyBpbiB5b3VyIHNldHVwLiBZb3UgYWNjZXNzIHRoZSB0IGZ1bmN0aW9uIGJlZm9yZSBpMThuZXh0LmluaXQgLyBpMThuZXh0LmxvYWROYW1lc3BhY2UgLyBpMThuZXh0LmNoYW5nZUxhbmd1YWdlIHdhcyBkb25lLiBXYWl0IGZvciB0aGUgY2FsbGJhY2sgb3IgUHJvbWlzZSB0byByZXNvbHZlIGJlZm9yZSBhY2Nlc3NpbmcgaXQhISEnKTtcbiAgICAgICAgfVxuICAgICAgICBjb2Rlcy5mb3JFYWNoKGNvZGUgPT4ge1xuICAgICAgICAgIGlmICh0aGlzLmlzVmFsaWRMb29rdXAoZm91bmQpKSByZXR1cm47XG4gICAgICAgICAgdXNlZExuZyA9IGNvZGU7XG4gICAgICAgICAgY29uc3QgZmluYWxLZXlzID0gW2tleV07XG4gICAgICAgICAgaWYgKHRoaXMuaTE4bkZvcm1hdCAmJiB0aGlzLmkxOG5Gb3JtYXQuYWRkTG9va3VwS2V5cykge1xuICAgICAgICAgICAgdGhpcy5pMThuRm9ybWF0LmFkZExvb2t1cEtleXMoZmluYWxLZXlzLCBrZXksIGNvZGUsIG5zLCBvcHRpb25zKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGV0IHBsdXJhbFN1ZmZpeDtcbiAgICAgICAgICAgIGlmIChuZWVkc1BsdXJhbEhhbmRsaW5nKSBwbHVyYWxTdWZmaXggPSB0aGlzLnBsdXJhbFJlc29sdmVyLmdldFN1ZmZpeChjb2RlLCBvcHRpb25zLmNvdW50LCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IHplcm9TdWZmaXggPSBgJHt0aGlzLm9wdGlvbnMucGx1cmFsU2VwYXJhdG9yfXplcm9gO1xuICAgICAgICAgICAgY29uc3Qgb3JkaW5hbFByZWZpeCA9IGAke3RoaXMub3B0aW9ucy5wbHVyYWxTZXBhcmF0b3J9b3JkaW5hbCR7dGhpcy5vcHRpb25zLnBsdXJhbFNlcGFyYXRvcn1gO1xuICAgICAgICAgICAgaWYgKG5lZWRzUGx1cmFsSGFuZGxpbmcpIHtcbiAgICAgICAgICAgICAgZmluYWxLZXlzLnB1c2goa2V5ICsgcGx1cmFsU3VmZml4KTtcbiAgICAgICAgICAgICAgaWYgKG9wdGlvbnMub3JkaW5hbCAmJiBwbHVyYWxTdWZmaXguaW5kZXhPZihvcmRpbmFsUHJlZml4KSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGZpbmFsS2V5cy5wdXNoKGtleSArIHBsdXJhbFN1ZmZpeC5yZXBsYWNlKG9yZGluYWxQcmVmaXgsIHRoaXMub3B0aW9ucy5wbHVyYWxTZXBhcmF0b3IpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAobmVlZHNaZXJvU3VmZml4TG9va3VwKSB7XG4gICAgICAgICAgICAgICAgZmluYWxLZXlzLnB1c2goa2V5ICsgemVyb1N1ZmZpeCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuZWVkc0NvbnRleHRIYW5kbGluZykge1xuICAgICAgICAgICAgICBjb25zdCBjb250ZXh0S2V5ID0gYCR7a2V5fSR7dGhpcy5vcHRpb25zLmNvbnRleHRTZXBhcmF0b3J9JHtvcHRpb25zLmNvbnRleHR9YDtcbiAgICAgICAgICAgICAgZmluYWxLZXlzLnB1c2goY29udGV4dEtleSk7XG4gICAgICAgICAgICAgIGlmIChuZWVkc1BsdXJhbEhhbmRsaW5nKSB7XG4gICAgICAgICAgICAgICAgZmluYWxLZXlzLnB1c2goY29udGV4dEtleSArIHBsdXJhbFN1ZmZpeCk7XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMub3JkaW5hbCAmJiBwbHVyYWxTdWZmaXguaW5kZXhPZihvcmRpbmFsUHJlZml4KSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgZmluYWxLZXlzLnB1c2goY29udGV4dEtleSArIHBsdXJhbFN1ZmZpeC5yZXBsYWNlKG9yZGluYWxQcmVmaXgsIHRoaXMub3B0aW9ucy5wbHVyYWxTZXBhcmF0b3IpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG5lZWRzWmVyb1N1ZmZpeExvb2t1cCkge1xuICAgICAgICAgICAgICAgICAgZmluYWxLZXlzLnB1c2goY29udGV4dEtleSArIHplcm9TdWZmaXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBsZXQgcG9zc2libGVLZXk7XG4gICAgICAgICAgd2hpbGUgKHBvc3NpYmxlS2V5ID0gZmluYWxLZXlzLnBvcCgpKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZExvb2t1cChmb3VuZCkpIHtcbiAgICAgICAgICAgICAgZXhhY3RVc2VkS2V5ID0gcG9zc2libGVLZXk7XG4gICAgICAgICAgICAgIGZvdW5kID0gdGhpcy5nZXRSZXNvdXJjZShjb2RlLCBucywgcG9zc2libGVLZXksIG9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgcmVzOiBmb3VuZCxcbiAgICAgIHVzZWRLZXksXG4gICAgICBleGFjdFVzZWRLZXksXG4gICAgICB1c2VkTG5nLFxuICAgICAgdXNlZE5TXG4gICAgfTtcbiAgfVxuICBpc1ZhbGlkTG9va3VwKHJlcykge1xuICAgIHJldHVybiByZXMgIT09IHVuZGVmaW5lZCAmJiAhKCF0aGlzLm9wdGlvbnMucmV0dXJuTnVsbCAmJiByZXMgPT09IG51bGwpICYmICEoIXRoaXMub3B0aW9ucy5yZXR1cm5FbXB0eVN0cmluZyAmJiByZXMgPT09ICcnKTtcbiAgfVxuICBnZXRSZXNvdXJjZShjb2RlLCBucywga2V5KSB7XG4gICAgbGV0IG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IHt9O1xuICAgIGlmICh0aGlzLmkxOG5Gb3JtYXQgJiYgdGhpcy5pMThuRm9ybWF0LmdldFJlc291cmNlKSByZXR1cm4gdGhpcy5pMThuRm9ybWF0LmdldFJlc291cmNlKGNvZGUsIG5zLCBrZXksIG9wdGlvbnMpO1xuICAgIHJldHVybiB0aGlzLnJlc291cmNlU3RvcmUuZ2V0UmVzb3VyY2UoY29kZSwgbnMsIGtleSwgb3B0aW9ucyk7XG4gIH1cbiAgZ2V0VXNlZFBhcmFtc0RldGFpbHMoKSB7XG4gICAgbGV0IG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgIGNvbnN0IG9wdGlvbnNLZXlzID0gWydkZWZhdWx0VmFsdWUnLCAnb3JkaW5hbCcsICdjb250ZXh0JywgJ3JlcGxhY2UnLCAnbG5nJywgJ2xuZ3MnLCAnZmFsbGJhY2tMbmcnLCAnbnMnLCAna2V5U2VwYXJhdG9yJywgJ25zU2VwYXJhdG9yJywgJ3JldHVybk9iamVjdHMnLCAncmV0dXJuRGV0YWlscycsICdqb2luQXJyYXlzJywgJ3Bvc3RQcm9jZXNzJywgJ2ludGVycG9sYXRpb24nXTtcbiAgICBjb25zdCB1c2VPcHRpb25zUmVwbGFjZUZvckRhdGEgPSBvcHRpb25zLnJlcGxhY2UgJiYgdHlwZW9mIG9wdGlvbnMucmVwbGFjZSAhPT0gJ3N0cmluZyc7XG4gICAgbGV0IGRhdGEgPSB1c2VPcHRpb25zUmVwbGFjZUZvckRhdGEgPyBvcHRpb25zLnJlcGxhY2UgOiBvcHRpb25zO1xuICAgIGlmICh1c2VPcHRpb25zUmVwbGFjZUZvckRhdGEgJiYgdHlwZW9mIG9wdGlvbnMuY291bnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBkYXRhLmNvdW50ID0gb3B0aW9ucy5jb3VudDtcbiAgICB9XG4gICAgaWYgKHRoaXMub3B0aW9ucy5pbnRlcnBvbGF0aW9uLmRlZmF1bHRWYXJpYWJsZXMpIHtcbiAgICAgIGRhdGEgPSB7XG4gICAgICAgIC4uLnRoaXMub3B0aW9ucy5pbnRlcnBvbGF0aW9uLmRlZmF1bHRWYXJpYWJsZXMsXG4gICAgICAgIC4uLmRhdGFcbiAgICAgIH07XG4gICAgfVxuICAgIGlmICghdXNlT3B0aW9uc1JlcGxhY2VGb3JEYXRhKSB7XG4gICAgICBkYXRhID0ge1xuICAgICAgICAuLi5kYXRhXG4gICAgICB9O1xuICAgICAgZm9yIChjb25zdCBrZXkgb2Ygb3B0aW9uc0tleXMpIHtcbiAgICAgICAgZGVsZXRlIGRhdGFba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cbiAgc3RhdGljIGhhc0RlZmF1bHRWYWx1ZShvcHRpb25zKSB7XG4gICAgY29uc3QgcHJlZml4ID0gJ2RlZmF1bHRWYWx1ZSc7XG4gICAgZm9yIChjb25zdCBvcHRpb24gaW4gb3B0aW9ucykge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvcHRpb25zLCBvcHRpb24pICYmIHByZWZpeCA9PT0gb3B0aW9uLnN1YnN0cmluZygwLCBwcmVmaXgubGVuZ3RoKSAmJiB1bmRlZmluZWQgIT09IG9wdGlvbnNbb3B0aW9uXSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNhcGl0YWxpemUoc3RyaW5nKSB7XG4gIHJldHVybiBzdHJpbmcuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzdHJpbmcuc2xpY2UoMSk7XG59XG5jbGFzcyBMYW5ndWFnZVV0aWwge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLnN1cHBvcnRlZExuZ3MgPSB0aGlzLm9wdGlvbnMuc3VwcG9ydGVkTG5ncyB8fCBmYWxzZTtcbiAgICB0aGlzLmxvZ2dlciA9IGJhc2VMb2dnZXIuY3JlYXRlKCdsYW5ndWFnZVV0aWxzJyk7XG4gIH1cbiAgZ2V0U2NyaXB0UGFydEZyb21Db2RlKGNvZGUpIHtcbiAgICBjb2RlID0gZ2V0Q2xlYW5lZENvZGUoY29kZSk7XG4gICAgaWYgKCFjb2RlIHx8IGNvZGUuaW5kZXhPZignLScpIDwgMCkgcmV0dXJuIG51bGw7XG4gICAgY29uc3QgcCA9IGNvZGUuc3BsaXQoJy0nKTtcbiAgICBpZiAocC5sZW5ndGggPT09IDIpIHJldHVybiBudWxsO1xuICAgIHAucG9wKCk7XG4gICAgaWYgKHBbcC5sZW5ndGggLSAxXS50b0xvd2VyQ2FzZSgpID09PSAneCcpIHJldHVybiBudWxsO1xuICAgIHJldHVybiB0aGlzLmZvcm1hdExhbmd1YWdlQ29kZShwLmpvaW4oJy0nKSk7XG4gIH1cbiAgZ2V0TGFuZ3VhZ2VQYXJ0RnJvbUNvZGUoY29kZSkge1xuICAgIGNvZGUgPSBnZXRDbGVhbmVkQ29kZShjb2RlKTtcbiAgICBpZiAoIWNvZGUgfHwgY29kZS5pbmRleE9mKCctJykgPCAwKSByZXR1cm4gY29kZTtcbiAgICBjb25zdCBwID0gY29kZS5zcGxpdCgnLScpO1xuICAgIHJldHVybiB0aGlzLmZvcm1hdExhbmd1YWdlQ29kZShwWzBdKTtcbiAgfVxuICBmb3JtYXRMYW5ndWFnZUNvZGUoY29kZSkge1xuICAgIGlmICh0eXBlb2YgY29kZSA9PT0gJ3N0cmluZycgJiYgY29kZS5pbmRleE9mKCctJykgPiAtMSkge1xuICAgICAgY29uc3Qgc3BlY2lhbENhc2VzID0gWydoYW5zJywgJ2hhbnQnLCAnbGF0bicsICdjeXJsJywgJ2NhbnMnLCAnbW9uZycsICdhcmFiJ107XG4gICAgICBsZXQgcCA9IGNvZGUuc3BsaXQoJy0nKTtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMubG93ZXJDYXNlTG5nKSB7XG4gICAgICAgIHAgPSBwLm1hcChwYXJ0ID0+IHBhcnQudG9Mb3dlckNhc2UoKSk7XG4gICAgICB9IGVsc2UgaWYgKHAubGVuZ3RoID09PSAyKSB7XG4gICAgICAgIHBbMF0gPSBwWzBdLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHBbMV0gPSBwWzFdLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgIGlmIChzcGVjaWFsQ2FzZXMuaW5kZXhPZihwWzFdLnRvTG93ZXJDYXNlKCkpID4gLTEpIHBbMV0gPSBjYXBpdGFsaXplKHBbMV0udG9Mb3dlckNhc2UoKSk7XG4gICAgICB9IGVsc2UgaWYgKHAubGVuZ3RoID09PSAzKSB7XG4gICAgICAgIHBbMF0gPSBwWzBdLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmIChwWzFdLmxlbmd0aCA9PT0gMikgcFsxXSA9IHBbMV0udG9VcHBlckNhc2UoKTtcbiAgICAgICAgaWYgKHBbMF0gIT09ICdzZ24nICYmIHBbMl0ubGVuZ3RoID09PSAyKSBwWzJdID0gcFsyXS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICBpZiAoc3BlY2lhbENhc2VzLmluZGV4T2YocFsxXS50b0xvd2VyQ2FzZSgpKSA+IC0xKSBwWzFdID0gY2FwaXRhbGl6ZShwWzFdLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgICBpZiAoc3BlY2lhbENhc2VzLmluZGV4T2YocFsyXS50b0xvd2VyQ2FzZSgpKSA+IC0xKSBwWzJdID0gY2FwaXRhbGl6ZShwWzJdLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHAuam9pbignLScpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5vcHRpb25zLmNsZWFuQ29kZSB8fCB0aGlzLm9wdGlvbnMubG93ZXJDYXNlTG5nID8gY29kZS50b0xvd2VyQ2FzZSgpIDogY29kZTtcbiAgfVxuICBpc1N1cHBvcnRlZENvZGUoY29kZSkge1xuICAgIGlmICh0aGlzLm9wdGlvbnMubG9hZCA9PT0gJ2xhbmd1YWdlT25seScgfHwgdGhpcy5vcHRpb25zLm5vbkV4cGxpY2l0U3VwcG9ydGVkTG5ncykge1xuICAgICAgY29kZSA9IHRoaXMuZ2V0TGFuZ3VhZ2VQYXJ0RnJvbUNvZGUoY29kZSk7XG4gICAgfVxuICAgIHJldHVybiAhdGhpcy5zdXBwb3J0ZWRMbmdzIHx8ICF0aGlzLnN1cHBvcnRlZExuZ3MubGVuZ3RoIHx8IHRoaXMuc3VwcG9ydGVkTG5ncy5pbmRleE9mKGNvZGUpID4gLTE7XG4gIH1cbiAgZ2V0QmVzdE1hdGNoRnJvbUNvZGVzKGNvZGVzKSB7XG4gICAgaWYgKCFjb2RlcykgcmV0dXJuIG51bGw7XG4gICAgbGV0IGZvdW5kO1xuICAgIGNvZGVzLmZvckVhY2goY29kZSA9PiB7XG4gICAgICBpZiAoZm91bmQpIHJldHVybjtcbiAgICAgIGNvbnN0IGNsZWFuZWRMbmcgPSB0aGlzLmZvcm1hdExhbmd1YWdlQ29kZShjb2RlKTtcbiAgICAgIGlmICghdGhpcy5vcHRpb25zLnN1cHBvcnRlZExuZ3MgfHwgdGhpcy5pc1N1cHBvcnRlZENvZGUoY2xlYW5lZExuZykpIGZvdW5kID0gY2xlYW5lZExuZztcbiAgICB9KTtcbiAgICBpZiAoIWZvdW5kICYmIHRoaXMub3B0aW9ucy5zdXBwb3J0ZWRMbmdzKSB7XG4gICAgICBjb2Rlcy5mb3JFYWNoKGNvZGUgPT4ge1xuICAgICAgICBpZiAoZm91bmQpIHJldHVybjtcbiAgICAgICAgY29uc3QgbG5nT25seSA9IHRoaXMuZ2V0TGFuZ3VhZ2VQYXJ0RnJvbUNvZGUoY29kZSk7XG4gICAgICAgIGlmICh0aGlzLmlzU3VwcG9ydGVkQ29kZShsbmdPbmx5KSkgcmV0dXJuIGZvdW5kID0gbG5nT25seTtcbiAgICAgICAgZm91bmQgPSB0aGlzLm9wdGlvbnMuc3VwcG9ydGVkTG5ncy5maW5kKHN1cHBvcnRlZExuZyA9PiB7XG4gICAgICAgICAgaWYgKHN1cHBvcnRlZExuZyA9PT0gbG5nT25seSkgcmV0dXJuIHN1cHBvcnRlZExuZztcbiAgICAgICAgICBpZiAoc3VwcG9ydGVkTG5nLmluZGV4T2YoJy0nKSA8IDAgJiYgbG5nT25seS5pbmRleE9mKCctJykgPCAwKSByZXR1cm47XG4gICAgICAgICAgaWYgKHN1cHBvcnRlZExuZy5pbmRleE9mKCctJykgPiAwICYmIGxuZ09ubHkuaW5kZXhPZignLScpIDwgMCAmJiBzdXBwb3J0ZWRMbmcuc3Vic3RyaW5nKDAsIHN1cHBvcnRlZExuZy5pbmRleE9mKCctJykpID09PSBsbmdPbmx5KSByZXR1cm4gc3VwcG9ydGVkTG5nO1xuICAgICAgICAgIGlmIChzdXBwb3J0ZWRMbmcuaW5kZXhPZihsbmdPbmx5KSA9PT0gMCAmJiBsbmdPbmx5Lmxlbmd0aCA+IDEpIHJldHVybiBzdXBwb3J0ZWRMbmc7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGlmICghZm91bmQpIGZvdW5kID0gdGhpcy5nZXRGYWxsYmFja0NvZGVzKHRoaXMub3B0aW9ucy5mYWxsYmFja0xuZylbMF07XG4gICAgcmV0dXJuIGZvdW5kO1xuICB9XG4gIGdldEZhbGxiYWNrQ29kZXMoZmFsbGJhY2tzLCBjb2RlKSB7XG4gICAgaWYgKCFmYWxsYmFja3MpIHJldHVybiBbXTtcbiAgICBpZiAodHlwZW9mIGZhbGxiYWNrcyA9PT0gJ2Z1bmN0aW9uJykgZmFsbGJhY2tzID0gZmFsbGJhY2tzKGNvZGUpO1xuICAgIGlmICh0eXBlb2YgZmFsbGJhY2tzID09PSAnc3RyaW5nJykgZmFsbGJhY2tzID0gW2ZhbGxiYWNrc107XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZmFsbGJhY2tzKSkgcmV0dXJuIGZhbGxiYWNrcztcbiAgICBpZiAoIWNvZGUpIHJldHVybiBmYWxsYmFja3MuZGVmYXVsdCB8fCBbXTtcbiAgICBsZXQgZm91bmQgPSBmYWxsYmFja3NbY29kZV07XG4gICAgaWYgKCFmb3VuZCkgZm91bmQgPSBmYWxsYmFja3NbdGhpcy5nZXRTY3JpcHRQYXJ0RnJvbUNvZGUoY29kZSldO1xuICAgIGlmICghZm91bmQpIGZvdW5kID0gZmFsbGJhY2tzW3RoaXMuZm9ybWF0TGFuZ3VhZ2VDb2RlKGNvZGUpXTtcbiAgICBpZiAoIWZvdW5kKSBmb3VuZCA9IGZhbGxiYWNrc1t0aGlzLmdldExhbmd1YWdlUGFydEZyb21Db2RlKGNvZGUpXTtcbiAgICBpZiAoIWZvdW5kKSBmb3VuZCA9IGZhbGxiYWNrcy5kZWZhdWx0O1xuICAgIHJldHVybiBmb3VuZCB8fCBbXTtcbiAgfVxuICB0b1Jlc29sdmVIaWVyYXJjaHkoY29kZSwgZmFsbGJhY2tDb2RlKSB7XG4gICAgY29uc3QgZmFsbGJhY2tDb2RlcyA9IHRoaXMuZ2V0RmFsbGJhY2tDb2RlcyhmYWxsYmFja0NvZGUgfHwgdGhpcy5vcHRpb25zLmZhbGxiYWNrTG5nIHx8IFtdLCBjb2RlKTtcbiAgICBjb25zdCBjb2RlcyA9IFtdO1xuICAgIGNvbnN0IGFkZENvZGUgPSBjID0+IHtcbiAgICAgIGlmICghYykgcmV0dXJuO1xuICAgICAgaWYgKHRoaXMuaXNTdXBwb3J0ZWRDb2RlKGMpKSB7XG4gICAgICAgIGNvZGVzLnB1c2goYyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmxvZ2dlci53YXJuKGByZWplY3RpbmcgbGFuZ3VhZ2UgY29kZSBub3QgZm91bmQgaW4gc3VwcG9ydGVkTG5nczogJHtjfWApO1xuICAgICAgfVxuICAgIH07XG4gICAgaWYgKHR5cGVvZiBjb2RlID09PSAnc3RyaW5nJyAmJiAoY29kZS5pbmRleE9mKCctJykgPiAtMSB8fCBjb2RlLmluZGV4T2YoJ18nKSA+IC0xKSkge1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5sb2FkICE9PSAnbGFuZ3VhZ2VPbmx5JykgYWRkQ29kZSh0aGlzLmZvcm1hdExhbmd1YWdlQ29kZShjb2RlKSk7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmxvYWQgIT09ICdsYW5ndWFnZU9ubHknICYmIHRoaXMub3B0aW9ucy5sb2FkICE9PSAnY3VycmVudE9ubHknKSBhZGRDb2RlKHRoaXMuZ2V0U2NyaXB0UGFydEZyb21Db2RlKGNvZGUpKTtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMubG9hZCAhPT0gJ2N1cnJlbnRPbmx5JykgYWRkQ29kZSh0aGlzLmdldExhbmd1YWdlUGFydEZyb21Db2RlKGNvZGUpKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBjb2RlID09PSAnc3RyaW5nJykge1xuICAgICAgYWRkQ29kZSh0aGlzLmZvcm1hdExhbmd1YWdlQ29kZShjb2RlKSk7XG4gICAgfVxuICAgIGZhbGxiYWNrQ29kZXMuZm9yRWFjaChmYyA9PiB7XG4gICAgICBpZiAoY29kZXMuaW5kZXhPZihmYykgPCAwKSBhZGRDb2RlKHRoaXMuZm9ybWF0TGFuZ3VhZ2VDb2RlKGZjKSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGNvZGVzO1xuICB9XG59XG5cbmxldCBzZXRzID0gW3tcbiAgbG5nczogWydhY2gnLCAnYWsnLCAnYW0nLCAnYXJuJywgJ2JyJywgJ2ZpbCcsICdndW4nLCAnbG4nLCAnbWZlJywgJ21nJywgJ21pJywgJ29jJywgJ3B0JywgJ3B0LUJSJywgJ3RnJywgJ3RsJywgJ3RpJywgJ3RyJywgJ3V6JywgJ3dhJ10sXG4gIG5yOiBbMSwgMl0sXG4gIGZjOiAxXG59LCB7XG4gIGxuZ3M6IFsnYWYnLCAnYW4nLCAnYXN0JywgJ2F6JywgJ2JnJywgJ2JuJywgJ2NhJywgJ2RhJywgJ2RlJywgJ2RldicsICdlbCcsICdlbicsICdlbycsICdlcycsICdldCcsICdldScsICdmaScsICdmbycsICdmdXInLCAnZnknLCAnZ2wnLCAnZ3UnLCAnaGEnLCAnaGknLCAnaHUnLCAnaHknLCAnaWEnLCAnaXQnLCAna2snLCAna24nLCAna3UnLCAnbGInLCAnbWFpJywgJ21sJywgJ21uJywgJ21yJywgJ25haCcsICduYXAnLCAnbmInLCAnbmUnLCAnbmwnLCAnbm4nLCAnbm8nLCAnbnNvJywgJ3BhJywgJ3BhcCcsICdwbXMnLCAncHMnLCAncHQtUFQnLCAncm0nLCAnc2NvJywgJ3NlJywgJ3NpJywgJ3NvJywgJ3NvbicsICdzcScsICdzdicsICdzdycsICd0YScsICd0ZScsICd0aycsICd1cicsICd5byddLFxuICBucjogWzEsIDJdLFxuICBmYzogMlxufSwge1xuICBsbmdzOiBbJ2F5JywgJ2JvJywgJ2NnZycsICdmYScsICdodCcsICdpZCcsICdqYScsICdqYm8nLCAna2EnLCAna20nLCAna28nLCAna3knLCAnbG8nLCAnbXMnLCAnc2FoJywgJ3N1JywgJ3RoJywgJ3R0JywgJ3VnJywgJ3ZpJywgJ3dvJywgJ3poJ10sXG4gIG5yOiBbMV0sXG4gIGZjOiAzXG59LCB7XG4gIGxuZ3M6IFsnYmUnLCAnYnMnLCAnY25yJywgJ2R6JywgJ2hyJywgJ3J1JywgJ3NyJywgJ3VrJ10sXG4gIG5yOiBbMSwgMiwgNV0sXG4gIGZjOiA0XG59LCB7XG4gIGxuZ3M6IFsnYXInXSxcbiAgbnI6IFswLCAxLCAyLCAzLCAxMSwgMTAwXSxcbiAgZmM6IDVcbn0sIHtcbiAgbG5nczogWydjcycsICdzayddLFxuICBucjogWzEsIDIsIDVdLFxuICBmYzogNlxufSwge1xuICBsbmdzOiBbJ2NzYicsICdwbCddLFxuICBucjogWzEsIDIsIDVdLFxuICBmYzogN1xufSwge1xuICBsbmdzOiBbJ2N5J10sXG4gIG5yOiBbMSwgMiwgMywgOF0sXG4gIGZjOiA4XG59LCB7XG4gIGxuZ3M6IFsnZnInXSxcbiAgbnI6IFsxLCAyXSxcbiAgZmM6IDlcbn0sIHtcbiAgbG5nczogWydnYSddLFxuICBucjogWzEsIDIsIDMsIDcsIDExXSxcbiAgZmM6IDEwXG59LCB7XG4gIGxuZ3M6IFsnZ2QnXSxcbiAgbnI6IFsxLCAyLCAzLCAyMF0sXG4gIGZjOiAxMVxufSwge1xuICBsbmdzOiBbJ2lzJ10sXG4gIG5yOiBbMSwgMl0sXG4gIGZjOiAxMlxufSwge1xuICBsbmdzOiBbJ2p2J10sXG4gIG5yOiBbMCwgMV0sXG4gIGZjOiAxM1xufSwge1xuICBsbmdzOiBbJ2t3J10sXG4gIG5yOiBbMSwgMiwgMywgNF0sXG4gIGZjOiAxNFxufSwge1xuICBsbmdzOiBbJ2x0J10sXG4gIG5yOiBbMSwgMiwgMTBdLFxuICBmYzogMTVcbn0sIHtcbiAgbG5nczogWydsdiddLFxuICBucjogWzEsIDIsIDBdLFxuICBmYzogMTZcbn0sIHtcbiAgbG5nczogWydtayddLFxuICBucjogWzEsIDJdLFxuICBmYzogMTdcbn0sIHtcbiAgbG5nczogWydtbmsnXSxcbiAgbnI6IFswLCAxLCAyXSxcbiAgZmM6IDE4XG59LCB7XG4gIGxuZ3M6IFsnbXQnXSxcbiAgbnI6IFsxLCAyLCAxMSwgMjBdLFxuICBmYzogMTlcbn0sIHtcbiAgbG5nczogWydvciddLFxuICBucjogWzIsIDFdLFxuICBmYzogMlxufSwge1xuICBsbmdzOiBbJ3JvJ10sXG4gIG5yOiBbMSwgMiwgMjBdLFxuICBmYzogMjBcbn0sIHtcbiAgbG5nczogWydzbCddLFxuICBucjogWzUsIDEsIDIsIDNdLFxuICBmYzogMjFcbn0sIHtcbiAgbG5nczogWydoZScsICdpdyddLFxuICBucjogWzEsIDIsIDIwLCAyMV0sXG4gIGZjOiAyMlxufV07XG5sZXQgX3J1bGVzUGx1cmFsc1R5cGVzID0ge1xuICAxOiBmdW5jdGlvbiAobikge1xuICAgIHJldHVybiBOdW1iZXIobiA+IDEpO1xuICB9LFxuICAyOiBmdW5jdGlvbiAobikge1xuICAgIHJldHVybiBOdW1iZXIobiAhPSAxKTtcbiAgfSxcbiAgMzogZnVuY3Rpb24gKG4pIHtcbiAgICByZXR1cm4gMDtcbiAgfSxcbiAgNDogZnVuY3Rpb24gKG4pIHtcbiAgICByZXR1cm4gTnVtYmVyKG4gJSAxMCA9PSAxICYmIG4gJSAxMDAgIT0gMTEgPyAwIDogbiAlIDEwID49IDIgJiYgbiAlIDEwIDw9IDQgJiYgKG4gJSAxMDAgPCAxMCB8fCBuICUgMTAwID49IDIwKSA/IDEgOiAyKTtcbiAgfSxcbiAgNTogZnVuY3Rpb24gKG4pIHtcbiAgICByZXR1cm4gTnVtYmVyKG4gPT0gMCA/IDAgOiBuID09IDEgPyAxIDogbiA9PSAyID8gMiA6IG4gJSAxMDAgPj0gMyAmJiBuICUgMTAwIDw9IDEwID8gMyA6IG4gJSAxMDAgPj0gMTEgPyA0IDogNSk7XG4gIH0sXG4gIDY6IGZ1bmN0aW9uIChuKSB7XG4gICAgcmV0dXJuIE51bWJlcihuID09IDEgPyAwIDogbiA+PSAyICYmIG4gPD0gNCA/IDEgOiAyKTtcbiAgfSxcbiAgNzogZnVuY3Rpb24gKG4pIHtcbiAgICByZXR1cm4gTnVtYmVyKG4gPT0gMSA/IDAgOiBuICUgMTAgPj0gMiAmJiBuICUgMTAgPD0gNCAmJiAobiAlIDEwMCA8IDEwIHx8IG4gJSAxMDAgPj0gMjApID8gMSA6IDIpO1xuICB9LFxuICA4OiBmdW5jdGlvbiAobikge1xuICAgIHJldHVybiBOdW1iZXIobiA9PSAxID8gMCA6IG4gPT0gMiA/IDEgOiBuICE9IDggJiYgbiAhPSAxMSA/IDIgOiAzKTtcbiAgfSxcbiAgOTogZnVuY3Rpb24gKG4pIHtcbiAgICByZXR1cm4gTnVtYmVyKG4gPj0gMik7XG4gIH0sXG4gIDEwOiBmdW5jdGlvbiAobikge1xuICAgIHJldHVybiBOdW1iZXIobiA9PSAxID8gMCA6IG4gPT0gMiA/IDEgOiBuIDwgNyA/IDIgOiBuIDwgMTEgPyAzIDogNCk7XG4gIH0sXG4gIDExOiBmdW5jdGlvbiAobikge1xuICAgIHJldHVybiBOdW1iZXIobiA9PSAxIHx8IG4gPT0gMTEgPyAwIDogbiA9PSAyIHx8IG4gPT0gMTIgPyAxIDogbiA+IDIgJiYgbiA8IDIwID8gMiA6IDMpO1xuICB9LFxuICAxMjogZnVuY3Rpb24gKG4pIHtcbiAgICByZXR1cm4gTnVtYmVyKG4gJSAxMCAhPSAxIHx8IG4gJSAxMDAgPT0gMTEpO1xuICB9LFxuICAxMzogZnVuY3Rpb24gKG4pIHtcbiAgICByZXR1cm4gTnVtYmVyKG4gIT09IDApO1xuICB9LFxuICAxNDogZnVuY3Rpb24gKG4pIHtcbiAgICByZXR1cm4gTnVtYmVyKG4gPT0gMSA/IDAgOiBuID09IDIgPyAxIDogbiA9PSAzID8gMiA6IDMpO1xuICB9LFxuICAxNTogZnVuY3Rpb24gKG4pIHtcbiAgICByZXR1cm4gTnVtYmVyKG4gJSAxMCA9PSAxICYmIG4gJSAxMDAgIT0gMTEgPyAwIDogbiAlIDEwID49IDIgJiYgKG4gJSAxMDAgPCAxMCB8fCBuICUgMTAwID49IDIwKSA/IDEgOiAyKTtcbiAgfSxcbiAgMTY6IGZ1bmN0aW9uIChuKSB7XG4gICAgcmV0dXJuIE51bWJlcihuICUgMTAgPT0gMSAmJiBuICUgMTAwICE9IDExID8gMCA6IG4gIT09IDAgPyAxIDogMik7XG4gIH0sXG4gIDE3OiBmdW5jdGlvbiAobikge1xuICAgIHJldHVybiBOdW1iZXIobiA9PSAxIHx8IG4gJSAxMCA9PSAxICYmIG4gJSAxMDAgIT0gMTEgPyAwIDogMSk7XG4gIH0sXG4gIDE4OiBmdW5jdGlvbiAobikge1xuICAgIHJldHVybiBOdW1iZXIobiA9PSAwID8gMCA6IG4gPT0gMSA/IDEgOiAyKTtcbiAgfSxcbiAgMTk6IGZ1bmN0aW9uIChuKSB7XG4gICAgcmV0dXJuIE51bWJlcihuID09IDEgPyAwIDogbiA9PSAwIHx8IG4gJSAxMDAgPiAxICYmIG4gJSAxMDAgPCAxMSA/IDEgOiBuICUgMTAwID4gMTAgJiYgbiAlIDEwMCA8IDIwID8gMiA6IDMpO1xuICB9LFxuICAyMDogZnVuY3Rpb24gKG4pIHtcbiAgICByZXR1cm4gTnVtYmVyKG4gPT0gMSA/IDAgOiBuID09IDAgfHwgbiAlIDEwMCA+IDAgJiYgbiAlIDEwMCA8IDIwID8gMSA6IDIpO1xuICB9LFxuICAyMTogZnVuY3Rpb24gKG4pIHtcbiAgICByZXR1cm4gTnVtYmVyKG4gJSAxMDAgPT0gMSA/IDEgOiBuICUgMTAwID09IDIgPyAyIDogbiAlIDEwMCA9PSAzIHx8IG4gJSAxMDAgPT0gNCA/IDMgOiAwKTtcbiAgfSxcbiAgMjI6IGZ1bmN0aW9uIChuKSB7XG4gICAgcmV0dXJuIE51bWJlcihuID09IDEgPyAwIDogbiA9PSAyID8gMSA6IChuIDwgMCB8fCBuID4gMTApICYmIG4gJSAxMCA9PSAwID8gMiA6IDMpO1xuICB9XG59O1xuY29uc3Qgbm9uSW50bFZlcnNpb25zID0gWyd2MScsICd2MicsICd2MyddO1xuY29uc3QgaW50bFZlcnNpb25zID0gWyd2NCddO1xuY29uc3Qgc3VmZml4ZXNPcmRlciA9IHtcbiAgemVybzogMCxcbiAgb25lOiAxLFxuICB0d286IDIsXG4gIGZldzogMyxcbiAgbWFueTogNCxcbiAgb3RoZXI6IDVcbn07XG5mdW5jdGlvbiBjcmVhdGVSdWxlcygpIHtcbiAgY29uc3QgcnVsZXMgPSB7fTtcbiAgc2V0cy5mb3JFYWNoKHNldCA9PiB7XG4gICAgc2V0LmxuZ3MuZm9yRWFjaChsID0+IHtcbiAgICAgIHJ1bGVzW2xdID0ge1xuICAgICAgICBudW1iZXJzOiBzZXQubnIsXG4gICAgICAgIHBsdXJhbHM6IF9ydWxlc1BsdXJhbHNUeXBlc1tzZXQuZmNdXG4gICAgICB9O1xuICAgIH0pO1xuICB9KTtcbiAgcmV0dXJuIHJ1bGVzO1xufVxuY2xhc3MgUGx1cmFsUmVzb2x2ZXIge1xuICBjb25zdHJ1Y3RvcihsYW5ndWFnZVV0aWxzKSB7XG4gICAgbGV0IG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIHRoaXMubGFuZ3VhZ2VVdGlscyA9IGxhbmd1YWdlVXRpbHM7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLmxvZ2dlciA9IGJhc2VMb2dnZXIuY3JlYXRlKCdwbHVyYWxSZXNvbHZlcicpO1xuICAgIGlmICgoIXRoaXMub3B0aW9ucy5jb21wYXRpYmlsaXR5SlNPTiB8fCBpbnRsVmVyc2lvbnMuaW5jbHVkZXModGhpcy5vcHRpb25zLmNvbXBhdGliaWxpdHlKU09OKSkgJiYgKHR5cGVvZiBJbnRsID09PSAndW5kZWZpbmVkJyB8fCAhSW50bC5QbHVyYWxSdWxlcykpIHtcbiAgICAgIHRoaXMub3B0aW9ucy5jb21wYXRpYmlsaXR5SlNPTiA9ICd2Myc7XG4gICAgICB0aGlzLmxvZ2dlci5lcnJvcignWW91ciBlbnZpcm9ubWVudCBzZWVtcyBub3QgdG8gYmUgSW50bCBBUEkgY29tcGF0aWJsZSwgdXNlIGFuIEludGwuUGx1cmFsUnVsZXMgcG9seWZpbGwuIFdpbGwgZmFsbGJhY2sgdG8gdGhlIGNvbXBhdGliaWxpdHlKU09OIHYzIGZvcm1hdCBoYW5kbGluZy4nKTtcbiAgICB9XG4gICAgdGhpcy5ydWxlcyA9IGNyZWF0ZVJ1bGVzKCk7XG4gIH1cbiAgYWRkUnVsZShsbmcsIG9iaikge1xuICAgIHRoaXMucnVsZXNbbG5nXSA9IG9iajtcbiAgfVxuICBnZXRSdWxlKGNvZGUpIHtcbiAgICBsZXQgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgaWYgKHRoaXMuc2hvdWxkVXNlSW50bEFwaSgpKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gbmV3IEludGwuUGx1cmFsUnVsZXMoZ2V0Q2xlYW5lZENvZGUoY29kZSA9PT0gJ2RldicgPyAnZW4nIDogY29kZSksIHtcbiAgICAgICAgICB0eXBlOiBvcHRpb25zLm9yZGluYWwgPyAnb3JkaW5hbCcgOiAnY2FyZGluYWwnXG4gICAgICAgIH0pO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucnVsZXNbY29kZV0gfHwgdGhpcy5ydWxlc1t0aGlzLmxhbmd1YWdlVXRpbHMuZ2V0TGFuZ3VhZ2VQYXJ0RnJvbUNvZGUoY29kZSldO1xuICB9XG4gIG5lZWRzUGx1cmFsKGNvZGUpIHtcbiAgICBsZXQgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgY29uc3QgcnVsZSA9IHRoaXMuZ2V0UnVsZShjb2RlLCBvcHRpb25zKTtcbiAgICBpZiAodGhpcy5zaG91bGRVc2VJbnRsQXBpKCkpIHtcbiAgICAgIHJldHVybiBydWxlICYmIHJ1bGUucmVzb2x2ZWRPcHRpb25zKCkucGx1cmFsQ2F0ZWdvcmllcy5sZW5ndGggPiAxO1xuICAgIH1cbiAgICByZXR1cm4gcnVsZSAmJiBydWxlLm51bWJlcnMubGVuZ3RoID4gMTtcbiAgfVxuICBnZXRQbHVyYWxGb3Jtc09mS2V5KGNvZGUsIGtleSkge1xuICAgIGxldCBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICByZXR1cm4gdGhpcy5nZXRTdWZmaXhlcyhjb2RlLCBvcHRpb25zKS5tYXAoc3VmZml4ID0+IGAke2tleX0ke3N1ZmZpeH1gKTtcbiAgfVxuICBnZXRTdWZmaXhlcyhjb2RlKSB7XG4gICAgbGV0IG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIGNvbnN0IHJ1bGUgPSB0aGlzLmdldFJ1bGUoY29kZSwgb3B0aW9ucyk7XG4gICAgaWYgKCFydWxlKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGlmICh0aGlzLnNob3VsZFVzZUludGxBcGkoKSkge1xuICAgICAgcmV0dXJuIHJ1bGUucmVzb2x2ZWRPcHRpb25zKCkucGx1cmFsQ2F0ZWdvcmllcy5zb3J0KChwbHVyYWxDYXRlZ29yeTEsIHBsdXJhbENhdGVnb3J5MikgPT4gc3VmZml4ZXNPcmRlcltwbHVyYWxDYXRlZ29yeTFdIC0gc3VmZml4ZXNPcmRlcltwbHVyYWxDYXRlZ29yeTJdKS5tYXAocGx1cmFsQ2F0ZWdvcnkgPT4gYCR7dGhpcy5vcHRpb25zLnByZXBlbmR9JHtvcHRpb25zLm9yZGluYWwgPyBgb3JkaW5hbCR7dGhpcy5vcHRpb25zLnByZXBlbmR9YCA6ICcnfSR7cGx1cmFsQ2F0ZWdvcnl9YCk7XG4gICAgfVxuICAgIHJldHVybiBydWxlLm51bWJlcnMubWFwKG51bWJlciA9PiB0aGlzLmdldFN1ZmZpeChjb2RlLCBudW1iZXIsIG9wdGlvbnMpKTtcbiAgfVxuICBnZXRTdWZmaXgoY29kZSwgY291bnQpIHtcbiAgICBsZXQgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgY29uc3QgcnVsZSA9IHRoaXMuZ2V0UnVsZShjb2RlLCBvcHRpb25zKTtcbiAgICBpZiAocnVsZSkge1xuICAgICAgaWYgKHRoaXMuc2hvdWxkVXNlSW50bEFwaSgpKSB7XG4gICAgICAgIHJldHVybiBgJHt0aGlzLm9wdGlvbnMucHJlcGVuZH0ke29wdGlvbnMub3JkaW5hbCA/IGBvcmRpbmFsJHt0aGlzLm9wdGlvbnMucHJlcGVuZH1gIDogJyd9JHtydWxlLnNlbGVjdChjb3VudCl9YDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmdldFN1ZmZpeFJldHJvQ29tcGF0aWJsZShydWxlLCBjb3VudCk7XG4gICAgfVxuICAgIHRoaXMubG9nZ2VyLndhcm4oYG5vIHBsdXJhbCBydWxlIGZvdW5kIGZvcjogJHtjb2RlfWApO1xuICAgIHJldHVybiAnJztcbiAgfVxuICBnZXRTdWZmaXhSZXRyb0NvbXBhdGlibGUocnVsZSwgY291bnQpIHtcbiAgICBjb25zdCBpZHggPSBydWxlLm5vQWJzID8gcnVsZS5wbHVyYWxzKGNvdW50KSA6IHJ1bGUucGx1cmFscyhNYXRoLmFicyhjb3VudCkpO1xuICAgIGxldCBzdWZmaXggPSBydWxlLm51bWJlcnNbaWR4XTtcbiAgICBpZiAodGhpcy5vcHRpb25zLnNpbXBsaWZ5UGx1cmFsU3VmZml4ICYmIHJ1bGUubnVtYmVycy5sZW5ndGggPT09IDIgJiYgcnVsZS5udW1iZXJzWzBdID09PSAxKSB7XG4gICAgICBpZiAoc3VmZml4ID09PSAyKSB7XG4gICAgICAgIHN1ZmZpeCA9ICdwbHVyYWwnO1xuICAgICAgfSBlbHNlIGlmIChzdWZmaXggPT09IDEpIHtcbiAgICAgICAgc3VmZml4ID0gJyc7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHJldHVyblN1ZmZpeCA9ICgpID0+IHRoaXMub3B0aW9ucy5wcmVwZW5kICYmIHN1ZmZpeC50b1N0cmluZygpID8gdGhpcy5vcHRpb25zLnByZXBlbmQgKyBzdWZmaXgudG9TdHJpbmcoKSA6IHN1ZmZpeC50b1N0cmluZygpO1xuICAgIGlmICh0aGlzLm9wdGlvbnMuY29tcGF0aWJpbGl0eUpTT04gPT09ICd2MScpIHtcbiAgICAgIGlmIChzdWZmaXggPT09IDEpIHJldHVybiAnJztcbiAgICAgIGlmICh0eXBlb2Ygc3VmZml4ID09PSAnbnVtYmVyJykgcmV0dXJuIGBfcGx1cmFsXyR7c3VmZml4LnRvU3RyaW5nKCl9YDtcbiAgICAgIHJldHVybiByZXR1cm5TdWZmaXgoKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMub3B0aW9ucy5jb21wYXRpYmlsaXR5SlNPTiA9PT0gJ3YyJykge1xuICAgICAgcmV0dXJuIHJldHVyblN1ZmZpeCgpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5vcHRpb25zLnNpbXBsaWZ5UGx1cmFsU3VmZml4ICYmIHJ1bGUubnVtYmVycy5sZW5ndGggPT09IDIgJiYgcnVsZS5udW1iZXJzWzBdID09PSAxKSB7XG4gICAgICByZXR1cm4gcmV0dXJuU3VmZml4KCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLm9wdGlvbnMucHJlcGVuZCAmJiBpZHgudG9TdHJpbmcoKSA/IHRoaXMub3B0aW9ucy5wcmVwZW5kICsgaWR4LnRvU3RyaW5nKCkgOiBpZHgudG9TdHJpbmcoKTtcbiAgfVxuICBzaG91bGRVc2VJbnRsQXBpKCkge1xuICAgIHJldHVybiAhbm9uSW50bFZlcnNpb25zLmluY2x1ZGVzKHRoaXMub3B0aW9ucy5jb21wYXRpYmlsaXR5SlNPTik7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVlcEZpbmRXaXRoRGVmYXVsdHMoZGF0YSwgZGVmYXVsdERhdGEsIGtleSkge1xuICBsZXQga2V5U2VwYXJhdG9yID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiAnLic7XG4gIGxldCBpZ25vcmVKU09OU3RydWN0dXJlID0gYXJndW1lbnRzLmxlbmd0aCA+IDQgJiYgYXJndW1lbnRzWzRdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNF0gOiB0cnVlO1xuICBsZXQgcGF0aCA9IGdldFBhdGhXaXRoRGVmYXVsdHMoZGF0YSwgZGVmYXVsdERhdGEsIGtleSk7XG4gIGlmICghcGF0aCAmJiBpZ25vcmVKU09OU3RydWN0dXJlICYmIHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnKSB7XG4gICAgcGF0aCA9IGRlZXBGaW5kKGRhdGEsIGtleSwga2V5U2VwYXJhdG9yKTtcbiAgICBpZiAocGF0aCA9PT0gdW5kZWZpbmVkKSBwYXRoID0gZGVlcEZpbmQoZGVmYXVsdERhdGEsIGtleSwga2V5U2VwYXJhdG9yKTtcbiAgfVxuICByZXR1cm4gcGF0aDtcbn1cbmNsYXNzIEludGVycG9sYXRvciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIGxldCBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICB0aGlzLmxvZ2dlciA9IGJhc2VMb2dnZXIuY3JlYXRlKCdpbnRlcnBvbGF0b3InKTtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMuZm9ybWF0ID0gb3B0aW9ucy5pbnRlcnBvbGF0aW9uICYmIG9wdGlvbnMuaW50ZXJwb2xhdGlvbi5mb3JtYXQgfHwgKHZhbHVlID0+IHZhbHVlKTtcbiAgICB0aGlzLmluaXQob3B0aW9ucyk7XG4gIH1cbiAgaW5pdCgpIHtcbiAgICBsZXQgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgaWYgKCFvcHRpb25zLmludGVycG9sYXRpb24pIG9wdGlvbnMuaW50ZXJwb2xhdGlvbiA9IHtcbiAgICAgIGVzY2FwZVZhbHVlOiB0cnVlXG4gICAgfTtcbiAgICBjb25zdCB7XG4gICAgICBlc2NhcGU6IGVzY2FwZSQxLFxuICAgICAgZXNjYXBlVmFsdWUsXG4gICAgICB1c2VSYXdWYWx1ZVRvRXNjYXBlLFxuICAgICAgcHJlZml4LFxuICAgICAgcHJlZml4RXNjYXBlZCxcbiAgICAgIHN1ZmZpeCxcbiAgICAgIHN1ZmZpeEVzY2FwZWQsXG4gICAgICBmb3JtYXRTZXBhcmF0b3IsXG4gICAgICB1bmVzY2FwZVN1ZmZpeCxcbiAgICAgIHVuZXNjYXBlUHJlZml4LFxuICAgICAgbmVzdGluZ1ByZWZpeCxcbiAgICAgIG5lc3RpbmdQcmVmaXhFc2NhcGVkLFxuICAgICAgbmVzdGluZ1N1ZmZpeCxcbiAgICAgIG5lc3RpbmdTdWZmaXhFc2NhcGVkLFxuICAgICAgbmVzdGluZ09wdGlvbnNTZXBhcmF0b3IsXG4gICAgICBtYXhSZXBsYWNlcyxcbiAgICAgIGFsd2F5c0Zvcm1hdFxuICAgIH0gPSBvcHRpb25zLmludGVycG9sYXRpb247XG4gICAgdGhpcy5lc2NhcGUgPSBlc2NhcGUkMSAhPT0gdW5kZWZpbmVkID8gZXNjYXBlJDEgOiBlc2NhcGU7XG4gICAgdGhpcy5lc2NhcGVWYWx1ZSA9IGVzY2FwZVZhbHVlICE9PSB1bmRlZmluZWQgPyBlc2NhcGVWYWx1ZSA6IHRydWU7XG4gICAgdGhpcy51c2VSYXdWYWx1ZVRvRXNjYXBlID0gdXNlUmF3VmFsdWVUb0VzY2FwZSAhPT0gdW5kZWZpbmVkID8gdXNlUmF3VmFsdWVUb0VzY2FwZSA6IGZhbHNlO1xuICAgIHRoaXMucHJlZml4ID0gcHJlZml4ID8gcmVnZXhFc2NhcGUocHJlZml4KSA6IHByZWZpeEVzY2FwZWQgfHwgJ3t7JztcbiAgICB0aGlzLnN1ZmZpeCA9IHN1ZmZpeCA/IHJlZ2V4RXNjYXBlKHN1ZmZpeCkgOiBzdWZmaXhFc2NhcGVkIHx8ICd9fSc7XG4gICAgdGhpcy5mb3JtYXRTZXBhcmF0b3IgPSBmb3JtYXRTZXBhcmF0b3IgfHwgJywnO1xuICAgIHRoaXMudW5lc2NhcGVQcmVmaXggPSB1bmVzY2FwZVN1ZmZpeCA/ICcnIDogdW5lc2NhcGVQcmVmaXggfHwgJy0nO1xuICAgIHRoaXMudW5lc2NhcGVTdWZmaXggPSB0aGlzLnVuZXNjYXBlUHJlZml4ID8gJycgOiB1bmVzY2FwZVN1ZmZpeCB8fCAnJztcbiAgICB0aGlzLm5lc3RpbmdQcmVmaXggPSBuZXN0aW5nUHJlZml4ID8gcmVnZXhFc2NhcGUobmVzdGluZ1ByZWZpeCkgOiBuZXN0aW5nUHJlZml4RXNjYXBlZCB8fCByZWdleEVzY2FwZSgnJHQoJyk7XG4gICAgdGhpcy5uZXN0aW5nU3VmZml4ID0gbmVzdGluZ1N1ZmZpeCA/IHJlZ2V4RXNjYXBlKG5lc3RpbmdTdWZmaXgpIDogbmVzdGluZ1N1ZmZpeEVzY2FwZWQgfHwgcmVnZXhFc2NhcGUoJyknKTtcbiAgICB0aGlzLm5lc3RpbmdPcHRpb25zU2VwYXJhdG9yID0gbmVzdGluZ09wdGlvbnNTZXBhcmF0b3IgfHwgJywnO1xuICAgIHRoaXMubWF4UmVwbGFjZXMgPSBtYXhSZXBsYWNlcyB8fCAxMDAwO1xuICAgIHRoaXMuYWx3YXlzRm9ybWF0ID0gYWx3YXlzRm9ybWF0ICE9PSB1bmRlZmluZWQgPyBhbHdheXNGb3JtYXQgOiBmYWxzZTtcbiAgICB0aGlzLnJlc2V0UmVnRXhwKCk7XG4gIH1cbiAgcmVzZXQoKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucykgdGhpcy5pbml0KHRoaXMub3B0aW9ucyk7XG4gIH1cbiAgcmVzZXRSZWdFeHAoKSB7XG4gICAgY29uc3QgZ2V0T3JSZXNldFJlZ0V4cCA9IChleGlzdGluZ1JlZ0V4cCwgcGF0dGVybikgPT4ge1xuICAgICAgaWYgKGV4aXN0aW5nUmVnRXhwICYmIGV4aXN0aW5nUmVnRXhwLnNvdXJjZSA9PT0gcGF0dGVybikge1xuICAgICAgICBleGlzdGluZ1JlZ0V4cC5sYXN0SW5kZXggPSAwO1xuICAgICAgICByZXR1cm4gZXhpc3RpbmdSZWdFeHA7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IFJlZ0V4cChwYXR0ZXJuLCAnZycpO1xuICAgIH07XG4gICAgdGhpcy5yZWdleHAgPSBnZXRPclJlc2V0UmVnRXhwKHRoaXMucmVnZXhwLCBgJHt0aGlzLnByZWZpeH0oLis/KSR7dGhpcy5zdWZmaXh9YCk7XG4gICAgdGhpcy5yZWdleHBVbmVzY2FwZSA9IGdldE9yUmVzZXRSZWdFeHAodGhpcy5yZWdleHBVbmVzY2FwZSwgYCR7dGhpcy5wcmVmaXh9JHt0aGlzLnVuZXNjYXBlUHJlZml4fSguKz8pJHt0aGlzLnVuZXNjYXBlU3VmZml4fSR7dGhpcy5zdWZmaXh9YCk7XG4gICAgdGhpcy5uZXN0aW5nUmVnZXhwID0gZ2V0T3JSZXNldFJlZ0V4cCh0aGlzLm5lc3RpbmdSZWdleHAsIGAke3RoaXMubmVzdGluZ1ByZWZpeH0oLis/KSR7dGhpcy5uZXN0aW5nU3VmZml4fWApO1xuICB9XG4gIGludGVycG9sYXRlKHN0ciwgZGF0YSwgbG5nLCBvcHRpb25zKSB7XG4gICAgbGV0IG1hdGNoO1xuICAgIGxldCB2YWx1ZTtcbiAgICBsZXQgcmVwbGFjZXM7XG4gICAgY29uc3QgZGVmYXVsdERhdGEgPSB0aGlzLm9wdGlvbnMgJiYgdGhpcy5vcHRpb25zLmludGVycG9sYXRpb24gJiYgdGhpcy5vcHRpb25zLmludGVycG9sYXRpb24uZGVmYXVsdFZhcmlhYmxlcyB8fCB7fTtcbiAgICBmdW5jdGlvbiByZWdleFNhZmUodmFsKSB7XG4gICAgICByZXR1cm4gdmFsLnJlcGxhY2UoL1xcJC9nLCAnJCQkJCcpO1xuICAgIH1cbiAgICBjb25zdCBoYW5kbGVGb3JtYXQgPSBrZXkgPT4ge1xuICAgICAgaWYgKGtleS5pbmRleE9mKHRoaXMuZm9ybWF0U2VwYXJhdG9yKSA8IDApIHtcbiAgICAgICAgY29uc3QgcGF0aCA9IGRlZXBGaW5kV2l0aERlZmF1bHRzKGRhdGEsIGRlZmF1bHREYXRhLCBrZXksIHRoaXMub3B0aW9ucy5rZXlTZXBhcmF0b3IsIHRoaXMub3B0aW9ucy5pZ25vcmVKU09OU3RydWN0dXJlKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWx3YXlzRm9ybWF0ID8gdGhpcy5mb3JtYXQocGF0aCwgdW5kZWZpbmVkLCBsbmcsIHtcbiAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgIC4uLmRhdGEsXG4gICAgICAgICAgaW50ZXJwb2xhdGlvbmtleToga2V5XG4gICAgICAgIH0pIDogcGF0aDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHAgPSBrZXkuc3BsaXQodGhpcy5mb3JtYXRTZXBhcmF0b3IpO1xuICAgICAgY29uc3QgayA9IHAuc2hpZnQoKS50cmltKCk7XG4gICAgICBjb25zdCBmID0gcC5qb2luKHRoaXMuZm9ybWF0U2VwYXJhdG9yKS50cmltKCk7XG4gICAgICByZXR1cm4gdGhpcy5mb3JtYXQoZGVlcEZpbmRXaXRoRGVmYXVsdHMoZGF0YSwgZGVmYXVsdERhdGEsIGssIHRoaXMub3B0aW9ucy5rZXlTZXBhcmF0b3IsIHRoaXMub3B0aW9ucy5pZ25vcmVKU09OU3RydWN0dXJlKSwgZiwgbG5nLCB7XG4gICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgIC4uLmRhdGEsXG4gICAgICAgIGludGVycG9sYXRpb25rZXk6IGtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgdGhpcy5yZXNldFJlZ0V4cCgpO1xuICAgIGNvbnN0IG1pc3NpbmdJbnRlcnBvbGF0aW9uSGFuZGxlciA9IG9wdGlvbnMgJiYgb3B0aW9ucy5taXNzaW5nSW50ZXJwb2xhdGlvbkhhbmRsZXIgfHwgdGhpcy5vcHRpb25zLm1pc3NpbmdJbnRlcnBvbGF0aW9uSGFuZGxlcjtcbiAgICBjb25zdCBza2lwT25WYXJpYWJsZXMgPSBvcHRpb25zICYmIG9wdGlvbnMuaW50ZXJwb2xhdGlvbiAmJiBvcHRpb25zLmludGVycG9sYXRpb24uc2tpcE9uVmFyaWFibGVzICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmludGVycG9sYXRpb24uc2tpcE9uVmFyaWFibGVzIDogdGhpcy5vcHRpb25zLmludGVycG9sYXRpb24uc2tpcE9uVmFyaWFibGVzO1xuICAgIGNvbnN0IHRvZG9zID0gW3tcbiAgICAgIHJlZ2V4OiB0aGlzLnJlZ2V4cFVuZXNjYXBlLFxuICAgICAgc2FmZVZhbHVlOiB2YWwgPT4gcmVnZXhTYWZlKHZhbClcbiAgICB9LCB7XG4gICAgICByZWdleDogdGhpcy5yZWdleHAsXG4gICAgICBzYWZlVmFsdWU6IHZhbCA9PiB0aGlzLmVzY2FwZVZhbHVlID8gcmVnZXhTYWZlKHRoaXMuZXNjYXBlKHZhbCkpIDogcmVnZXhTYWZlKHZhbClcbiAgICB9XTtcbiAgICB0b2Rvcy5mb3JFYWNoKHRvZG8gPT4ge1xuICAgICAgcmVwbGFjZXMgPSAwO1xuICAgICAgd2hpbGUgKG1hdGNoID0gdG9kby5yZWdleC5leGVjKHN0cikpIHtcbiAgICAgICAgY29uc3QgbWF0Y2hlZFZhciA9IG1hdGNoWzFdLnRyaW0oKTtcbiAgICAgICAgdmFsdWUgPSBoYW5kbGVGb3JtYXQobWF0Y2hlZFZhcik7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBtaXNzaW5nSW50ZXJwb2xhdGlvbkhhbmRsZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNvbnN0IHRlbXAgPSBtaXNzaW5nSW50ZXJwb2xhdGlvbkhhbmRsZXIoc3RyLCBtYXRjaCwgb3B0aW9ucyk7XG4gICAgICAgICAgICB2YWx1ZSA9IHR5cGVvZiB0ZW1wID09PSAnc3RyaW5nJyA/IHRlbXAgOiAnJztcbiAgICAgICAgICB9IGVsc2UgaWYgKG9wdGlvbnMgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9wdGlvbnMsIG1hdGNoZWRWYXIpKSB7XG4gICAgICAgICAgICB2YWx1ZSA9ICcnO1xuICAgICAgICAgIH0gZWxzZSBpZiAoc2tpcE9uVmFyaWFibGVzKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IG1hdGNoWzBdO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLndhcm4oYG1pc3NlZCB0byBwYXNzIGluIHZhcmlhYmxlICR7bWF0Y2hlZFZhcn0gZm9yIGludGVycG9sYXRpbmcgJHtzdHJ9YCk7XG4gICAgICAgICAgICB2YWx1ZSA9ICcnO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnICYmICF0aGlzLnVzZVJhd1ZhbHVlVG9Fc2NhcGUpIHtcbiAgICAgICAgICB2YWx1ZSA9IG1ha2VTdHJpbmcodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNhZmVWYWx1ZSA9IHRvZG8uc2FmZVZhbHVlKHZhbHVlKTtcbiAgICAgICAgc3RyID0gc3RyLnJlcGxhY2UobWF0Y2hbMF0sIHNhZmVWYWx1ZSk7XG4gICAgICAgIGlmIChza2lwT25WYXJpYWJsZXMpIHtcbiAgICAgICAgICB0b2RvLnJlZ2V4Lmxhc3RJbmRleCArPSB2YWx1ZS5sZW5ndGg7XG4gICAgICAgICAgdG9kby5yZWdleC5sYXN0SW5kZXggLT0gbWF0Y2hbMF0ubGVuZ3RoO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRvZG8ucmVnZXgubGFzdEluZGV4ID0gMDtcbiAgICAgICAgfVxuICAgICAgICByZXBsYWNlcysrO1xuICAgICAgICBpZiAocmVwbGFjZXMgPj0gdGhpcy5tYXhSZXBsYWNlcykge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxuICBuZXN0KHN0ciwgZmMpIHtcbiAgICBsZXQgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgbGV0IG1hdGNoO1xuICAgIGxldCB2YWx1ZTtcbiAgICBsZXQgY2xvbmVkT3B0aW9ucztcbiAgICBmdW5jdGlvbiBoYW5kbGVIYXNPcHRpb25zKGtleSwgaW5oZXJpdGVkT3B0aW9ucykge1xuICAgICAgY29uc3Qgc2VwID0gdGhpcy5uZXN0aW5nT3B0aW9uc1NlcGFyYXRvcjtcbiAgICAgIGlmIChrZXkuaW5kZXhPZihzZXApIDwgMCkgcmV0dXJuIGtleTtcbiAgICAgIGNvbnN0IGMgPSBrZXkuc3BsaXQobmV3IFJlZ0V4cChgJHtzZXB9WyBdKntgKSk7XG4gICAgICBsZXQgb3B0aW9uc1N0cmluZyA9IGB7JHtjWzFdfWA7XG4gICAgICBrZXkgPSBjWzBdO1xuICAgICAgb3B0aW9uc1N0cmluZyA9IHRoaXMuaW50ZXJwb2xhdGUob3B0aW9uc1N0cmluZywgY2xvbmVkT3B0aW9ucyk7XG4gICAgICBjb25zdCBtYXRjaGVkU2luZ2xlUXVvdGVzID0gb3B0aW9uc1N0cmluZy5tYXRjaCgvJy9nKTtcbiAgICAgIGNvbnN0IG1hdGNoZWREb3VibGVRdW90ZXMgPSBvcHRpb25zU3RyaW5nLm1hdGNoKC9cIi9nKTtcbiAgICAgIGlmIChtYXRjaGVkU2luZ2xlUXVvdGVzICYmIG1hdGNoZWRTaW5nbGVRdW90ZXMubGVuZ3RoICUgMiA9PT0gMCAmJiAhbWF0Y2hlZERvdWJsZVF1b3RlcyB8fCBtYXRjaGVkRG91YmxlUXVvdGVzLmxlbmd0aCAlIDIgIT09IDApIHtcbiAgICAgICAgb3B0aW9uc1N0cmluZyA9IG9wdGlvbnNTdHJpbmcucmVwbGFjZSgvJy9nLCAnXCInKTtcbiAgICAgIH1cbiAgICAgIHRyeSB7XG4gICAgICAgIGNsb25lZE9wdGlvbnMgPSBKU09OLnBhcnNlKG9wdGlvbnNTdHJpbmcpO1xuICAgICAgICBpZiAoaW5oZXJpdGVkT3B0aW9ucykgY2xvbmVkT3B0aW9ucyA9IHtcbiAgICAgICAgICAuLi5pbmhlcml0ZWRPcHRpb25zLFxuICAgICAgICAgIC4uLmNsb25lZE9wdGlvbnNcbiAgICAgICAgfTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgdGhpcy5sb2dnZXIud2FybihgZmFpbGVkIHBhcnNpbmcgb3B0aW9ucyBzdHJpbmcgaW4gbmVzdGluZyBmb3Iga2V5ICR7a2V5fWAsIGUpO1xuICAgICAgICByZXR1cm4gYCR7a2V5fSR7c2VwfSR7b3B0aW9uc1N0cmluZ31gO1xuICAgICAgfVxuICAgICAgaWYgKGNsb25lZE9wdGlvbnMuZGVmYXVsdFZhbHVlICYmIGNsb25lZE9wdGlvbnMuZGVmYXVsdFZhbHVlLmluZGV4T2YodGhpcy5wcmVmaXgpID4gLTEpIGRlbGV0ZSBjbG9uZWRPcHRpb25zLmRlZmF1bHRWYWx1ZTtcbiAgICAgIHJldHVybiBrZXk7XG4gICAgfVxuICAgIHdoaWxlIChtYXRjaCA9IHRoaXMubmVzdGluZ1JlZ2V4cC5leGVjKHN0cikpIHtcbiAgICAgIGxldCBmb3JtYXR0ZXJzID0gW107XG4gICAgICBjbG9uZWRPcHRpb25zID0ge1xuICAgICAgICAuLi5vcHRpb25zXG4gICAgICB9O1xuICAgICAgY2xvbmVkT3B0aW9ucyA9IGNsb25lZE9wdGlvbnMucmVwbGFjZSAmJiB0eXBlb2YgY2xvbmVkT3B0aW9ucy5yZXBsYWNlICE9PSAnc3RyaW5nJyA/IGNsb25lZE9wdGlvbnMucmVwbGFjZSA6IGNsb25lZE9wdGlvbnM7XG4gICAgICBjbG9uZWRPcHRpb25zLmFwcGx5UG9zdFByb2Nlc3NvciA9IGZhbHNlO1xuICAgICAgZGVsZXRlIGNsb25lZE9wdGlvbnMuZGVmYXVsdFZhbHVlO1xuICAgICAgbGV0IGRvUmVkdWNlID0gZmFsc2U7XG4gICAgICBpZiAobWF0Y2hbMF0uaW5kZXhPZih0aGlzLmZvcm1hdFNlcGFyYXRvcikgIT09IC0xICYmICEvey4qfS8udGVzdChtYXRjaFsxXSkpIHtcbiAgICAgICAgY29uc3QgciA9IG1hdGNoWzFdLnNwbGl0KHRoaXMuZm9ybWF0U2VwYXJhdG9yKS5tYXAoZWxlbSA9PiBlbGVtLnRyaW0oKSk7XG4gICAgICAgIG1hdGNoWzFdID0gci5zaGlmdCgpO1xuICAgICAgICBmb3JtYXR0ZXJzID0gcjtcbiAgICAgICAgZG9SZWR1Y2UgPSB0cnVlO1xuICAgICAgfVxuICAgICAgdmFsdWUgPSBmYyhoYW5kbGVIYXNPcHRpb25zLmNhbGwodGhpcywgbWF0Y2hbMV0udHJpbSgpLCBjbG9uZWRPcHRpb25zKSwgY2xvbmVkT3B0aW9ucyk7XG4gICAgICBpZiAodmFsdWUgJiYgbWF0Y2hbMF0gPT09IHN0ciAmJiB0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSByZXR1cm4gdmFsdWU7XG4gICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykgdmFsdWUgPSBtYWtlU3RyaW5nKHZhbHVlKTtcbiAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgdGhpcy5sb2dnZXIud2FybihgbWlzc2VkIHRvIHJlc29sdmUgJHttYXRjaFsxXX0gZm9yIG5lc3RpbmcgJHtzdHJ9YCk7XG4gICAgICAgIHZhbHVlID0gJyc7XG4gICAgICB9XG4gICAgICBpZiAoZG9SZWR1Y2UpIHtcbiAgICAgICAgdmFsdWUgPSBmb3JtYXR0ZXJzLnJlZHVjZSgodiwgZikgPT4gdGhpcy5mb3JtYXQodiwgZiwgb3B0aW9ucy5sbmcsIHtcbiAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgIGludGVycG9sYXRpb25rZXk6IG1hdGNoWzFdLnRyaW0oKVxuICAgICAgICB9KSwgdmFsdWUudHJpbSgpKTtcbiAgICAgIH1cbiAgICAgIHN0ciA9IHN0ci5yZXBsYWNlKG1hdGNoWzBdLCB2YWx1ZSk7XG4gICAgICB0aGlzLnJlZ2V4cC5sYXN0SW5kZXggPSAwO1xuICAgIH1cbiAgICByZXR1cm4gc3RyO1xuICB9XG59XG5cbmZ1bmN0aW9uIHBhcnNlRm9ybWF0U3RyKGZvcm1hdFN0cikge1xuICBsZXQgZm9ybWF0TmFtZSA9IGZvcm1hdFN0ci50b0xvd2VyQ2FzZSgpLnRyaW0oKTtcbiAgY29uc3QgZm9ybWF0T3B0aW9ucyA9IHt9O1xuICBpZiAoZm9ybWF0U3RyLmluZGV4T2YoJygnKSA+IC0xKSB7XG4gICAgY29uc3QgcCA9IGZvcm1hdFN0ci5zcGxpdCgnKCcpO1xuICAgIGZvcm1hdE5hbWUgPSBwWzBdLnRvTG93ZXJDYXNlKCkudHJpbSgpO1xuICAgIGNvbnN0IG9wdFN0ciA9IHBbMV0uc3Vic3RyaW5nKDAsIHBbMV0ubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGZvcm1hdE5hbWUgPT09ICdjdXJyZW5jeScgJiYgb3B0U3RyLmluZGV4T2YoJzonKSA8IDApIHtcbiAgICAgIGlmICghZm9ybWF0T3B0aW9ucy5jdXJyZW5jeSkgZm9ybWF0T3B0aW9ucy5jdXJyZW5jeSA9IG9wdFN0ci50cmltKCk7XG4gICAgfSBlbHNlIGlmIChmb3JtYXROYW1lID09PSAncmVsYXRpdmV0aW1lJyAmJiBvcHRTdHIuaW5kZXhPZignOicpIDwgMCkge1xuICAgICAgaWYgKCFmb3JtYXRPcHRpb25zLnJhbmdlKSBmb3JtYXRPcHRpb25zLnJhbmdlID0gb3B0U3RyLnRyaW0oKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qgb3B0cyA9IG9wdFN0ci5zcGxpdCgnOycpO1xuICAgICAgb3B0cy5mb3JFYWNoKG9wdCA9PiB7XG4gICAgICAgIGlmIChvcHQpIHtcbiAgICAgICAgICBjb25zdCBba2V5LCAuLi5yZXN0XSA9IG9wdC5zcGxpdCgnOicpO1xuICAgICAgICAgIGNvbnN0IHZhbCA9IHJlc3Quam9pbignOicpLnRyaW0oKS5yZXBsYWNlKC9eJyt8JyskL2csICcnKTtcbiAgICAgICAgICBjb25zdCB0cmltbWVkS2V5ID0ga2V5LnRyaW0oKTtcbiAgICAgICAgICBpZiAoIWZvcm1hdE9wdGlvbnNbdHJpbW1lZEtleV0pIGZvcm1hdE9wdGlvbnNbdHJpbW1lZEtleV0gPSB2YWw7XG4gICAgICAgICAgaWYgKHZhbCA9PT0gJ2ZhbHNlJykgZm9ybWF0T3B0aW9uc1t0cmltbWVkS2V5XSA9IGZhbHNlO1xuICAgICAgICAgIGlmICh2YWwgPT09ICd0cnVlJykgZm9ybWF0T3B0aW9uc1t0cmltbWVkS2V5XSA9IHRydWU7XG4gICAgICAgICAgaWYgKCFpc05hTih2YWwpKSBmb3JtYXRPcHRpb25zW3RyaW1tZWRLZXldID0gcGFyc2VJbnQodmFsLCAxMCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIGZvcm1hdE5hbWUsXG4gICAgZm9ybWF0T3B0aW9uc1xuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlQ2FjaGVkRm9ybWF0dGVyKGZuKSB7XG4gIGNvbnN0IGNhY2hlID0ge307XG4gIHJldHVybiBmdW5jdGlvbiBpbnZva2VGb3JtYXR0ZXIodmFsLCBsbmcsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBrZXkgPSBsbmcgKyBKU09OLnN0cmluZ2lmeShvcHRpb25zKTtcbiAgICBsZXQgZm9ybWF0dGVyID0gY2FjaGVba2V5XTtcbiAgICBpZiAoIWZvcm1hdHRlcikge1xuICAgICAgZm9ybWF0dGVyID0gZm4oZ2V0Q2xlYW5lZENvZGUobG5nKSwgb3B0aW9ucyk7XG4gICAgICBjYWNoZVtrZXldID0gZm9ybWF0dGVyO1xuICAgIH1cbiAgICByZXR1cm4gZm9ybWF0dGVyKHZhbCk7XG4gIH07XG59XG5jbGFzcyBGb3JtYXR0ZXIge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBsZXQgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgdGhpcy5sb2dnZXIgPSBiYXNlTG9nZ2VyLmNyZWF0ZSgnZm9ybWF0dGVyJyk7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLmZvcm1hdHMgPSB7XG4gICAgICBudW1iZXI6IGNyZWF0ZUNhY2hlZEZvcm1hdHRlcigobG5nLCBvcHQpID0+IHtcbiAgICAgICAgY29uc3QgZm9ybWF0dGVyID0gbmV3IEludGwuTnVtYmVyRm9ybWF0KGxuZywge1xuICAgICAgICAgIC4uLm9wdFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHZhbCA9PiBmb3JtYXR0ZXIuZm9ybWF0KHZhbCk7XG4gICAgICB9KSxcbiAgICAgIGN1cnJlbmN5OiBjcmVhdGVDYWNoZWRGb3JtYXR0ZXIoKGxuZywgb3B0KSA9PiB7XG4gICAgICAgIGNvbnN0IGZvcm1hdHRlciA9IG5ldyBJbnRsLk51bWJlckZvcm1hdChsbmcsIHtcbiAgICAgICAgICAuLi5vcHQsXG4gICAgICAgICAgc3R5bGU6ICdjdXJyZW5jeSdcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB2YWwgPT4gZm9ybWF0dGVyLmZvcm1hdCh2YWwpO1xuICAgICAgfSksXG4gICAgICBkYXRldGltZTogY3JlYXRlQ2FjaGVkRm9ybWF0dGVyKChsbmcsIG9wdCkgPT4ge1xuICAgICAgICBjb25zdCBmb3JtYXR0ZXIgPSBuZXcgSW50bC5EYXRlVGltZUZvcm1hdChsbmcsIHtcbiAgICAgICAgICAuLi5vcHRcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB2YWwgPT4gZm9ybWF0dGVyLmZvcm1hdCh2YWwpO1xuICAgICAgfSksXG4gICAgICByZWxhdGl2ZXRpbWU6IGNyZWF0ZUNhY2hlZEZvcm1hdHRlcigobG5nLCBvcHQpID0+IHtcbiAgICAgICAgY29uc3QgZm9ybWF0dGVyID0gbmV3IEludGwuUmVsYXRpdmVUaW1lRm9ybWF0KGxuZywge1xuICAgICAgICAgIC4uLm9wdFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHZhbCA9PiBmb3JtYXR0ZXIuZm9ybWF0KHZhbCwgb3B0LnJhbmdlIHx8ICdkYXknKTtcbiAgICAgIH0pLFxuICAgICAgbGlzdDogY3JlYXRlQ2FjaGVkRm9ybWF0dGVyKChsbmcsIG9wdCkgPT4ge1xuICAgICAgICBjb25zdCBmb3JtYXR0ZXIgPSBuZXcgSW50bC5MaXN0Rm9ybWF0KGxuZywge1xuICAgICAgICAgIC4uLm9wdFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHZhbCA9PiBmb3JtYXR0ZXIuZm9ybWF0KHZhbCk7XG4gICAgICB9KVxuICAgIH07XG4gICAgdGhpcy5pbml0KG9wdGlvbnMpO1xuICB9XG4gIGluaXQoc2VydmljZXMpIHtcbiAgICBsZXQgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge1xuICAgICAgaW50ZXJwb2xhdGlvbjoge31cbiAgICB9O1xuICAgIGNvbnN0IGlPcHRzID0gb3B0aW9ucy5pbnRlcnBvbGF0aW9uO1xuICAgIHRoaXMuZm9ybWF0U2VwYXJhdG9yID0gaU9wdHMuZm9ybWF0U2VwYXJhdG9yID8gaU9wdHMuZm9ybWF0U2VwYXJhdG9yIDogaU9wdHMuZm9ybWF0U2VwYXJhdG9yIHx8ICcsJztcbiAgfVxuICBhZGQobmFtZSwgZmMpIHtcbiAgICB0aGlzLmZvcm1hdHNbbmFtZS50b0xvd2VyQ2FzZSgpLnRyaW0oKV0gPSBmYztcbiAgfVxuICBhZGRDYWNoZWQobmFtZSwgZmMpIHtcbiAgICB0aGlzLmZvcm1hdHNbbmFtZS50b0xvd2VyQ2FzZSgpLnRyaW0oKV0gPSBjcmVhdGVDYWNoZWRGb3JtYXR0ZXIoZmMpO1xuICB9XG4gIGZvcm1hdCh2YWx1ZSwgZm9ybWF0LCBsbmcpIHtcbiAgICBsZXQgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDoge307XG4gICAgY29uc3QgZm9ybWF0cyA9IGZvcm1hdC5zcGxpdCh0aGlzLmZvcm1hdFNlcGFyYXRvcik7XG4gICAgY29uc3QgcmVzdWx0ID0gZm9ybWF0cy5yZWR1Y2UoKG1lbSwgZikgPT4ge1xuICAgICAgY29uc3Qge1xuICAgICAgICBmb3JtYXROYW1lLFxuICAgICAgICBmb3JtYXRPcHRpb25zXG4gICAgICB9ID0gcGFyc2VGb3JtYXRTdHIoZik7XG4gICAgICBpZiAodGhpcy5mb3JtYXRzW2Zvcm1hdE5hbWVdKSB7XG4gICAgICAgIGxldCBmb3JtYXR0ZWQgPSBtZW07XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgdmFsT3B0aW9ucyA9IG9wdGlvbnMgJiYgb3B0aW9ucy5mb3JtYXRQYXJhbXMgJiYgb3B0aW9ucy5mb3JtYXRQYXJhbXNbb3B0aW9ucy5pbnRlcnBvbGF0aW9ua2V5XSB8fCB7fTtcbiAgICAgICAgICBjb25zdCBsID0gdmFsT3B0aW9ucy5sb2NhbGUgfHwgdmFsT3B0aW9ucy5sbmcgfHwgb3B0aW9ucy5sb2NhbGUgfHwgb3B0aW9ucy5sbmcgfHwgbG5nO1xuICAgICAgICAgIGZvcm1hdHRlZCA9IHRoaXMuZm9ybWF0c1tmb3JtYXROYW1lXShtZW0sIGwsIHtcbiAgICAgICAgICAgIC4uLmZvcm1hdE9wdGlvbnMsXG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgLi4udmFsT3B0aW9uc1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIHRoaXMubG9nZ2VyLndhcm4oZXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmb3JtYXR0ZWQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmxvZ2dlci53YXJuKGB0aGVyZSB3YXMgbm8gZm9ybWF0IGZ1bmN0aW9uIGZvciAke2Zvcm1hdE5hbWV9YCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbWVtO1xuICAgIH0sIHZhbHVlKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlbW92ZVBlbmRpbmcocSwgbmFtZSkge1xuICBpZiAocS5wZW5kaW5nW25hbWVdICE9PSB1bmRlZmluZWQpIHtcbiAgICBkZWxldGUgcS5wZW5kaW5nW25hbWVdO1xuICAgIHEucGVuZGluZ0NvdW50LS07XG4gIH1cbn1cbmNsYXNzIENvbm5lY3RvciBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gIGNvbnN0cnVjdG9yKGJhY2tlbmQsIHN0b3JlLCBzZXJ2aWNlcykge1xuICAgIGxldCBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiB7fTtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuYmFja2VuZCA9IGJhY2tlbmQ7XG4gICAgdGhpcy5zdG9yZSA9IHN0b3JlO1xuICAgIHRoaXMuc2VydmljZXMgPSBzZXJ2aWNlcztcbiAgICB0aGlzLmxhbmd1YWdlVXRpbHMgPSBzZXJ2aWNlcy5sYW5ndWFnZVV0aWxzO1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy5sb2dnZXIgPSBiYXNlTG9nZ2VyLmNyZWF0ZSgnYmFja2VuZENvbm5lY3RvcicpO1xuICAgIHRoaXMud2FpdGluZ1JlYWRzID0gW107XG4gICAgdGhpcy5tYXhQYXJhbGxlbFJlYWRzID0gb3B0aW9ucy5tYXhQYXJhbGxlbFJlYWRzIHx8IDEwO1xuICAgIHRoaXMucmVhZGluZ0NhbGxzID0gMDtcbiAgICB0aGlzLm1heFJldHJpZXMgPSBvcHRpb25zLm1heFJldHJpZXMgPj0gMCA/IG9wdGlvbnMubWF4UmV0cmllcyA6IDU7XG4gICAgdGhpcy5yZXRyeVRpbWVvdXQgPSBvcHRpb25zLnJldHJ5VGltZW91dCA+PSAxID8gb3B0aW9ucy5yZXRyeVRpbWVvdXQgOiAzNTA7XG4gICAgdGhpcy5zdGF0ZSA9IHt9O1xuICAgIHRoaXMucXVldWUgPSBbXTtcbiAgICBpZiAodGhpcy5iYWNrZW5kICYmIHRoaXMuYmFja2VuZC5pbml0KSB7XG4gICAgICB0aGlzLmJhY2tlbmQuaW5pdChzZXJ2aWNlcywgb3B0aW9ucy5iYWNrZW5kLCBvcHRpb25zKTtcbiAgICB9XG4gIH1cbiAgcXVldWVMb2FkKGxhbmd1YWdlcywgbmFtZXNwYWNlcywgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICBjb25zdCB0b0xvYWQgPSB7fTtcbiAgICBjb25zdCBwZW5kaW5nID0ge307XG4gICAgY29uc3QgdG9Mb2FkTGFuZ3VhZ2VzID0ge307XG4gICAgY29uc3QgdG9Mb2FkTmFtZXNwYWNlcyA9IHt9O1xuICAgIGxhbmd1YWdlcy5mb3JFYWNoKGxuZyA9PiB7XG4gICAgICBsZXQgaGFzQWxsTmFtZXNwYWNlcyA9IHRydWU7XG4gICAgICBuYW1lc3BhY2VzLmZvckVhY2gobnMgPT4ge1xuICAgICAgICBjb25zdCBuYW1lID0gYCR7bG5nfXwke25zfWA7XG4gICAgICAgIGlmICghb3B0aW9ucy5yZWxvYWQgJiYgdGhpcy5zdG9yZS5oYXNSZXNvdXJjZUJ1bmRsZShsbmcsIG5zKSkge1xuICAgICAgICAgIHRoaXMuc3RhdGVbbmFtZV0gPSAyO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuc3RhdGVbbmFtZV0gPCAwKSA7IGVsc2UgaWYgKHRoaXMuc3RhdGVbbmFtZV0gPT09IDEpIHtcbiAgICAgICAgICBpZiAocGVuZGluZ1tuYW1lXSA9PT0gdW5kZWZpbmVkKSBwZW5kaW5nW25hbWVdID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnN0YXRlW25hbWVdID0gMTtcbiAgICAgICAgICBoYXNBbGxOYW1lc3BhY2VzID0gZmFsc2U7XG4gICAgICAgICAgaWYgKHBlbmRpbmdbbmFtZV0gPT09IHVuZGVmaW5lZCkgcGVuZGluZ1tuYW1lXSA9IHRydWU7XG4gICAgICAgICAgaWYgKHRvTG9hZFtuYW1lXSA9PT0gdW5kZWZpbmVkKSB0b0xvYWRbbmFtZV0gPSB0cnVlO1xuICAgICAgICAgIGlmICh0b0xvYWROYW1lc3BhY2VzW25zXSA9PT0gdW5kZWZpbmVkKSB0b0xvYWROYW1lc3BhY2VzW25zXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgaWYgKCFoYXNBbGxOYW1lc3BhY2VzKSB0b0xvYWRMYW5ndWFnZXNbbG5nXSA9IHRydWU7XG4gICAgfSk7XG4gICAgaWYgKE9iamVjdC5rZXlzKHRvTG9hZCkubGVuZ3RoIHx8IE9iamVjdC5rZXlzKHBlbmRpbmcpLmxlbmd0aCkge1xuICAgICAgdGhpcy5xdWV1ZS5wdXNoKHtcbiAgICAgICAgcGVuZGluZyxcbiAgICAgICAgcGVuZGluZ0NvdW50OiBPYmplY3Qua2V5cyhwZW5kaW5nKS5sZW5ndGgsXG4gICAgICAgIGxvYWRlZDoge30sXG4gICAgICAgIGVycm9yczogW10sXG4gICAgICAgIGNhbGxiYWNrXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHRvTG9hZDogT2JqZWN0LmtleXModG9Mb2FkKSxcbiAgICAgIHBlbmRpbmc6IE9iamVjdC5rZXlzKHBlbmRpbmcpLFxuICAgICAgdG9Mb2FkTGFuZ3VhZ2VzOiBPYmplY3Qua2V5cyh0b0xvYWRMYW5ndWFnZXMpLFxuICAgICAgdG9Mb2FkTmFtZXNwYWNlczogT2JqZWN0LmtleXModG9Mb2FkTmFtZXNwYWNlcylcbiAgICB9O1xuICB9XG4gIGxvYWRlZChuYW1lLCBlcnIsIGRhdGEpIHtcbiAgICBjb25zdCBzID0gbmFtZS5zcGxpdCgnfCcpO1xuICAgIGNvbnN0IGxuZyA9IHNbMF07XG4gICAgY29uc3QgbnMgPSBzWzFdO1xuICAgIGlmIChlcnIpIHRoaXMuZW1pdCgnZmFpbGVkTG9hZGluZycsIGxuZywgbnMsIGVycik7XG4gICAgaWYgKGRhdGEpIHtcbiAgICAgIHRoaXMuc3RvcmUuYWRkUmVzb3VyY2VCdW5kbGUobG5nLCBucywgZGF0YSwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHtcbiAgICAgICAgc2tpcENvcHk6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzLnN0YXRlW25hbWVdID0gZXJyID8gLTEgOiAyO1xuICAgIGNvbnN0IGxvYWRlZCA9IHt9O1xuICAgIHRoaXMucXVldWUuZm9yRWFjaChxID0+IHtcbiAgICAgIHB1c2hQYXRoKHEubG9hZGVkLCBbbG5nXSwgbnMpO1xuICAgICAgcmVtb3ZlUGVuZGluZyhxLCBuYW1lKTtcbiAgICAgIGlmIChlcnIpIHEuZXJyb3JzLnB1c2goZXJyKTtcbiAgICAgIGlmIChxLnBlbmRpbmdDb3VudCA9PT0gMCAmJiAhcS5kb25lKSB7XG4gICAgICAgIE9iamVjdC5rZXlzKHEubG9hZGVkKS5mb3JFYWNoKGwgPT4ge1xuICAgICAgICAgIGlmICghbG9hZGVkW2xdKSBsb2FkZWRbbF0gPSB7fTtcbiAgICAgICAgICBjb25zdCBsb2FkZWRLZXlzID0gcS5sb2FkZWRbbF07XG4gICAgICAgICAgaWYgKGxvYWRlZEtleXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBsb2FkZWRLZXlzLmZvckVhY2gobiA9PiB7XG4gICAgICAgICAgICAgIGlmIChsb2FkZWRbbF1bbl0gPT09IHVuZGVmaW5lZCkgbG9hZGVkW2xdW25dID0gdHJ1ZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHEuZG9uZSA9IHRydWU7XG4gICAgICAgIGlmIChxLmVycm9ycy5sZW5ndGgpIHtcbiAgICAgICAgICBxLmNhbGxiYWNrKHEuZXJyb3JzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBxLmNhbGxiYWNrKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLmVtaXQoJ2xvYWRlZCcsIGxvYWRlZCk7XG4gICAgdGhpcy5xdWV1ZSA9IHRoaXMucXVldWUuZmlsdGVyKHEgPT4gIXEuZG9uZSk7XG4gIH1cbiAgcmVhZChsbmcsIG5zLCBmY05hbWUpIHtcbiAgICBsZXQgdHJpZWQgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IDA7XG4gICAgbGV0IHdhaXQgPSBhcmd1bWVudHMubGVuZ3RoID4gNCAmJiBhcmd1bWVudHNbNF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s0XSA6IHRoaXMucmV0cnlUaW1lb3V0O1xuICAgIGxldCBjYWxsYmFjayA9IGFyZ3VtZW50cy5sZW5ndGggPiA1ID8gYXJndW1lbnRzWzVdIDogdW5kZWZpbmVkO1xuICAgIGlmICghbG5nLmxlbmd0aCkgcmV0dXJuIGNhbGxiYWNrKG51bGwsIHt9KTtcbiAgICBpZiAodGhpcy5yZWFkaW5nQ2FsbHMgPj0gdGhpcy5tYXhQYXJhbGxlbFJlYWRzKSB7XG4gICAgICB0aGlzLndhaXRpbmdSZWFkcy5wdXNoKHtcbiAgICAgICAgbG5nLFxuICAgICAgICBucyxcbiAgICAgICAgZmNOYW1lLFxuICAgICAgICB0cmllZCxcbiAgICAgICAgd2FpdCxcbiAgICAgICAgY2FsbGJhY2tcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnJlYWRpbmdDYWxscysrO1xuICAgIGNvbnN0IHJlc29sdmVyID0gKGVyciwgZGF0YSkgPT4ge1xuICAgICAgdGhpcy5yZWFkaW5nQ2FsbHMtLTtcbiAgICAgIGlmICh0aGlzLndhaXRpbmdSZWFkcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnN0IG5leHQgPSB0aGlzLndhaXRpbmdSZWFkcy5zaGlmdCgpO1xuICAgICAgICB0aGlzLnJlYWQobmV4dC5sbmcsIG5leHQubnMsIG5leHQuZmNOYW1lLCBuZXh0LnRyaWVkLCBuZXh0LndhaXQsIG5leHQuY2FsbGJhY2spO1xuICAgICAgfVxuICAgICAgaWYgKGVyciAmJiBkYXRhICYmIHRyaWVkIDwgdGhpcy5tYXhSZXRyaWVzKSB7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIHRoaXMucmVhZC5jYWxsKHRoaXMsIGxuZywgbnMsIGZjTmFtZSwgdHJpZWQgKyAxLCB3YWl0ICogMiwgY2FsbGJhY2spO1xuICAgICAgICB9LCB3YWl0KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY2FsbGJhY2soZXJyLCBkYXRhKTtcbiAgICB9O1xuICAgIGNvbnN0IGZjID0gdGhpcy5iYWNrZW5kW2ZjTmFtZV0uYmluZCh0aGlzLmJhY2tlbmQpO1xuICAgIGlmIChmYy5sZW5ndGggPT09IDIpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHIgPSBmYyhsbmcsIG5zKTtcbiAgICAgICAgaWYgKHIgJiYgdHlwZW9mIHIudGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHIudGhlbihkYXRhID0+IHJlc29sdmVyKG51bGwsIGRhdGEpKS5jYXRjaChyZXNvbHZlcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzb2x2ZXIobnVsbCwgcik7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICByZXNvbHZlcihlcnIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZXR1cm4gZmMobG5nLCBucywgcmVzb2x2ZXIpO1xuICB9XG4gIHByZXBhcmVMb2FkaW5nKGxhbmd1YWdlcywgbmFtZXNwYWNlcykge1xuICAgIGxldCBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICBsZXQgY2FsbGJhY2sgPSBhcmd1bWVudHMubGVuZ3RoID4gMyA/IGFyZ3VtZW50c1szXSA6IHVuZGVmaW5lZDtcbiAgICBpZiAoIXRoaXMuYmFja2VuZCkge1xuICAgICAgdGhpcy5sb2dnZXIud2FybignTm8gYmFja2VuZCB3YXMgYWRkZWQgdmlhIGkxOG5leHQudXNlLiBXaWxsIG5vdCBsb2FkIHJlc291cmNlcy4nKTtcbiAgICAgIHJldHVybiBjYWxsYmFjayAmJiBjYWxsYmFjaygpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGxhbmd1YWdlcyA9PT0gJ3N0cmluZycpIGxhbmd1YWdlcyA9IHRoaXMubGFuZ3VhZ2VVdGlscy50b1Jlc29sdmVIaWVyYXJjaHkobGFuZ3VhZ2VzKTtcbiAgICBpZiAodHlwZW9mIG5hbWVzcGFjZXMgPT09ICdzdHJpbmcnKSBuYW1lc3BhY2VzID0gW25hbWVzcGFjZXNdO1xuICAgIGNvbnN0IHRvTG9hZCA9IHRoaXMucXVldWVMb2FkKGxhbmd1YWdlcywgbmFtZXNwYWNlcywgb3B0aW9ucywgY2FsbGJhY2spO1xuICAgIGlmICghdG9Mb2FkLnRvTG9hZC5sZW5ndGgpIHtcbiAgICAgIGlmICghdG9Mb2FkLnBlbmRpbmcubGVuZ3RoKSBjYWxsYmFjaygpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHRvTG9hZC50b0xvYWQuZm9yRWFjaChuYW1lID0+IHtcbiAgICAgIHRoaXMubG9hZE9uZShuYW1lKTtcbiAgICB9KTtcbiAgfVxuICBsb2FkKGxhbmd1YWdlcywgbmFtZXNwYWNlcywgY2FsbGJhY2spIHtcbiAgICB0aGlzLnByZXBhcmVMb2FkaW5nKGxhbmd1YWdlcywgbmFtZXNwYWNlcywge30sIGNhbGxiYWNrKTtcbiAgfVxuICByZWxvYWQobGFuZ3VhZ2VzLCBuYW1lc3BhY2VzLCBjYWxsYmFjaykge1xuICAgIHRoaXMucHJlcGFyZUxvYWRpbmcobGFuZ3VhZ2VzLCBuYW1lc3BhY2VzLCB7XG4gICAgICByZWxvYWQ6IHRydWVcbiAgICB9LCBjYWxsYmFjayk7XG4gIH1cbiAgbG9hZE9uZShuYW1lKSB7XG4gICAgbGV0IHByZWZpeCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogJyc7XG4gICAgY29uc3QgcyA9IG5hbWUuc3BsaXQoJ3wnKTtcbiAgICBjb25zdCBsbmcgPSBzWzBdO1xuICAgIGNvbnN0IG5zID0gc1sxXTtcbiAgICB0aGlzLnJlYWQobG5nLCBucywgJ3JlYWQnLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgKGVyciwgZGF0YSkgPT4ge1xuICAgICAgaWYgKGVycikgdGhpcy5sb2dnZXIud2FybihgJHtwcmVmaXh9bG9hZGluZyBuYW1lc3BhY2UgJHtuc30gZm9yIGxhbmd1YWdlICR7bG5nfSBmYWlsZWRgLCBlcnIpO1xuICAgICAgaWYgKCFlcnIgJiYgZGF0YSkgdGhpcy5sb2dnZXIubG9nKGAke3ByZWZpeH1sb2FkZWQgbmFtZXNwYWNlICR7bnN9IGZvciBsYW5ndWFnZSAke2xuZ31gLCBkYXRhKTtcbiAgICAgIHRoaXMubG9hZGVkKG5hbWUsIGVyciwgZGF0YSk7XG4gICAgfSk7XG4gIH1cbiAgc2F2ZU1pc3NpbmcobGFuZ3VhZ2VzLCBuYW1lc3BhY2UsIGtleSwgZmFsbGJhY2tWYWx1ZSwgaXNVcGRhdGUpIHtcbiAgICBsZXQgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiA1ICYmIGFyZ3VtZW50c1s1XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzVdIDoge307XG4gICAgbGV0IGNsYiA9IGFyZ3VtZW50cy5sZW5ndGggPiA2ICYmIGFyZ3VtZW50c1s2XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzZdIDogKCkgPT4ge307XG4gICAgaWYgKHRoaXMuc2VydmljZXMudXRpbHMgJiYgdGhpcy5zZXJ2aWNlcy51dGlscy5oYXNMb2FkZWROYW1lc3BhY2UgJiYgIXRoaXMuc2VydmljZXMudXRpbHMuaGFzTG9hZGVkTmFtZXNwYWNlKG5hbWVzcGFjZSkpIHtcbiAgICAgIHRoaXMubG9nZ2VyLndhcm4oYGRpZCBub3Qgc2F2ZSBrZXkgXCIke2tleX1cIiBhcyB0aGUgbmFtZXNwYWNlIFwiJHtuYW1lc3BhY2V9XCIgd2FzIG5vdCB5ZXQgbG9hZGVkYCwgJ1RoaXMgbWVhbnMgc29tZXRoaW5nIElTIFdST05HIGluIHlvdXIgc2V0dXAuIFlvdSBhY2Nlc3MgdGhlIHQgZnVuY3Rpb24gYmVmb3JlIGkxOG5leHQuaW5pdCAvIGkxOG5leHQubG9hZE5hbWVzcGFjZSAvIGkxOG5leHQuY2hhbmdlTGFuZ3VhZ2Ugd2FzIGRvbmUuIFdhaXQgZm9yIHRoZSBjYWxsYmFjayBvciBQcm9taXNlIHRvIHJlc29sdmUgYmVmb3JlIGFjY2Vzc2luZyBpdCEhIScpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoa2V5ID09PSB1bmRlZmluZWQgfHwga2V5ID09PSBudWxsIHx8IGtleSA9PT0gJycpIHJldHVybjtcbiAgICBpZiAodGhpcy5iYWNrZW5kICYmIHRoaXMuYmFja2VuZC5jcmVhdGUpIHtcbiAgICAgIGNvbnN0IG9wdHMgPSB7XG4gICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgIGlzVXBkYXRlXG4gICAgICB9O1xuICAgICAgY29uc3QgZmMgPSB0aGlzLmJhY2tlbmQuY3JlYXRlLmJpbmQodGhpcy5iYWNrZW5kKTtcbiAgICAgIGlmIChmYy5sZW5ndGggPCA2KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgbGV0IHI7XG4gICAgICAgICAgaWYgKGZjLmxlbmd0aCA9PT0gNSkge1xuICAgICAgICAgICAgciA9IGZjKGxhbmd1YWdlcywgbmFtZXNwYWNlLCBrZXksIGZhbGxiYWNrVmFsdWUsIG9wdHMpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByID0gZmMobGFuZ3VhZ2VzLCBuYW1lc3BhY2UsIGtleSwgZmFsbGJhY2tWYWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChyICYmIHR5cGVvZiByLnRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHIudGhlbihkYXRhID0+IGNsYihudWxsLCBkYXRhKSkuY2F0Y2goY2xiKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2xiKG51bGwsIHIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgY2xiKGVycik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZjKGxhbmd1YWdlcywgbmFtZXNwYWNlLCBrZXksIGZhbGxiYWNrVmFsdWUsIGNsYiwgb3B0cyk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghbGFuZ3VhZ2VzIHx8ICFsYW5ndWFnZXNbMF0pIHJldHVybjtcbiAgICB0aGlzLnN0b3JlLmFkZFJlc291cmNlKGxhbmd1YWdlc1swXSwgbmFtZXNwYWNlLCBrZXksIGZhbGxiYWNrVmFsdWUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldCgpIHtcbiAgcmV0dXJuIHtcbiAgICBkZWJ1ZzogZmFsc2UsXG4gICAgaW5pdEltbWVkaWF0ZTogdHJ1ZSxcbiAgICBuczogWyd0cmFuc2xhdGlvbiddLFxuICAgIGRlZmF1bHROUzogWyd0cmFuc2xhdGlvbiddLFxuICAgIGZhbGxiYWNrTG5nOiBbJ2RldiddLFxuICAgIGZhbGxiYWNrTlM6IGZhbHNlLFxuICAgIHN1cHBvcnRlZExuZ3M6IGZhbHNlLFxuICAgIG5vbkV4cGxpY2l0U3VwcG9ydGVkTG5nczogZmFsc2UsXG4gICAgbG9hZDogJ2FsbCcsXG4gICAgcHJlbG9hZDogZmFsc2UsXG4gICAgc2ltcGxpZnlQbHVyYWxTdWZmaXg6IHRydWUsXG4gICAga2V5U2VwYXJhdG9yOiAnLicsXG4gICAgbnNTZXBhcmF0b3I6ICc6JyxcbiAgICBwbHVyYWxTZXBhcmF0b3I6ICdfJyxcbiAgICBjb250ZXh0U2VwYXJhdG9yOiAnXycsXG4gICAgcGFydGlhbEJ1bmRsZWRMYW5ndWFnZXM6IGZhbHNlLFxuICAgIHNhdmVNaXNzaW5nOiBmYWxzZSxcbiAgICB1cGRhdGVNaXNzaW5nOiBmYWxzZSxcbiAgICBzYXZlTWlzc2luZ1RvOiAnZmFsbGJhY2snLFxuICAgIHNhdmVNaXNzaW5nUGx1cmFsczogdHJ1ZSxcbiAgICBtaXNzaW5nS2V5SGFuZGxlcjogZmFsc2UsXG4gICAgbWlzc2luZ0ludGVycG9sYXRpb25IYW5kbGVyOiBmYWxzZSxcbiAgICBwb3N0UHJvY2VzczogZmFsc2UsXG4gICAgcG9zdFByb2Nlc3NQYXNzUmVzb2x2ZWQ6IGZhbHNlLFxuICAgIHJldHVybk51bGw6IGZhbHNlLFxuICAgIHJldHVybkVtcHR5U3RyaW5nOiB0cnVlLFxuICAgIHJldHVybk9iamVjdHM6IGZhbHNlLFxuICAgIGpvaW5BcnJheXM6IGZhbHNlLFxuICAgIHJldHVybmVkT2JqZWN0SGFuZGxlcjogZmFsc2UsXG4gICAgcGFyc2VNaXNzaW5nS2V5SGFuZGxlcjogZmFsc2UsXG4gICAgYXBwZW5kTmFtZXNwYWNlVG9NaXNzaW5nS2V5OiBmYWxzZSxcbiAgICBhcHBlbmROYW1lc3BhY2VUb0NJTW9kZTogZmFsc2UsXG4gICAgb3ZlcmxvYWRUcmFuc2xhdGlvbk9wdGlvbkhhbmRsZXI6IGZ1bmN0aW9uIGhhbmRsZShhcmdzKSB7XG4gICAgICBsZXQgcmV0ID0ge307XG4gICAgICBpZiAodHlwZW9mIGFyZ3NbMV0gPT09ICdvYmplY3QnKSByZXQgPSBhcmdzWzFdO1xuICAgICAgaWYgKHR5cGVvZiBhcmdzWzFdID09PSAnc3RyaW5nJykgcmV0LmRlZmF1bHRWYWx1ZSA9IGFyZ3NbMV07XG4gICAgICBpZiAodHlwZW9mIGFyZ3NbMl0gPT09ICdzdHJpbmcnKSByZXQudERlc2NyaXB0aW9uID0gYXJnc1syXTtcbiAgICAgIGlmICh0eXBlb2YgYXJnc1syXSA9PT0gJ29iamVjdCcgfHwgdHlwZW9mIGFyZ3NbM10gPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSBhcmdzWzNdIHx8IGFyZ3NbMl07XG4gICAgICAgIE9iamVjdC5rZXlzKG9wdGlvbnMpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICByZXRba2V5XSA9IG9wdGlvbnNba2V5XTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH0sXG4gICAgaW50ZXJwb2xhdGlvbjoge1xuICAgICAgZXNjYXBlVmFsdWU6IHRydWUsXG4gICAgICBmb3JtYXQ6IHZhbHVlID0+IHZhbHVlLFxuICAgICAgcHJlZml4OiAne3snLFxuICAgICAgc3VmZml4OiAnfX0nLFxuICAgICAgZm9ybWF0U2VwYXJhdG9yOiAnLCcsXG4gICAgICB1bmVzY2FwZVByZWZpeDogJy0nLFxuICAgICAgbmVzdGluZ1ByZWZpeDogJyR0KCcsXG4gICAgICBuZXN0aW5nU3VmZml4OiAnKScsXG4gICAgICBuZXN0aW5nT3B0aW9uc1NlcGFyYXRvcjogJywnLFxuICAgICAgbWF4UmVwbGFjZXM6IDEwMDAsXG4gICAgICBza2lwT25WYXJpYWJsZXM6IHRydWVcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiB0cmFuc2Zvcm1PcHRpb25zKG9wdGlvbnMpIHtcbiAgaWYgKHR5cGVvZiBvcHRpb25zLm5zID09PSAnc3RyaW5nJykgb3B0aW9ucy5ucyA9IFtvcHRpb25zLm5zXTtcbiAgaWYgKHR5cGVvZiBvcHRpb25zLmZhbGxiYWNrTG5nID09PSAnc3RyaW5nJykgb3B0aW9ucy5mYWxsYmFja0xuZyA9IFtvcHRpb25zLmZhbGxiYWNrTG5nXTtcbiAgaWYgKHR5cGVvZiBvcHRpb25zLmZhbGxiYWNrTlMgPT09ICdzdHJpbmcnKSBvcHRpb25zLmZhbGxiYWNrTlMgPSBbb3B0aW9ucy5mYWxsYmFja05TXTtcbiAgaWYgKG9wdGlvbnMuc3VwcG9ydGVkTG5ncyAmJiBvcHRpb25zLnN1cHBvcnRlZExuZ3MuaW5kZXhPZignY2ltb2RlJykgPCAwKSB7XG4gICAgb3B0aW9ucy5zdXBwb3J0ZWRMbmdzID0gb3B0aW9ucy5zdXBwb3J0ZWRMbmdzLmNvbmNhdChbJ2NpbW9kZSddKTtcbiAgfVxuICByZXR1cm4gb3B0aW9ucztcbn1cblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5mdW5jdGlvbiBiaW5kTWVtYmVyRnVuY3Rpb25zKGluc3QpIHtcbiAgY29uc3QgbWVtcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKE9iamVjdC5nZXRQcm90b3R5cGVPZihpbnN0KSk7XG4gIG1lbXMuZm9yRWFjaChtZW0gPT4ge1xuICAgIGlmICh0eXBlb2YgaW5zdFttZW1dID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpbnN0W21lbV0gPSBpbnN0W21lbV0uYmluZChpbnN0KTtcbiAgICB9XG4gIH0pO1xufVxuY2xhc3MgSTE4biBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIGxldCBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICBsZXQgY2FsbGJhY2sgPSBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZDtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMub3B0aW9ucyA9IHRyYW5zZm9ybU9wdGlvbnMob3B0aW9ucyk7XG4gICAgdGhpcy5zZXJ2aWNlcyA9IHt9O1xuICAgIHRoaXMubG9nZ2VyID0gYmFzZUxvZ2dlcjtcbiAgICB0aGlzLm1vZHVsZXMgPSB7XG4gICAgICBleHRlcm5hbDogW11cbiAgICB9O1xuICAgIGJpbmRNZW1iZXJGdW5jdGlvbnModGhpcyk7XG4gICAgaWYgKGNhbGxiYWNrICYmICF0aGlzLmlzSW5pdGlhbGl6ZWQgJiYgIW9wdGlvbnMuaXNDbG9uZSkge1xuICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuaW5pdEltbWVkaWF0ZSkge1xuICAgICAgICB0aGlzLmluaXQob3B0aW9ucywgY2FsbGJhY2spO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB0aGlzLmluaXQob3B0aW9ucywgY2FsbGJhY2spO1xuICAgICAgfSwgMCk7XG4gICAgfVxuICB9XG4gIGluaXQoKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICBsZXQgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgbGV0IGNhbGxiYWNrID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQ7XG4gICAgdGhpcy5pc0luaXRpYWxpemluZyA9IHRydWU7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjYWxsYmFjayA9IG9wdGlvbnM7XG4gICAgICBvcHRpb25zID0ge307XG4gICAgfVxuICAgIGlmICghb3B0aW9ucy5kZWZhdWx0TlMgJiYgb3B0aW9ucy5kZWZhdWx0TlMgIT09IGZhbHNlICYmIG9wdGlvbnMubnMpIHtcbiAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5ucyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgb3B0aW9ucy5kZWZhdWx0TlMgPSBvcHRpb25zLm5zO1xuICAgICAgfSBlbHNlIGlmIChvcHRpb25zLm5zLmluZGV4T2YoJ3RyYW5zbGF0aW9uJykgPCAwKSB7XG4gICAgICAgIG9wdGlvbnMuZGVmYXVsdE5TID0gb3B0aW9ucy5uc1swXTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgZGVmT3B0cyA9IGdldCgpO1xuICAgIHRoaXMub3B0aW9ucyA9IHtcbiAgICAgIC4uLmRlZk9wdHMsXG4gICAgICAuLi50aGlzLm9wdGlvbnMsXG4gICAgICAuLi50cmFuc2Zvcm1PcHRpb25zKG9wdGlvbnMpXG4gICAgfTtcbiAgICBpZiAodGhpcy5vcHRpb25zLmNvbXBhdGliaWxpdHlBUEkgIT09ICd2MScpIHtcbiAgICAgIHRoaXMub3B0aW9ucy5pbnRlcnBvbGF0aW9uID0ge1xuICAgICAgICAuLi5kZWZPcHRzLmludGVycG9sYXRpb24sXG4gICAgICAgIC4uLnRoaXMub3B0aW9ucy5pbnRlcnBvbGF0aW9uXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5rZXlTZXBhcmF0b3IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5vcHRpb25zLnVzZXJEZWZpbmVkS2V5U2VwYXJhdG9yID0gb3B0aW9ucy5rZXlTZXBhcmF0b3I7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLm5zU2VwYXJhdG9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMub3B0aW9ucy51c2VyRGVmaW5lZE5zU2VwYXJhdG9yID0gb3B0aW9ucy5uc1NlcGFyYXRvcjtcbiAgICB9XG4gICAgZnVuY3Rpb24gY3JlYXRlQ2xhc3NPbkRlbWFuZChDbGFzc09yT2JqZWN0KSB7XG4gICAgICBpZiAoIUNsYXNzT3JPYmplY3QpIHJldHVybiBudWxsO1xuICAgICAgaWYgKHR5cGVvZiBDbGFzc09yT2JqZWN0ID09PSAnZnVuY3Rpb24nKSByZXR1cm4gbmV3IENsYXNzT3JPYmplY3QoKTtcbiAgICAgIHJldHVybiBDbGFzc09yT2JqZWN0O1xuICAgIH1cbiAgICBpZiAoIXRoaXMub3B0aW9ucy5pc0Nsb25lKSB7XG4gICAgICBpZiAodGhpcy5tb2R1bGVzLmxvZ2dlcikge1xuICAgICAgICBiYXNlTG9nZ2VyLmluaXQoY3JlYXRlQ2xhc3NPbkRlbWFuZCh0aGlzLm1vZHVsZXMubG9nZ2VyKSwgdGhpcy5vcHRpb25zKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJhc2VMb2dnZXIuaW5pdChudWxsLCB0aGlzLm9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgbGV0IGZvcm1hdHRlcjtcbiAgICAgIGlmICh0aGlzLm1vZHVsZXMuZm9ybWF0dGVyKSB7XG4gICAgICAgIGZvcm1hdHRlciA9IHRoaXMubW9kdWxlcy5mb3JtYXR0ZXI7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBJbnRsICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBmb3JtYXR0ZXIgPSBGb3JtYXR0ZXI7XG4gICAgICB9XG4gICAgICBjb25zdCBsdSA9IG5ldyBMYW5ndWFnZVV0aWwodGhpcy5vcHRpb25zKTtcbiAgICAgIHRoaXMuc3RvcmUgPSBuZXcgUmVzb3VyY2VTdG9yZSh0aGlzLm9wdGlvbnMucmVzb3VyY2VzLCB0aGlzLm9wdGlvbnMpO1xuICAgICAgY29uc3QgcyA9IHRoaXMuc2VydmljZXM7XG4gICAgICBzLmxvZ2dlciA9IGJhc2VMb2dnZXI7XG4gICAgICBzLnJlc291cmNlU3RvcmUgPSB0aGlzLnN0b3JlO1xuICAgICAgcy5sYW5ndWFnZVV0aWxzID0gbHU7XG4gICAgICBzLnBsdXJhbFJlc29sdmVyID0gbmV3IFBsdXJhbFJlc29sdmVyKGx1LCB7XG4gICAgICAgIHByZXBlbmQ6IHRoaXMub3B0aW9ucy5wbHVyYWxTZXBhcmF0b3IsXG4gICAgICAgIGNvbXBhdGliaWxpdHlKU09OOiB0aGlzLm9wdGlvbnMuY29tcGF0aWJpbGl0eUpTT04sXG4gICAgICAgIHNpbXBsaWZ5UGx1cmFsU3VmZml4OiB0aGlzLm9wdGlvbnMuc2ltcGxpZnlQbHVyYWxTdWZmaXhcbiAgICAgIH0pO1xuICAgICAgaWYgKGZvcm1hdHRlciAmJiAoIXRoaXMub3B0aW9ucy5pbnRlcnBvbGF0aW9uLmZvcm1hdCB8fCB0aGlzLm9wdGlvbnMuaW50ZXJwb2xhdGlvbi5mb3JtYXQgPT09IGRlZk9wdHMuaW50ZXJwb2xhdGlvbi5mb3JtYXQpKSB7XG4gICAgICAgIHMuZm9ybWF0dGVyID0gY3JlYXRlQ2xhc3NPbkRlbWFuZChmb3JtYXR0ZXIpO1xuICAgICAgICBzLmZvcm1hdHRlci5pbml0KHMsIHRoaXMub3B0aW9ucyk7XG4gICAgICAgIHRoaXMub3B0aW9ucy5pbnRlcnBvbGF0aW9uLmZvcm1hdCA9IHMuZm9ybWF0dGVyLmZvcm1hdC5iaW5kKHMuZm9ybWF0dGVyKTtcbiAgICAgIH1cbiAgICAgIHMuaW50ZXJwb2xhdG9yID0gbmV3IEludGVycG9sYXRvcih0aGlzLm9wdGlvbnMpO1xuICAgICAgcy51dGlscyA9IHtcbiAgICAgICAgaGFzTG9hZGVkTmFtZXNwYWNlOiB0aGlzLmhhc0xvYWRlZE5hbWVzcGFjZS5iaW5kKHRoaXMpXG4gICAgICB9O1xuICAgICAgcy5iYWNrZW5kQ29ubmVjdG9yID0gbmV3IENvbm5lY3RvcihjcmVhdGVDbGFzc09uRGVtYW5kKHRoaXMubW9kdWxlcy5iYWNrZW5kKSwgcy5yZXNvdXJjZVN0b3JlLCBzLCB0aGlzLm9wdGlvbnMpO1xuICAgICAgcy5iYWNrZW5kQ29ubmVjdG9yLm9uKCcqJywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgICBhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgICAgfVxuICAgICAgICBfdGhpcy5lbWl0KGV2ZW50LCAuLi5hcmdzKTtcbiAgICAgIH0pO1xuICAgICAgaWYgKHRoaXMubW9kdWxlcy5sYW5ndWFnZURldGVjdG9yKSB7XG4gICAgICAgIHMubGFuZ3VhZ2VEZXRlY3RvciA9IGNyZWF0ZUNsYXNzT25EZW1hbmQodGhpcy5tb2R1bGVzLmxhbmd1YWdlRGV0ZWN0b3IpO1xuICAgICAgICBpZiAocy5sYW5ndWFnZURldGVjdG9yLmluaXQpIHMubGFuZ3VhZ2VEZXRlY3Rvci5pbml0KHMsIHRoaXMub3B0aW9ucy5kZXRlY3Rpb24sIHRoaXMub3B0aW9ucyk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5tb2R1bGVzLmkxOG5Gb3JtYXQpIHtcbiAgICAgICAgcy5pMThuRm9ybWF0ID0gY3JlYXRlQ2xhc3NPbkRlbWFuZCh0aGlzLm1vZHVsZXMuaTE4bkZvcm1hdCk7XG4gICAgICAgIGlmIChzLmkxOG5Gb3JtYXQuaW5pdCkgcy5pMThuRm9ybWF0LmluaXQodGhpcyk7XG4gICAgICB9XG4gICAgICB0aGlzLnRyYW5zbGF0b3IgPSBuZXcgVHJhbnNsYXRvcih0aGlzLnNlcnZpY2VzLCB0aGlzLm9wdGlvbnMpO1xuICAgICAgdGhpcy50cmFuc2xhdG9yLm9uKCcqJywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMiA+IDEgPyBfbGVuMiAtIDEgOiAwKSwgX2tleTIgPSAxOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgICAgYXJnc1tfa2V5MiAtIDFdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICAgICAgfVxuICAgICAgICBfdGhpcy5lbWl0KGV2ZW50LCAuLi5hcmdzKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5tb2R1bGVzLmV4dGVybmFsLmZvckVhY2gobSA9PiB7XG4gICAgICAgIGlmIChtLmluaXQpIG0uaW5pdCh0aGlzKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzLmZvcm1hdCA9IHRoaXMub3B0aW9ucy5pbnRlcnBvbGF0aW9uLmZvcm1hdDtcbiAgICBpZiAoIWNhbGxiYWNrKSBjYWxsYmFjayA9IG5vb3A7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5mYWxsYmFja0xuZyAmJiAhdGhpcy5zZXJ2aWNlcy5sYW5ndWFnZURldGVjdG9yICYmICF0aGlzLm9wdGlvbnMubG5nKSB7XG4gICAgICBjb25zdCBjb2RlcyA9IHRoaXMuc2VydmljZXMubGFuZ3VhZ2VVdGlscy5nZXRGYWxsYmFja0NvZGVzKHRoaXMub3B0aW9ucy5mYWxsYmFja0xuZyk7XG4gICAgICBpZiAoY29kZXMubGVuZ3RoID4gMCAmJiBjb2Rlc1swXSAhPT0gJ2RldicpIHRoaXMub3B0aW9ucy5sbmcgPSBjb2Rlc1swXTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLnNlcnZpY2VzLmxhbmd1YWdlRGV0ZWN0b3IgJiYgIXRoaXMub3B0aW9ucy5sbmcpIHtcbiAgICAgIHRoaXMubG9nZ2VyLndhcm4oJ2luaXQ6IG5vIGxhbmd1YWdlRGV0ZWN0b3IgaXMgdXNlZCBhbmQgbm8gbG5nIGlzIGRlZmluZWQnKTtcbiAgICB9XG4gICAgY29uc3Qgc3RvcmVBcGkgPSBbJ2dldFJlc291cmNlJywgJ2hhc1Jlc291cmNlQnVuZGxlJywgJ2dldFJlc291cmNlQnVuZGxlJywgJ2dldERhdGFCeUxhbmd1YWdlJ107XG4gICAgc3RvcmVBcGkuZm9yRWFjaChmY05hbWUgPT4ge1xuICAgICAgdGhpc1tmY05hbWVdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX3RoaXMuc3RvcmVbZmNOYW1lXSguLi5hcmd1bWVudHMpO1xuICAgICAgfTtcbiAgICB9KTtcbiAgICBjb25zdCBzdG9yZUFwaUNoYWluZWQgPSBbJ2FkZFJlc291cmNlJywgJ2FkZFJlc291cmNlcycsICdhZGRSZXNvdXJjZUJ1bmRsZScsICdyZW1vdmVSZXNvdXJjZUJ1bmRsZSddO1xuICAgIHN0b3JlQXBpQ2hhaW5lZC5mb3JFYWNoKGZjTmFtZSA9PiB7XG4gICAgICB0aGlzW2ZjTmFtZV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzLnN0b3JlW2ZjTmFtZV0oLi4uYXJndW1lbnRzKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgICAgfTtcbiAgICB9KTtcbiAgICBjb25zdCBkZWZlcnJlZCA9IGRlZmVyKCk7XG4gICAgY29uc3QgbG9hZCA9ICgpID0+IHtcbiAgICAgIGNvbnN0IGZpbmlzaCA9IChlcnIsIHQpID0+IHtcbiAgICAgICAgdGhpcy5pc0luaXRpYWxpemluZyA9IGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5pc0luaXRpYWxpemVkICYmICF0aGlzLmluaXRpYWxpemVkU3RvcmVPbmNlKSB0aGlzLmxvZ2dlci53YXJuKCdpbml0OiBpMThuZXh0IGlzIGFscmVhZHkgaW5pdGlhbGl6ZWQuIFlvdSBzaG91bGQgY2FsbCBpbml0IGp1c3Qgb25jZSEnKTtcbiAgICAgICAgdGhpcy5pc0luaXRpYWxpemVkID0gdHJ1ZTtcbiAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuaXNDbG9uZSkgdGhpcy5sb2dnZXIubG9nKCdpbml0aWFsaXplZCcsIHRoaXMub3B0aW9ucyk7XG4gICAgICAgIHRoaXMuZW1pdCgnaW5pdGlhbGl6ZWQnLCB0aGlzLm9wdGlvbnMpO1xuICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKHQpO1xuICAgICAgICBjYWxsYmFjayhlcnIsIHQpO1xuICAgICAgfTtcbiAgICAgIGlmICh0aGlzLmxhbmd1YWdlcyAmJiB0aGlzLm9wdGlvbnMuY29tcGF0aWJpbGl0eUFQSSAhPT0gJ3YxJyAmJiAhdGhpcy5pc0luaXRpYWxpemVkKSByZXR1cm4gZmluaXNoKG51bGwsIHRoaXMudC5iaW5kKHRoaXMpKTtcbiAgICAgIHRoaXMuY2hhbmdlTGFuZ3VhZ2UodGhpcy5vcHRpb25zLmxuZywgZmluaXNoKTtcbiAgICB9O1xuICAgIGlmICh0aGlzLm9wdGlvbnMucmVzb3VyY2VzIHx8ICF0aGlzLm9wdGlvbnMuaW5pdEltbWVkaWF0ZSkge1xuICAgICAgbG9hZCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZXRUaW1lb3V0KGxvYWQsIDApO1xuICAgIH1cbiAgICByZXR1cm4gZGVmZXJyZWQ7XG4gIH1cbiAgbG9hZFJlc291cmNlcyhsYW5ndWFnZSkge1xuICAgIGxldCBjYWxsYmFjayA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogbm9vcDtcbiAgICBsZXQgdXNlZENhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgY29uc3QgdXNlZExuZyA9IHR5cGVvZiBsYW5ndWFnZSA9PT0gJ3N0cmluZycgPyBsYW5ndWFnZSA6IHRoaXMubGFuZ3VhZ2U7XG4gICAgaWYgKHR5cGVvZiBsYW5ndWFnZSA9PT0gJ2Z1bmN0aW9uJykgdXNlZENhbGxiYWNrID0gbGFuZ3VhZ2U7XG4gICAgaWYgKCF0aGlzLm9wdGlvbnMucmVzb3VyY2VzIHx8IHRoaXMub3B0aW9ucy5wYXJ0aWFsQnVuZGxlZExhbmd1YWdlcykge1xuICAgICAgaWYgKHVzZWRMbmcgJiYgdXNlZExuZy50b0xvd2VyQ2FzZSgpID09PSAnY2ltb2RlJyAmJiAoIXRoaXMub3B0aW9ucy5wcmVsb2FkIHx8IHRoaXMub3B0aW9ucy5wcmVsb2FkLmxlbmd0aCA9PT0gMCkpIHJldHVybiB1c2VkQ2FsbGJhY2soKTtcbiAgICAgIGNvbnN0IHRvTG9hZCA9IFtdO1xuICAgICAgY29uc3QgYXBwZW5kID0gbG5nID0+IHtcbiAgICAgICAgaWYgKCFsbmcpIHJldHVybjtcbiAgICAgICAgaWYgKGxuZyA9PT0gJ2NpbW9kZScpIHJldHVybjtcbiAgICAgICAgY29uc3QgbG5ncyA9IHRoaXMuc2VydmljZXMubGFuZ3VhZ2VVdGlscy50b1Jlc29sdmVIaWVyYXJjaHkobG5nKTtcbiAgICAgICAgbG5ncy5mb3JFYWNoKGwgPT4ge1xuICAgICAgICAgIGlmIChsID09PSAnY2ltb2RlJykgcmV0dXJuO1xuICAgICAgICAgIGlmICh0b0xvYWQuaW5kZXhPZihsKSA8IDApIHRvTG9hZC5wdXNoKGwpO1xuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICBpZiAoIXVzZWRMbmcpIHtcbiAgICAgICAgY29uc3QgZmFsbGJhY2tzID0gdGhpcy5zZXJ2aWNlcy5sYW5ndWFnZVV0aWxzLmdldEZhbGxiYWNrQ29kZXModGhpcy5vcHRpb25zLmZhbGxiYWNrTG5nKTtcbiAgICAgICAgZmFsbGJhY2tzLmZvckVhY2gobCA9PiBhcHBlbmQobCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXBwZW5kKHVzZWRMbmcpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5wcmVsb2FkKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy5wcmVsb2FkLmZvckVhY2gobCA9PiBhcHBlbmQobCkpO1xuICAgICAgfVxuICAgICAgdGhpcy5zZXJ2aWNlcy5iYWNrZW5kQ29ubmVjdG9yLmxvYWQodG9Mb2FkLCB0aGlzLm9wdGlvbnMubnMsIGUgPT4ge1xuICAgICAgICBpZiAoIWUgJiYgIXRoaXMucmVzb2x2ZWRMYW5ndWFnZSAmJiB0aGlzLmxhbmd1YWdlKSB0aGlzLnNldFJlc29sdmVkTGFuZ3VhZ2UodGhpcy5sYW5ndWFnZSk7XG4gICAgICAgIHVzZWRDYWxsYmFjayhlKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB1c2VkQ2FsbGJhY2sobnVsbCk7XG4gICAgfVxuICB9XG4gIHJlbG9hZFJlc291cmNlcyhsbmdzLCBucywgY2FsbGJhY2spIHtcbiAgICBjb25zdCBkZWZlcnJlZCA9IGRlZmVyKCk7XG4gICAgaWYgKCFsbmdzKSBsbmdzID0gdGhpcy5sYW5ndWFnZXM7XG4gICAgaWYgKCFucykgbnMgPSB0aGlzLm9wdGlvbnMubnM7XG4gICAgaWYgKCFjYWxsYmFjaykgY2FsbGJhY2sgPSBub29wO1xuICAgIHRoaXMuc2VydmljZXMuYmFja2VuZENvbm5lY3Rvci5yZWxvYWQobG5ncywgbnMsIGVyciA9PiB7XG4gICAgICBkZWZlcnJlZC5yZXNvbHZlKCk7XG4gICAgICBjYWxsYmFjayhlcnIpO1xuICAgIH0pO1xuICAgIHJldHVybiBkZWZlcnJlZDtcbiAgfVxuICB1c2UobW9kdWxlKSB7XG4gICAgaWYgKCFtb2R1bGUpIHRocm93IG5ldyBFcnJvcignWW91IGFyZSBwYXNzaW5nIGFuIHVuZGVmaW5lZCBtb2R1bGUhIFBsZWFzZSBjaGVjayB0aGUgb2JqZWN0IHlvdSBhcmUgcGFzc2luZyB0byBpMThuZXh0LnVzZSgpJyk7XG4gICAgaWYgKCFtb2R1bGUudHlwZSkgdGhyb3cgbmV3IEVycm9yKCdZb3UgYXJlIHBhc3NpbmcgYSB3cm9uZyBtb2R1bGUhIFBsZWFzZSBjaGVjayB0aGUgb2JqZWN0IHlvdSBhcmUgcGFzc2luZyB0byBpMThuZXh0LnVzZSgpJyk7XG4gICAgaWYgKG1vZHVsZS50eXBlID09PSAnYmFja2VuZCcpIHtcbiAgICAgIHRoaXMubW9kdWxlcy5iYWNrZW5kID0gbW9kdWxlO1xuICAgIH1cbiAgICBpZiAobW9kdWxlLnR5cGUgPT09ICdsb2dnZXInIHx8IG1vZHVsZS5sb2cgJiYgbW9kdWxlLndhcm4gJiYgbW9kdWxlLmVycm9yKSB7XG4gICAgICB0aGlzLm1vZHVsZXMubG9nZ2VyID0gbW9kdWxlO1xuICAgIH1cbiAgICBpZiAobW9kdWxlLnR5cGUgPT09ICdsYW5ndWFnZURldGVjdG9yJykge1xuICAgICAgdGhpcy5tb2R1bGVzLmxhbmd1YWdlRGV0ZWN0b3IgPSBtb2R1bGU7XG4gICAgfVxuICAgIGlmIChtb2R1bGUudHlwZSA9PT0gJ2kxOG5Gb3JtYXQnKSB7XG4gICAgICB0aGlzLm1vZHVsZXMuaTE4bkZvcm1hdCA9IG1vZHVsZTtcbiAgICB9XG4gICAgaWYgKG1vZHVsZS50eXBlID09PSAncG9zdFByb2Nlc3NvcicpIHtcbiAgICAgIHBvc3RQcm9jZXNzb3IuYWRkUG9zdFByb2Nlc3Nvcihtb2R1bGUpO1xuICAgIH1cbiAgICBpZiAobW9kdWxlLnR5cGUgPT09ICdmb3JtYXR0ZXInKSB7XG4gICAgICB0aGlzLm1vZHVsZXMuZm9ybWF0dGVyID0gbW9kdWxlO1xuICAgIH1cbiAgICBpZiAobW9kdWxlLnR5cGUgPT09ICczcmRQYXJ0eScpIHtcbiAgICAgIHRoaXMubW9kdWxlcy5leHRlcm5hbC5wdXNoKG1vZHVsZSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHNldFJlc29sdmVkTGFuZ3VhZ2UobCkge1xuICAgIGlmICghbCB8fCAhdGhpcy5sYW5ndWFnZXMpIHJldHVybjtcbiAgICBpZiAoWydjaW1vZGUnLCAnZGV2J10uaW5kZXhPZihsKSA+IC0xKSByZXR1cm47XG4gICAgZm9yIChsZXQgbGkgPSAwOyBsaSA8IHRoaXMubGFuZ3VhZ2VzLmxlbmd0aDsgbGkrKykge1xuICAgICAgY29uc3QgbG5nSW5MbmdzID0gdGhpcy5sYW5ndWFnZXNbbGldO1xuICAgICAgaWYgKFsnY2ltb2RlJywgJ2RldiddLmluZGV4T2YobG5nSW5MbmdzKSA+IC0xKSBjb250aW51ZTtcbiAgICAgIGlmICh0aGlzLnN0b3JlLmhhc0xhbmd1YWdlU29tZVRyYW5zbGF0aW9ucyhsbmdJbkxuZ3MpKSB7XG4gICAgICAgIHRoaXMucmVzb2x2ZWRMYW5ndWFnZSA9IGxuZ0luTG5ncztcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGNoYW5nZUxhbmd1YWdlKGxuZywgY2FsbGJhY2spIHtcbiAgICB2YXIgX3RoaXMyID0gdGhpcztcbiAgICB0aGlzLmlzTGFuZ3VhZ2VDaGFuZ2luZ1RvID0gbG5nO1xuICAgIGNvbnN0IGRlZmVycmVkID0gZGVmZXIoKTtcbiAgICB0aGlzLmVtaXQoJ2xhbmd1YWdlQ2hhbmdpbmcnLCBsbmcpO1xuICAgIGNvbnN0IHNldExuZ1Byb3BzID0gbCA9PiB7XG4gICAgICB0aGlzLmxhbmd1YWdlID0gbDtcbiAgICAgIHRoaXMubGFuZ3VhZ2VzID0gdGhpcy5zZXJ2aWNlcy5sYW5ndWFnZVV0aWxzLnRvUmVzb2x2ZUhpZXJhcmNoeShsKTtcbiAgICAgIHRoaXMucmVzb2x2ZWRMYW5ndWFnZSA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuc2V0UmVzb2x2ZWRMYW5ndWFnZShsKTtcbiAgICB9O1xuICAgIGNvbnN0IGRvbmUgPSAoZXJyLCBsKSA9PiB7XG4gICAgICBpZiAobCkge1xuICAgICAgICBzZXRMbmdQcm9wcyhsKTtcbiAgICAgICAgdGhpcy50cmFuc2xhdG9yLmNoYW5nZUxhbmd1YWdlKGwpO1xuICAgICAgICB0aGlzLmlzTGFuZ3VhZ2VDaGFuZ2luZ1RvID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmVtaXQoJ2xhbmd1YWdlQ2hhbmdlZCcsIGwpO1xuICAgICAgICB0aGlzLmxvZ2dlci5sb2coJ2xhbmd1YWdlQ2hhbmdlZCcsIGwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5pc0xhbmd1YWdlQ2hhbmdpbmdUbyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIGRlZmVycmVkLnJlc29sdmUoZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX3RoaXMyLnQoLi4uYXJndW1lbnRzKTtcbiAgICAgIH0pO1xuICAgICAgaWYgKGNhbGxiYWNrKSBjYWxsYmFjayhlcnIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzMi50KC4uLmFyZ3VtZW50cyk7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IHNldExuZyA9IGxuZ3MgPT4ge1xuICAgICAgaWYgKCFsbmcgJiYgIWxuZ3MgJiYgdGhpcy5zZXJ2aWNlcy5sYW5ndWFnZURldGVjdG9yKSBsbmdzID0gW107XG4gICAgICBjb25zdCBsID0gdHlwZW9mIGxuZ3MgPT09ICdzdHJpbmcnID8gbG5ncyA6IHRoaXMuc2VydmljZXMubGFuZ3VhZ2VVdGlscy5nZXRCZXN0TWF0Y2hGcm9tQ29kZXMobG5ncyk7XG4gICAgICBpZiAobCkge1xuICAgICAgICBpZiAoIXRoaXMubGFuZ3VhZ2UpIHtcbiAgICAgICAgICBzZXRMbmdQcm9wcyhsKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMudHJhbnNsYXRvci5sYW5ndWFnZSkgdGhpcy50cmFuc2xhdG9yLmNoYW5nZUxhbmd1YWdlKGwpO1xuICAgICAgICBpZiAodGhpcy5zZXJ2aWNlcy5sYW5ndWFnZURldGVjdG9yICYmIHRoaXMuc2VydmljZXMubGFuZ3VhZ2VEZXRlY3Rvci5jYWNoZVVzZXJMYW5ndWFnZSkgdGhpcy5zZXJ2aWNlcy5sYW5ndWFnZURldGVjdG9yLmNhY2hlVXNlckxhbmd1YWdlKGwpO1xuICAgICAgfVxuICAgICAgdGhpcy5sb2FkUmVzb3VyY2VzKGwsIGVyciA9PiB7XG4gICAgICAgIGRvbmUoZXJyLCBsKTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgaWYgKCFsbmcgJiYgdGhpcy5zZXJ2aWNlcy5sYW5ndWFnZURldGVjdG9yICYmICF0aGlzLnNlcnZpY2VzLmxhbmd1YWdlRGV0ZWN0b3IuYXN5bmMpIHtcbiAgICAgIHNldExuZyh0aGlzLnNlcnZpY2VzLmxhbmd1YWdlRGV0ZWN0b3IuZGV0ZWN0KCkpO1xuICAgIH0gZWxzZSBpZiAoIWxuZyAmJiB0aGlzLnNlcnZpY2VzLmxhbmd1YWdlRGV0ZWN0b3IgJiYgdGhpcy5zZXJ2aWNlcy5sYW5ndWFnZURldGVjdG9yLmFzeW5jKSB7XG4gICAgICBpZiAodGhpcy5zZXJ2aWNlcy5sYW5ndWFnZURldGVjdG9yLmRldGVjdC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhpcy5zZXJ2aWNlcy5sYW5ndWFnZURldGVjdG9yLmRldGVjdCgpLnRoZW4oc2V0TG5nKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc2VydmljZXMubGFuZ3VhZ2VEZXRlY3Rvci5kZXRlY3Qoc2V0TG5nKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc2V0TG5nKGxuZyk7XG4gICAgfVxuICAgIHJldHVybiBkZWZlcnJlZDtcbiAgfVxuICBnZXRGaXhlZFQobG5nLCBucywga2V5UHJlZml4KSB7XG4gICAgdmFyIF90aGlzMyA9IHRoaXM7XG4gICAgY29uc3QgZml4ZWRUID0gZnVuY3Rpb24gKGtleSwgb3B0cykge1xuICAgICAgbGV0IG9wdGlvbnM7XG4gICAgICBpZiAodHlwZW9mIG9wdHMgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIGZvciAodmFyIF9sZW4zID0gYXJndW1lbnRzLmxlbmd0aCwgcmVzdCA9IG5ldyBBcnJheShfbGVuMyA+IDIgPyBfbGVuMyAtIDIgOiAwKSwgX2tleTMgPSAyOyBfa2V5MyA8IF9sZW4zOyBfa2V5MysrKSB7XG4gICAgICAgICAgcmVzdFtfa2V5MyAtIDJdID0gYXJndW1lbnRzW19rZXkzXTtcbiAgICAgICAgfVxuICAgICAgICBvcHRpb25zID0gX3RoaXMzLm9wdGlvbnMub3ZlcmxvYWRUcmFuc2xhdGlvbk9wdGlvbkhhbmRsZXIoW2tleSwgb3B0c10uY29uY2F0KHJlc3QpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9wdGlvbnMgPSB7XG4gICAgICAgICAgLi4ub3B0c1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgb3B0aW9ucy5sbmcgPSBvcHRpb25zLmxuZyB8fCBmaXhlZFQubG5nO1xuICAgICAgb3B0aW9ucy5sbmdzID0gb3B0aW9ucy5sbmdzIHx8IGZpeGVkVC5sbmdzO1xuICAgICAgb3B0aW9ucy5ucyA9IG9wdGlvbnMubnMgfHwgZml4ZWRULm5zO1xuICAgICAgaWYgKG9wdGlvbnMua2V5UHJlZml4ICE9PSAnJykgb3B0aW9ucy5rZXlQcmVmaXggPSBvcHRpb25zLmtleVByZWZpeCB8fCBrZXlQcmVmaXggfHwgZml4ZWRULmtleVByZWZpeDtcbiAgICAgIGNvbnN0IGtleVNlcGFyYXRvciA9IF90aGlzMy5vcHRpb25zLmtleVNlcGFyYXRvciB8fCAnLic7XG4gICAgICBsZXQgcmVzdWx0S2V5O1xuICAgICAgaWYgKG9wdGlvbnMua2V5UHJlZml4ICYmIEFycmF5LmlzQXJyYXkoa2V5KSkge1xuICAgICAgICByZXN1bHRLZXkgPSBrZXkubWFwKGsgPT4gYCR7b3B0aW9ucy5rZXlQcmVmaXh9JHtrZXlTZXBhcmF0b3J9JHtrfWApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0S2V5ID0gb3B0aW9ucy5rZXlQcmVmaXggPyBgJHtvcHRpb25zLmtleVByZWZpeH0ke2tleVNlcGFyYXRvcn0ke2tleX1gIDoga2V5O1xuICAgICAgfVxuICAgICAgcmV0dXJuIF90aGlzMy50KHJlc3VsdEtleSwgb3B0aW9ucyk7XG4gICAgfTtcbiAgICBpZiAodHlwZW9mIGxuZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGZpeGVkVC5sbmcgPSBsbmc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZpeGVkVC5sbmdzID0gbG5nO1xuICAgIH1cbiAgICBmaXhlZFQubnMgPSBucztcbiAgICBmaXhlZFQua2V5UHJlZml4ID0ga2V5UHJlZml4O1xuICAgIHJldHVybiBmaXhlZFQ7XG4gIH1cbiAgdCgpIHtcbiAgICByZXR1cm4gdGhpcy50cmFuc2xhdG9yICYmIHRoaXMudHJhbnNsYXRvci50cmFuc2xhdGUoLi4uYXJndW1lbnRzKTtcbiAgfVxuICBleGlzdHMoKSB7XG4gICAgcmV0dXJuIHRoaXMudHJhbnNsYXRvciAmJiB0aGlzLnRyYW5zbGF0b3IuZXhpc3RzKC4uLmFyZ3VtZW50cyk7XG4gIH1cbiAgc2V0RGVmYXVsdE5hbWVzcGFjZShucykge1xuICAgIHRoaXMub3B0aW9ucy5kZWZhdWx0TlMgPSBucztcbiAgfVxuICBoYXNMb2FkZWROYW1lc3BhY2UobnMpIHtcbiAgICBsZXQgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgaWYgKCF0aGlzLmlzSW5pdGlhbGl6ZWQpIHtcbiAgICAgIHRoaXMubG9nZ2VyLndhcm4oJ2hhc0xvYWRlZE5hbWVzcGFjZTogaTE4bmV4dCB3YXMgbm90IGluaXRpYWxpemVkJywgdGhpcy5sYW5ndWFnZXMpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoIXRoaXMubGFuZ3VhZ2VzIHx8ICF0aGlzLmxhbmd1YWdlcy5sZW5ndGgpIHtcbiAgICAgIHRoaXMubG9nZ2VyLndhcm4oJ2hhc0xvYWRlZE5hbWVzcGFjZTogaTE4bi5sYW5ndWFnZXMgd2VyZSB1bmRlZmluZWQgb3IgZW1wdHknLCB0aGlzLmxhbmd1YWdlcyk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IGxuZyA9IG9wdGlvbnMubG5nIHx8IHRoaXMucmVzb2x2ZWRMYW5ndWFnZSB8fCB0aGlzLmxhbmd1YWdlc1swXTtcbiAgICBjb25zdCBmYWxsYmFja0xuZyA9IHRoaXMub3B0aW9ucyA/IHRoaXMub3B0aW9ucy5mYWxsYmFja0xuZyA6IGZhbHNlO1xuICAgIGNvbnN0IGxhc3RMbmcgPSB0aGlzLmxhbmd1YWdlc1t0aGlzLmxhbmd1YWdlcy5sZW5ndGggLSAxXTtcbiAgICBpZiAobG5nLnRvTG93ZXJDYXNlKCkgPT09ICdjaW1vZGUnKSByZXR1cm4gdHJ1ZTtcbiAgICBjb25zdCBsb2FkTm90UGVuZGluZyA9IChsLCBuKSA9PiB7XG4gICAgICBjb25zdCBsb2FkU3RhdGUgPSB0aGlzLnNlcnZpY2VzLmJhY2tlbmRDb25uZWN0b3Iuc3RhdGVbYCR7bH18JHtufWBdO1xuICAgICAgcmV0dXJuIGxvYWRTdGF0ZSA9PT0gLTEgfHwgbG9hZFN0YXRlID09PSAyO1xuICAgIH07XG4gICAgaWYgKG9wdGlvbnMucHJlY2hlY2spIHtcbiAgICAgIGNvbnN0IHByZVJlc3VsdCA9IG9wdGlvbnMucHJlY2hlY2sodGhpcywgbG9hZE5vdFBlbmRpbmcpO1xuICAgICAgaWYgKHByZVJlc3VsdCAhPT0gdW5kZWZpbmVkKSByZXR1cm4gcHJlUmVzdWx0O1xuICAgIH1cbiAgICBpZiAodGhpcy5oYXNSZXNvdXJjZUJ1bmRsZShsbmcsIG5zKSkgcmV0dXJuIHRydWU7XG4gICAgaWYgKCF0aGlzLnNlcnZpY2VzLmJhY2tlbmRDb25uZWN0b3IuYmFja2VuZCB8fCB0aGlzLm9wdGlvbnMucmVzb3VyY2VzICYmICF0aGlzLm9wdGlvbnMucGFydGlhbEJ1bmRsZWRMYW5ndWFnZXMpIHJldHVybiB0cnVlO1xuICAgIGlmIChsb2FkTm90UGVuZGluZyhsbmcsIG5zKSAmJiAoIWZhbGxiYWNrTG5nIHx8IGxvYWROb3RQZW5kaW5nKGxhc3RMbmcsIG5zKSkpIHJldHVybiB0cnVlO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBsb2FkTmFtZXNwYWNlcyhucywgY2FsbGJhY2spIHtcbiAgICBjb25zdCBkZWZlcnJlZCA9IGRlZmVyKCk7XG4gICAgaWYgKCF0aGlzLm9wdGlvbnMubnMpIHtcbiAgICAgIGlmIChjYWxsYmFjaykgY2FsbGJhY2soKTtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBucyA9PT0gJ3N0cmluZycpIG5zID0gW25zXTtcbiAgICBucy5mb3JFYWNoKG4gPT4ge1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5ucy5pbmRleE9mKG4pIDwgMCkgdGhpcy5vcHRpb25zLm5zLnB1c2gobik7XG4gICAgfSk7XG4gICAgdGhpcy5sb2FkUmVzb3VyY2VzKGVyciA9PiB7XG4gICAgICBkZWZlcnJlZC5yZXNvbHZlKCk7XG4gICAgICBpZiAoY2FsbGJhY2spIGNhbGxiYWNrKGVycik7XG4gICAgfSk7XG4gICAgcmV0dXJuIGRlZmVycmVkO1xuICB9XG4gIGxvYWRMYW5ndWFnZXMobG5ncywgY2FsbGJhY2spIHtcbiAgICBjb25zdCBkZWZlcnJlZCA9IGRlZmVyKCk7XG4gICAgaWYgKHR5cGVvZiBsbmdzID09PSAnc3RyaW5nJykgbG5ncyA9IFtsbmdzXTtcbiAgICBjb25zdCBwcmVsb2FkZWQgPSB0aGlzLm9wdGlvbnMucHJlbG9hZCB8fCBbXTtcbiAgICBjb25zdCBuZXdMbmdzID0gbG5ncy5maWx0ZXIobG5nID0+IHByZWxvYWRlZC5pbmRleE9mKGxuZykgPCAwICYmIHRoaXMuc2VydmljZXMubGFuZ3VhZ2VVdGlscy5pc1N1cHBvcnRlZENvZGUobG5nKSk7XG4gICAgaWYgKCFuZXdMbmdzLmxlbmd0aCkge1xuICAgICAgaWYgKGNhbGxiYWNrKSBjYWxsYmFjaygpO1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cbiAgICB0aGlzLm9wdGlvbnMucHJlbG9hZCA9IHByZWxvYWRlZC5jb25jYXQobmV3TG5ncyk7XG4gICAgdGhpcy5sb2FkUmVzb3VyY2VzKGVyciA9PiB7XG4gICAgICBkZWZlcnJlZC5yZXNvbHZlKCk7XG4gICAgICBpZiAoY2FsbGJhY2spIGNhbGxiYWNrKGVycik7XG4gICAgfSk7XG4gICAgcmV0dXJuIGRlZmVycmVkO1xuICB9XG4gIGRpcihsbmcpIHtcbiAgICBpZiAoIWxuZykgbG5nID0gdGhpcy5yZXNvbHZlZExhbmd1YWdlIHx8ICh0aGlzLmxhbmd1YWdlcyAmJiB0aGlzLmxhbmd1YWdlcy5sZW5ndGggPiAwID8gdGhpcy5sYW5ndWFnZXNbMF0gOiB0aGlzLmxhbmd1YWdlKTtcbiAgICBpZiAoIWxuZykgcmV0dXJuICdydGwnO1xuICAgIGNvbnN0IHJ0bExuZ3MgPSBbJ2FyJywgJ3NodScsICdzcXInLCAnc3NoJywgJ3hhYScsICd5aGQnLCAneXVkJywgJ2FhbycsICdhYmgnLCAnYWJ2JywgJ2FjbScsICdhY3EnLCAnYWN3JywgJ2FjeCcsICdhY3knLCAnYWRmJywgJ2FkcycsICdhZWInLCAnYWVjJywgJ2FmYicsICdhanAnLCAnYXBjJywgJ2FwZCcsICdhcmInLCAnYXJxJywgJ2FycycsICdhcnknLCAnYXJ6JywgJ2F1eicsICdhdmwnLCAnYXloJywgJ2F5bCcsICdheW4nLCAnYXlwJywgJ2JieicsICdwZ2EnLCAnaGUnLCAnaXcnLCAncHMnLCAncGJ0JywgJ3BidScsICdwc3QnLCAncHJwJywgJ3ByZCcsICd1ZycsICd1cicsICd5ZGQnLCAneWRzJywgJ3lpaCcsICdqaScsICd5aScsICdoYm8nLCAnbWVuJywgJ3htbicsICdmYScsICdqcHInLCAncGVvJywgJ3BlcycsICdwcnMnLCAnZHYnLCAnc2FtJywgJ2NrYiddO1xuICAgIGNvbnN0IGxhbmd1YWdlVXRpbHMgPSB0aGlzLnNlcnZpY2VzICYmIHRoaXMuc2VydmljZXMubGFuZ3VhZ2VVdGlscyB8fCBuZXcgTGFuZ3VhZ2VVdGlsKGdldCgpKTtcbiAgICByZXR1cm4gcnRsTG5ncy5pbmRleE9mKGxhbmd1YWdlVXRpbHMuZ2V0TGFuZ3VhZ2VQYXJ0RnJvbUNvZGUobG5nKSkgPiAtMSB8fCBsbmcudG9Mb3dlckNhc2UoKS5pbmRleE9mKCctYXJhYicpID4gMSA/ICdydGwnIDogJ2x0cic7XG4gIH1cbiAgc3RhdGljIGNyZWF0ZUluc3RhbmNlKCkge1xuICAgIGxldCBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICBsZXQgY2FsbGJhY2sgPSBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gbmV3IEkxOG4ob3B0aW9ucywgY2FsbGJhY2spO1xuICB9XG4gIGNsb25lSW5zdGFuY2UoKSB7XG4gICAgbGV0IG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgIGxldCBjYWxsYmFjayA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogbm9vcDtcbiAgICBjb25zdCBmb3JrUmVzb3VyY2VTdG9yZSA9IG9wdGlvbnMuZm9ya1Jlc291cmNlU3RvcmU7XG4gICAgaWYgKGZvcmtSZXNvdXJjZVN0b3JlKSBkZWxldGUgb3B0aW9ucy5mb3JrUmVzb3VyY2VTdG9yZTtcbiAgICBjb25zdCBtZXJnZWRPcHRpb25zID0ge1xuICAgICAgLi4udGhpcy5vcHRpb25zLFxuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIC4uLntcbiAgICAgICAgaXNDbG9uZTogdHJ1ZVxuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgY2xvbmUgPSBuZXcgSTE4bihtZXJnZWRPcHRpb25zKTtcbiAgICBpZiAob3B0aW9ucy5kZWJ1ZyAhPT0gdW5kZWZpbmVkIHx8IG9wdGlvbnMucHJlZml4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGNsb25lLmxvZ2dlciA9IGNsb25lLmxvZ2dlci5jbG9uZShvcHRpb25zKTtcbiAgICB9XG4gICAgY29uc3QgbWVtYmVyc1RvQ29weSA9IFsnc3RvcmUnLCAnc2VydmljZXMnLCAnbGFuZ3VhZ2UnXTtcbiAgICBtZW1iZXJzVG9Db3B5LmZvckVhY2gobSA9PiB7XG4gICAgICBjbG9uZVttXSA9IHRoaXNbbV07XG4gICAgfSk7XG4gICAgY2xvbmUuc2VydmljZXMgPSB7XG4gICAgICAuLi50aGlzLnNlcnZpY2VzXG4gICAgfTtcbiAgICBjbG9uZS5zZXJ2aWNlcy51dGlscyA9IHtcbiAgICAgIGhhc0xvYWRlZE5hbWVzcGFjZTogY2xvbmUuaGFzTG9hZGVkTmFtZXNwYWNlLmJpbmQoY2xvbmUpXG4gICAgfTtcbiAgICBpZiAoZm9ya1Jlc291cmNlU3RvcmUpIHtcbiAgICAgIGNsb25lLnN0b3JlID0gbmV3IFJlc291cmNlU3RvcmUodGhpcy5zdG9yZS5kYXRhLCBtZXJnZWRPcHRpb25zKTtcbiAgICAgIGNsb25lLnNlcnZpY2VzLnJlc291cmNlU3RvcmUgPSBjbG9uZS5zdG9yZTtcbiAgICB9XG4gICAgY2xvbmUudHJhbnNsYXRvciA9IG5ldyBUcmFuc2xhdG9yKGNsb25lLnNlcnZpY2VzLCBtZXJnZWRPcHRpb25zKTtcbiAgICBjbG9uZS50cmFuc2xhdG9yLm9uKCcqJywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICBmb3IgKHZhciBfbGVuNCA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjQgPiAxID8gX2xlbjQgLSAxIDogMCksIF9rZXk0ID0gMTsgX2tleTQgPCBfbGVuNDsgX2tleTQrKykge1xuICAgICAgICBhcmdzW19rZXk0IC0gMV0gPSBhcmd1bWVudHNbX2tleTRdO1xuICAgICAgfVxuICAgICAgY2xvbmUuZW1pdChldmVudCwgLi4uYXJncyk7XG4gICAgfSk7XG4gICAgY2xvbmUuaW5pdChtZXJnZWRPcHRpb25zLCBjYWxsYmFjayk7XG4gICAgY2xvbmUudHJhbnNsYXRvci5vcHRpb25zID0gbWVyZ2VkT3B0aW9ucztcbiAgICBjbG9uZS50cmFuc2xhdG9yLmJhY2tlbmRDb25uZWN0b3Iuc2VydmljZXMudXRpbHMgPSB7XG4gICAgICBoYXNMb2FkZWROYW1lc3BhY2U6IGNsb25lLmhhc0xvYWRlZE5hbWVzcGFjZS5iaW5kKGNsb25lKVxuICAgIH07XG4gICAgcmV0dXJuIGNsb25lO1xuICB9XG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgb3B0aW9uczogdGhpcy5vcHRpb25zLFxuICAgICAgc3RvcmU6IHRoaXMuc3RvcmUsXG4gICAgICBsYW5ndWFnZTogdGhpcy5sYW5ndWFnZSxcbiAgICAgIGxhbmd1YWdlczogdGhpcy5sYW5ndWFnZXMsXG4gICAgICByZXNvbHZlZExhbmd1YWdlOiB0aGlzLnJlc29sdmVkTGFuZ3VhZ2VcbiAgICB9O1xuICB9XG59XG5jb25zdCBpbnN0YW5jZSA9IEkxOG4uY3JlYXRlSW5zdGFuY2UoKTtcbmluc3RhbmNlLmNyZWF0ZUluc3RhbmNlID0gSTE4bi5jcmVhdGVJbnN0YW5jZTtcblxuY29uc3QgY3JlYXRlSW5zdGFuY2UgPSBpbnN0YW5jZS5jcmVhdGVJbnN0YW5jZTtcbmNvbnN0IGRpciA9IGluc3RhbmNlLmRpcjtcbmNvbnN0IGluaXQgPSBpbnN0YW5jZS5pbml0O1xuY29uc3QgbG9hZFJlc291cmNlcyA9IGluc3RhbmNlLmxvYWRSZXNvdXJjZXM7XG5jb25zdCByZWxvYWRSZXNvdXJjZXMgPSBpbnN0YW5jZS5yZWxvYWRSZXNvdXJjZXM7XG5jb25zdCB1c2UgPSBpbnN0YW5jZS51c2U7XG5jb25zdCBjaGFuZ2VMYW5ndWFnZSA9IGluc3RhbmNlLmNoYW5nZUxhbmd1YWdlO1xuY29uc3QgZ2V0Rml4ZWRUID0gaW5zdGFuY2UuZ2V0Rml4ZWRUO1xuY29uc3QgdCA9IGluc3RhbmNlLnQ7XG5jb25zdCBleGlzdHMgPSBpbnN0YW5jZS5leGlzdHM7XG5jb25zdCBzZXREZWZhdWx0TmFtZXNwYWNlID0gaW5zdGFuY2Uuc2V0RGVmYXVsdE5hbWVzcGFjZTtcbmNvbnN0IGhhc0xvYWRlZE5hbWVzcGFjZSA9IGluc3RhbmNlLmhhc0xvYWRlZE5hbWVzcGFjZTtcbmNvbnN0IGxvYWROYW1lc3BhY2VzID0gaW5zdGFuY2UubG9hZE5hbWVzcGFjZXM7XG5jb25zdCBsb2FkTGFuZ3VhZ2VzID0gaW5zdGFuY2UubG9hZExhbmd1YWdlcztcblxuZXhwb3J0IHsgY2hhbmdlTGFuZ3VhZ2UsIGNyZWF0ZUluc3RhbmNlLCBpbnN0YW5jZSBhcyBkZWZhdWx0LCBkaXIsIGV4aXN0cywgZ2V0Rml4ZWRULCBoYXNMb2FkZWROYW1lc3BhY2UsIGluaXQsIGxvYWRMYW5ndWFnZXMsIGxvYWROYW1lc3BhY2VzLCBsb2FkUmVzb3VyY2VzLCByZWxvYWRSZXNvdXJjZXMsIHNldERlZmF1bHROYW1lc3BhY2UsIHQsIHVzZSB9O1xuIl0sIm5hbWVzIjpbImNvbnNvbGVMb2dnZXIiLCJ0eXBlIiwibG9nIiwiYXJncyIsIm91dHB1dCIsIndhcm4iLCJlcnJvciIsImNvbnNvbGUiLCJhcHBseSIsIkxvZ2dlciIsImNvbnN0cnVjdG9yIiwiY29uY3JldGVMb2dnZXIiLCJvcHRpb25zIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwidW5kZWZpbmVkIiwiaW5pdCIsInByZWZpeCIsImxvZ2dlciIsImRlYnVnIiwiX2xlbiIsIkFycmF5IiwiX2tleSIsImZvcndhcmQiLCJfbGVuMiIsIl9rZXkyIiwiX2xlbjMiLCJfa2V5MyIsImRlcHJlY2F0ZSIsIl9sZW40IiwiX2tleTQiLCJsdmwiLCJkZWJ1Z09ubHkiLCJjcmVhdGUiLCJtb2R1bGVOYW1lIiwiY2xvbmUiLCJiYXNlTG9nZ2VyIiwiRXZlbnRFbWl0dGVyIiwib2JzZXJ2ZXJzIiwib24iLCJldmVudHMiLCJsaXN0ZW5lciIsInNwbGl0IiwiZm9yRWFjaCIsImV2ZW50IiwiTWFwIiwibnVtTGlzdGVuZXJzIiwiZ2V0Iiwic2V0Iiwib2ZmIiwiZGVsZXRlIiwiZW1pdCIsImNsb25lZCIsImZyb20iLCJlbnRyaWVzIiwiX3JlZiIsIm9ic2VydmVyIiwibnVtVGltZXNBZGRlZCIsImkiLCJfcmVmMiIsImRlZmVyIiwicmVzIiwicmVqIiwicHJvbWlzZSIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwibWFrZVN0cmluZyIsIm9iamVjdCIsImNvcHkiLCJhIiwicyIsInQiLCJtIiwibGFzdE9mUGF0aFNlcGFyYXRvclJlZ0V4cCIsImdldExhc3RPZlBhdGgiLCJwYXRoIiwiRW1wdHkiLCJjbGVhbktleSIsImtleSIsImluZGV4T2YiLCJyZXBsYWNlIiwiY2FuTm90VHJhdmVyc2VEZWVwZXIiLCJzdGFjayIsInN0YWNrSW5kZXgiLCJPYmplY3QiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJvYmoiLCJrIiwic2V0UGF0aCIsIm5ld1ZhbHVlIiwiZSIsInAiLCJzbGljZSIsImxhc3QiLCJwdXNoUGF0aCIsImNvbmNhdCIsInB1c2giLCJnZXRQYXRoIiwiZ2V0UGF0aFdpdGhEZWZhdWx0cyIsImRhdGEiLCJkZWZhdWx0RGF0YSIsInZhbHVlIiwiZGVlcEV4dGVuZCIsInRhcmdldCIsInNvdXJjZSIsIm92ZXJ3cml0ZSIsInByb3AiLCJTdHJpbmciLCJyZWdleEVzY2FwZSIsInN0ciIsIl9lbnRpdHlNYXAiLCJlc2NhcGUiLCJSZWdFeHBDYWNoZSIsImNhcGFjaXR5IiwicmVnRXhwTWFwIiwicmVnRXhwUXVldWUiLCJnZXRSZWdFeHAiLCJwYXR0ZXJuIiwicmVnRXhwRnJvbUNhY2hlIiwicmVnRXhwTmV3IiwiUmVnRXhwIiwic2hpZnQiLCJjaGFycyIsImxvb2tzTGlrZU9iamVjdFBhdGhSZWdFeHBDYWNoZSIsImxvb2tzTGlrZU9iamVjdFBhdGgiLCJuc1NlcGFyYXRvciIsImtleVNlcGFyYXRvciIsInBvc3NpYmxlQ2hhcnMiLCJmaWx0ZXIiLCJjIiwiciIsIm1hcCIsImpvaW4iLCJtYXRjaGVkIiwidGVzdCIsImtpIiwic3Vic3RyaW5nIiwiZGVlcEZpbmQiLCJ0b2tlbnMiLCJjdXJyZW50IiwibmV4dCIsIm5leHRQYXRoIiwiaiIsImdldENsZWFuZWRDb2RlIiwiY29kZSIsIlJlc291cmNlU3RvcmUiLCJucyIsImRlZmF1bHROUyIsImlnbm9yZUpTT05TdHJ1Y3R1cmUiLCJhZGROYW1lc3BhY2VzIiwicmVtb3ZlTmFtZXNwYWNlcyIsImluZGV4Iiwic3BsaWNlIiwiZ2V0UmVzb3VyY2UiLCJsbmciLCJpc0FycmF5IiwicmVzdWx0IiwiYWRkUmVzb3VyY2UiLCJzaWxlbnQiLCJhZGRSZXNvdXJjZXMiLCJyZXNvdXJjZXMiLCJhZGRSZXNvdXJjZUJ1bmRsZSIsImRlZXAiLCJza2lwQ29weSIsInBhY2siLCJKU09OIiwicGFyc2UiLCJzdHJpbmdpZnkiLCJyZW1vdmVSZXNvdXJjZUJ1bmRsZSIsImhhc1Jlc291cmNlQnVuZGxlIiwiZ2V0UmVzb3VyY2VCdW5kbGUiLCJjb21wYXRpYmlsaXR5QVBJIiwiZ2V0RGF0YUJ5TGFuZ3VhZ2UiLCJoYXNMYW5ndWFnZVNvbWVUcmFuc2xhdGlvbnMiLCJuIiwia2V5cyIsImZpbmQiLCJ2IiwidG9KU09OIiwicG9zdFByb2Nlc3NvciIsInByb2Nlc3NvcnMiLCJhZGRQb3N0UHJvY2Vzc29yIiwibW9kdWxlIiwibmFtZSIsImhhbmRsZSIsInRyYW5zbGF0b3IiLCJwcm9jZXNzb3IiLCJwcm9jZXNzIiwiY2hlY2tlZExvYWRlZEZvciIsIlRyYW5zbGF0b3IiLCJzZXJ2aWNlcyIsImNoYW5nZUxhbmd1YWdlIiwibGFuZ3VhZ2UiLCJleGlzdHMiLCJpbnRlcnBvbGF0aW9uIiwicmVzb2x2ZWQiLCJleHRyYWN0RnJvbUtleSIsIm5hbWVzcGFjZXMiLCJ3b3VsZENoZWNrRm9yTnNJbktleSIsInNlZW1zTmF0dXJhbExhbmd1YWdlIiwidXNlckRlZmluZWRLZXlTZXBhcmF0b3IiLCJ1c2VyRGVmaW5lZE5zU2VwYXJhdG9yIiwibWF0Y2giLCJpbnRlcnBvbGF0b3IiLCJuZXN0aW5nUmVnZXhwIiwicGFydHMiLCJ0cmFuc2xhdGUiLCJsYXN0S2V5Iiwib3ZlcmxvYWRUcmFuc2xhdGlvbk9wdGlvbkhhbmRsZXIiLCJyZXR1cm5EZXRhaWxzIiwibmFtZXNwYWNlIiwiYXBwZW5kTmFtZXNwYWNlVG9DSU1vZGUiLCJ0b0xvd2VyQ2FzZSIsInVzZWRLZXkiLCJleGFjdFVzZWRLZXkiLCJ1c2VkTG5nIiwidXNlZE5TIiwidXNlZFBhcmFtcyIsImdldFVzZWRQYXJhbXNEZXRhaWxzIiwicmVzVXNlZEtleSIsInJlc0V4YWN0VXNlZEtleSIsInJlc1R5cGUiLCJ0b1N0cmluZyIsIm5vT2JqZWN0Iiwiam9pbkFycmF5cyIsImhhbmRsZUFzT2JqZWN0SW5JMThuRm9ybWF0IiwiaTE4bkZvcm1hdCIsImhhbmRsZUFzT2JqZWN0IiwicmV0dXJuT2JqZWN0cyIsInJldHVybmVkT2JqZWN0SGFuZGxlciIsInJlc1R5cGVJc0FycmF5IiwibmV3S2V5VG9Vc2UiLCJkZWVwS2V5IiwiZXh0ZW5kVHJhbnNsYXRpb24iLCJ1c2VkRGVmYXVsdCIsIm5lZWRzUGx1cmFsSGFuZGxpbmciLCJjb3VudCIsImhhc0RlZmF1bHRWYWx1ZSIsImRlZmF1bHRWYWx1ZVN1ZmZpeCIsInBsdXJhbFJlc29sdmVyIiwiZ2V0U3VmZml4IiwiZGVmYXVsdFZhbHVlU3VmZml4T3JkaW5hbEZhbGxiYWNrIiwib3JkaW5hbCIsIm5lZWRzWmVyb1N1ZmZpeExvb2t1cCIsInNob3VsZFVzZUludGxBcGkiLCJkZWZhdWx0VmFsdWUiLCJwbHVyYWxTZXBhcmF0b3IiLCJpc1ZhbGlkTG9va3VwIiwibWlzc2luZ0tleU5vVmFsdWVGYWxsYmFja1RvS2V5IiwicmVzRm9yTWlzc2luZyIsInVwZGF0ZU1pc3NpbmciLCJmayIsImxuZ3MiLCJmYWxsYmFja0xuZ3MiLCJsYW5ndWFnZVV0aWxzIiwiZ2V0RmFsbGJhY2tDb2RlcyIsImZhbGxiYWNrTG5nIiwic2F2ZU1pc3NpbmdUbyIsInRvUmVzb2x2ZUhpZXJhcmNoeSIsInNlbmQiLCJsIiwic3BlY2lmaWNEZWZhdWx0VmFsdWUiLCJkZWZhdWx0Rm9yTWlzc2luZyIsIm1pc3NpbmdLZXlIYW5kbGVyIiwiYmFja2VuZENvbm5lY3RvciIsInNhdmVNaXNzaW5nIiwic2F2ZU1pc3NpbmdQbHVyYWxzIiwic3VmZml4ZXMiLCJnZXRTdWZmaXhlcyIsInN1ZmZpeCIsImFwcGVuZE5hbWVzcGFjZVRvTWlzc2luZ0tleSIsInBhcnNlTWlzc2luZ0tleUhhbmRsZXIiLCJfdGhpcyIsImRlZmF1bHRWYXJpYWJsZXMiLCJza2lwSW50ZXJwb2xhdGlvbiIsInNraXBPblZhcmlhYmxlcyIsIm5lc3RCZWYiLCJuYiIsImludGVycG9sYXRlIiwibmEiLCJuZXN0QWZ0IiwibmVzdCIsImNvbnRleHQiLCJyZXNldCIsInBvc3RQcm9jZXNzIiwicG9zdFByb2Nlc3Nvck5hbWVzIiwiYXBwbHlQb3N0UHJvY2Vzc29yIiwicG9zdFByb2Nlc3NQYXNzUmVzb2x2ZWQiLCJpMThuUmVzb2x2ZWQiLCJmb3VuZCIsImV4dHJhY3RlZCIsImZhbGxiYWNrTlMiLCJuZWVkc0NvbnRleHRIYW5kbGluZyIsImNvZGVzIiwidXRpbHMiLCJoYXNMb2FkZWROYW1lc3BhY2UiLCJmaW5hbEtleXMiLCJhZGRMb29rdXBLZXlzIiwicGx1cmFsU3VmZml4IiwiemVyb1N1ZmZpeCIsIm9yZGluYWxQcmVmaXgiLCJjb250ZXh0S2V5IiwiY29udGV4dFNlcGFyYXRvciIsInBvc3NpYmxlS2V5IiwicG9wIiwicmV0dXJuTnVsbCIsInJldHVybkVtcHR5U3RyaW5nIiwicmVzb3VyY2VTdG9yZSIsIm9wdGlvbnNLZXlzIiwidXNlT3B0aW9uc1JlcGxhY2VGb3JEYXRhIiwib3B0aW9uIiwiY2FwaXRhbGl6ZSIsInN0cmluZyIsImNoYXJBdCIsInRvVXBwZXJDYXNlIiwiTGFuZ3VhZ2VVdGlsIiwic3VwcG9ydGVkTG5ncyIsImdldFNjcmlwdFBhcnRGcm9tQ29kZSIsImZvcm1hdExhbmd1YWdlQ29kZSIsImdldExhbmd1YWdlUGFydEZyb21Db2RlIiwic3BlY2lhbENhc2VzIiwibG93ZXJDYXNlTG5nIiwicGFydCIsImNsZWFuQ29kZSIsImlzU3VwcG9ydGVkQ29kZSIsImxvYWQiLCJub25FeHBsaWNpdFN1cHBvcnRlZExuZ3MiLCJnZXRCZXN0TWF0Y2hGcm9tQ29kZXMiLCJjbGVhbmVkTG5nIiwibG5nT25seSIsInN1cHBvcnRlZExuZyIsImZhbGxiYWNrcyIsImRlZmF1bHQiLCJmYWxsYmFja0NvZGUiLCJmYWxsYmFja0NvZGVzIiwiYWRkQ29kZSIsImZjIiwic2V0cyIsIm5yIiwiX3J1bGVzUGx1cmFsc1R5cGVzIiwiTnVtYmVyIiwibm9uSW50bFZlcnNpb25zIiwiaW50bFZlcnNpb25zIiwic3VmZml4ZXNPcmRlciIsInplcm8iLCJvbmUiLCJ0d28iLCJmZXciLCJtYW55Iiwib3RoZXIiLCJjcmVhdGVSdWxlcyIsInJ1bGVzIiwibnVtYmVycyIsInBsdXJhbHMiLCJQbHVyYWxSZXNvbHZlciIsImNvbXBhdGliaWxpdHlKU09OIiwiaW5jbHVkZXMiLCJJbnRsIiwiUGx1cmFsUnVsZXMiLCJhZGRSdWxlIiwiZ2V0UnVsZSIsImVyciIsIm5lZWRzUGx1cmFsIiwicnVsZSIsInJlc29sdmVkT3B0aW9ucyIsInBsdXJhbENhdGVnb3JpZXMiLCJnZXRQbHVyYWxGb3Jtc09mS2V5Iiwic29ydCIsInBsdXJhbENhdGVnb3J5MSIsInBsdXJhbENhdGVnb3J5MiIsInBsdXJhbENhdGVnb3J5IiwicHJlcGVuZCIsIm51bWJlciIsInNlbGVjdCIsImdldFN1ZmZpeFJldHJvQ29tcGF0aWJsZSIsImlkeCIsIm5vQWJzIiwiTWF0aCIsImFicyIsInNpbXBsaWZ5UGx1cmFsU3VmZml4IiwicmV0dXJuU3VmZml4IiwiZGVlcEZpbmRXaXRoRGVmYXVsdHMiLCJJbnRlcnBvbGF0b3IiLCJmb3JtYXQiLCJlc2NhcGVWYWx1ZSIsImVzY2FwZSQxIiwidXNlUmF3VmFsdWVUb0VzY2FwZSIsInByZWZpeEVzY2FwZWQiLCJzdWZmaXhFc2NhcGVkIiwiZm9ybWF0U2VwYXJhdG9yIiwidW5lc2NhcGVTdWZmaXgiLCJ1bmVzY2FwZVByZWZpeCIsIm5lc3RpbmdQcmVmaXgiLCJuZXN0aW5nUHJlZml4RXNjYXBlZCIsIm5lc3RpbmdTdWZmaXgiLCJuZXN0aW5nU3VmZml4RXNjYXBlZCIsIm5lc3RpbmdPcHRpb25zU2VwYXJhdG9yIiwibWF4UmVwbGFjZXMiLCJhbHdheXNGb3JtYXQiLCJyZXNldFJlZ0V4cCIsImdldE9yUmVzZXRSZWdFeHAiLCJleGlzdGluZ1JlZ0V4cCIsImxhc3RJbmRleCIsInJlZ2V4cCIsInJlZ2V4cFVuZXNjYXBlIiwicmVwbGFjZXMiLCJyZWdleFNhZmUiLCJ2YWwiLCJoYW5kbGVGb3JtYXQiLCJpbnRlcnBvbGF0aW9ua2V5IiwidHJpbSIsImYiLCJtaXNzaW5nSW50ZXJwb2xhdGlvbkhhbmRsZXIiLCJ0b2RvcyIsInJlZ2V4Iiwic2FmZVZhbHVlIiwidG9kbyIsImV4ZWMiLCJtYXRjaGVkVmFyIiwidGVtcCIsImNsb25lZE9wdGlvbnMiLCJoYW5kbGVIYXNPcHRpb25zIiwiaW5oZXJpdGVkT3B0aW9ucyIsInNlcCIsIm9wdGlvbnNTdHJpbmciLCJtYXRjaGVkU2luZ2xlUXVvdGVzIiwibWF0Y2hlZERvdWJsZVF1b3RlcyIsImZvcm1hdHRlcnMiLCJkb1JlZHVjZSIsImVsZW0iLCJyZWR1Y2UiLCJwYXJzZUZvcm1hdFN0ciIsImZvcm1hdFN0ciIsImZvcm1hdE5hbWUiLCJmb3JtYXRPcHRpb25zIiwib3B0U3RyIiwiY3VycmVuY3kiLCJyYW5nZSIsIm9wdHMiLCJvcHQiLCJyZXN0IiwidHJpbW1lZEtleSIsImlzTmFOIiwicGFyc2VJbnQiLCJjcmVhdGVDYWNoZWRGb3JtYXR0ZXIiLCJmbiIsImNhY2hlIiwiaW52b2tlRm9ybWF0dGVyIiwiZm9ybWF0dGVyIiwiRm9ybWF0dGVyIiwiZm9ybWF0cyIsIk51bWJlckZvcm1hdCIsInN0eWxlIiwiZGF0ZXRpbWUiLCJEYXRlVGltZUZvcm1hdCIsInJlbGF0aXZldGltZSIsIlJlbGF0aXZlVGltZUZvcm1hdCIsImxpc3QiLCJMaXN0Rm9ybWF0IiwiaU9wdHMiLCJhZGQiLCJhZGRDYWNoZWQiLCJtZW0iLCJmb3JtYXR0ZWQiLCJ2YWxPcHRpb25zIiwiZm9ybWF0UGFyYW1zIiwibG9jYWxlIiwicmVtb3ZlUGVuZGluZyIsInEiLCJwZW5kaW5nIiwicGVuZGluZ0NvdW50IiwiQ29ubmVjdG9yIiwiYmFja2VuZCIsInN0b3JlIiwid2FpdGluZ1JlYWRzIiwibWF4UGFyYWxsZWxSZWFkcyIsInJlYWRpbmdDYWxscyIsIm1heFJldHJpZXMiLCJyZXRyeVRpbWVvdXQiLCJzdGF0ZSIsInF1ZXVlIiwicXVldWVMb2FkIiwibGFuZ3VhZ2VzIiwiY2FsbGJhY2siLCJ0b0xvYWQiLCJ0b0xvYWRMYW5ndWFnZXMiLCJ0b0xvYWROYW1lc3BhY2VzIiwiaGFzQWxsTmFtZXNwYWNlcyIsInJlbG9hZCIsImxvYWRlZCIsImVycm9ycyIsImRvbmUiLCJsb2FkZWRLZXlzIiwicmVhZCIsImZjTmFtZSIsInRyaWVkIiwid2FpdCIsInJlc29sdmVyIiwic2V0VGltZW91dCIsImJpbmQiLCJ0aGVuIiwiY2F0Y2giLCJwcmVwYXJlTG9hZGluZyIsImxvYWRPbmUiLCJmYWxsYmFja1ZhbHVlIiwiaXNVcGRhdGUiLCJjbGIiLCJpbml0SW1tZWRpYXRlIiwicHJlbG9hZCIsInBhcnRpYWxCdW5kbGVkTGFuZ3VhZ2VzIiwicmV0IiwidERlc2NyaXB0aW9uIiwidHJhbnNmb3JtT3B0aW9ucyIsIm5vb3AiLCJiaW5kTWVtYmVyRnVuY3Rpb25zIiwiaW5zdCIsIm1lbXMiLCJnZXRPd25Qcm9wZXJ0eU5hbWVzIiwiZ2V0UHJvdG90eXBlT2YiLCJJMThuIiwibW9kdWxlcyIsImV4dGVybmFsIiwiaXNJbml0aWFsaXplZCIsImlzQ2xvbmUiLCJpc0luaXRpYWxpemluZyIsImRlZk9wdHMiLCJjcmVhdGVDbGFzc09uRGVtYW5kIiwiQ2xhc3NPck9iamVjdCIsImx1IiwibGFuZ3VhZ2VEZXRlY3RvciIsImRldGVjdGlvbiIsInN0b3JlQXBpIiwic3RvcmVBcGlDaGFpbmVkIiwiZGVmZXJyZWQiLCJmaW5pc2giLCJpbml0aWFsaXplZFN0b3JlT25jZSIsImxvYWRSZXNvdXJjZXMiLCJ1c2VkQ2FsbGJhY2siLCJhcHBlbmQiLCJyZXNvbHZlZExhbmd1YWdlIiwic2V0UmVzb2x2ZWRMYW5ndWFnZSIsInJlbG9hZFJlc291cmNlcyIsInVzZSIsIkVycm9yIiwibGkiLCJsbmdJbkxuZ3MiLCJfdGhpczIiLCJpc0xhbmd1YWdlQ2hhbmdpbmdUbyIsInNldExuZ1Byb3BzIiwic2V0TG5nIiwiY2FjaGVVc2VyTGFuZ3VhZ2UiLCJhc3luYyIsImRldGVjdCIsImdldEZpeGVkVCIsImtleVByZWZpeCIsIl90aGlzMyIsImZpeGVkVCIsInJlc3VsdEtleSIsInNldERlZmF1bHROYW1lc3BhY2UiLCJsYXN0TG5nIiwibG9hZE5vdFBlbmRpbmciLCJsb2FkU3RhdGUiLCJwcmVjaGVjayIsInByZVJlc3VsdCIsImxvYWROYW1lc3BhY2VzIiwibG9hZExhbmd1YWdlcyIsInByZWxvYWRlZCIsIm5ld0xuZ3MiLCJkaXIiLCJydGxMbmdzIiwiY3JlYXRlSW5zdGFuY2UiLCJjbG9uZUluc3RhbmNlIiwiZm9ya1Jlc291cmNlU3RvcmUiLCJtZXJnZWRPcHRpb25zIiwibWVtYmVyc1RvQ29weSIsImluc3RhbmNlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/i18next/dist/esm/i18next.js\n");

/***/ })

};
;